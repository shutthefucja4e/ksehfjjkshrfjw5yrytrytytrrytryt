First.
Первым делом в коде должен быть написан package (например package arctic.tech.modules.impl.combat - зависит от темы функции)
Дальше идут импорты (тебе известно)
Дальше ты должен исполнить это как функцию:
@FunctionAnnotation(name = "НазваниеФункции", type = Type.ТипФункции(зависит от package после impl)
public class НазваниеФункции extends Function {
После этого обязательно должен быть:
@Override
    public void onEvent(final Event event) {
}
В этом евенте ты обязан сделать так, чтобы весь код был упомянут в этом эвенте (иначе код работать не будет)
Кроме этого, ты обязан писать только на существующем API Minecraft версии 1.16.5 (MCP)
Также, тебе прийдется использовать следующие сеттинги: BindSetting, BooleanOption, ButtonSetting, ColorSetting, ModeSetting, MultiBoxSetting, SliderSetting, TextSetting
Пример работы каждого я показывать не буду, но например давай покажу ModeSetting и BooleanOption
Например ModeSetting:
public ModeSetting mode = new ModeSetting("Mode", "Test", "Test", "Test1");
public BooleanOption smart = new BooleanOption("Тестить", true);
Если так таковые сеттинги имеются, тогда прийдется создать тебе паблик
Примерно будет так:
public TestFunction() {
    addSettings(test, test1); / Тут ты пишешь заместо test, test1 названия сеттингов
}
Тебе нельзя выдумывать классы из головы. Нужно действовать строго по базе

RenderUtil (ui)
package arctic.tech.util.render;

import arctic.tech.modules.impl.util.Optimization;
import arctic.tech.ui.midnight.Style;
import arctic.tech.util.IMinecraft;
import com.google.common.collect.Lists;
import com.mojang.blaze3d.platform.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import jhlabs.image.GaussianFilter;
import net.minecraft.client.MainWindow;
import net.minecraft.client.entity.player.AbstractClientPlayerEntity;
import net.minecraft.client.gui.AbstractGui;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.WorldVertexBufferUploader;
import net.minecraft.client.renderer.texture.DynamicTexture;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.shader.Framebuffer;
import net.minecraft.entity.LivingEntity;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.vector.Vector4f;
import net.optifine.util.TextureUtils;
import org.joml.Vector4i;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.EXTFramebufferObject;
import org.lwjgl.opengl.EXTPackedDepthStencil;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL30;
import arctic.tech.managment.Managment;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import static com.mojang.blaze3d.platform.GlStateManager.GL_QUADS;
import static com.mojang.blaze3d.platform.GlStateManager.disableBlend;
import static com.mojang.blaze3d.platform.GlStateManager.*;
import static com.mojang.blaze3d.systems.RenderSystem.enableBlend;
import static net.minecraft.client.renderer.vertex.DefaultVertexFormats.*;
import static org.lwjgl.opengl.GL11.*;
import static arctic.tech.util.render.RenderUtil.IntColor.*;


public class RenderUtil implements IMinecraft {
    public static int reAlphaInt(final int color,
                                 final int alpha) {
        return (MathHelper.clamp(alpha, 0, 255) << 24) | (color & 16777215);
    }

    public static void color(final int rgb) {
        GL11.glColor3f(getRed(rgb) / 255f, getGreen(rgb) / 255f, getBlue(rgb) / 255f);
    }

    public static boolean isInRegion(final int mouseX,
                                     final int mouseY,
                                     final int x,
                                     final int y,
                                     final int width,
                                     final int height) {
        return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;
    }

    public static boolean isInRegion(final double mouseX,
                                     final double mouseY,
                                     final float x,
                                     final float y,
                                     final float width,
                                     final float height) {
        return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;
    }

    public static boolean isInRegion(final double mouseX,
                                     final double mouseY,
                                     final int x,
                                     final int y,
                                     final int width,
                                     final int height) {
        return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;
    }

    public static class IntColor {

        public static float[] rgb(final int color) {
            return new float[]{
                    (color >> 16 & 0xFF) / 255f,
                    (color >> 8 & 0xFF) / 255f,
                    (color & 0xFF) / 255f,
                    (color >> 24 & 0xFF) / 255f
            };
        }

        public static int rgba(final int r,
                               final int g,
                               final int b,
                               final int a) {
            return a << 24 | r << 16 | g << 8 | b;
        }

        public static int getRed(final int hex) {
            return hex >> 16 & 255;
        }

        public static int getGreen(final int hex) {
            return hex >> 8 & 255;
        }

        public static int getBlue(final int hex) {
            return hex & 255;
        }

        public static int getAlpha(final int hex) {
            return hex >> 24 & 255;
        }
    }


    public static class Render2D {

        private static final HashMap<Integer, Integer> shadowCache = new HashMap<>();

        public static void drawTriangle(float x, float y, float width, float height, Color color) {
            GL11.glPushMatrix();
            GL11.glDisable(GL11.GL_TEXTURE_2D);
            enableSmoothLine(1);
            GL11.glRotatef(180 + 90, 0F, 0F, 1.0F);

            // fill.
            GL11.glBegin(9);
            ColorUtil.setColor(color.getRGB());
            GL11.glVertex2f(x, y - 2);
            GL11.glVertex2f(x + width, y + height);
            GL11.glVertex2f(x + width, y);
            GL11.glVertex2f(x, y - 2);
            GL11.glEnd();

            GL11.glBegin(9);
            ColorUtil.setColor(color.brighter().getRGB());
            GL11.glVertex2f(x + width, y);
            GL11.glVertex2f(x + width, y + height);
            GL11.glVertex2f(x + width * 2, y - 2);
            GL11.glVertex2f(x + width, y);
            GL11.glEnd();

            // line.
            GL11.glBegin(3);
            ColorUtil.setColor(color.getRGB());
            GL11.glVertex2f(x, y - 2);
            GL11.glVertex2f(x + width, y + height);
            GL11.glVertex2f(x + width, y);
            GL11.glVertex2f(x, y - 2);
            GL11.glEnd();

            GL11.glBegin(3);
            ColorUtil.setColor(color.brighter().getRGB());
            GL11.glVertex2f(x + width, y);
            GL11.glVertex2f(x + width, y + height);
            GL11.glVertex2f(x + width * 2, y - 2);
            GL11.glVertex2f(x + width, y);
            GL11.glEnd();

            disableSmoothLine();
            GL11.glEnable(GL11.GL_TEXTURE_2D);
            GL11.glRotatef(-180 - 90, 0F, 0F, 1.0F);
            GL11.glPopMatrix();
        }

        public static void drawTriangle(float x, float y, float width, float height, float vector, int color) {
            GL11.glPushMatrix();
            GL11.glDisable(GL11.GL_TEXTURE_2D);
            enableSmoothLine(1);
            GL11.glRotatef(180 + vector, 0F, 0F, 1.0F);

            // fill.
            GL11.glBegin(9);
            ColorUtil.setColor(color);
            GL11.glVertex2f(x, y - 2);
            GL11.glVertex2f(x + width, y + height);
            GL11.glVertex2f(x + width, y);
            GL11.glVertex2f(x, y - 2);
            GL11.glEnd();

            disableSmoothLine();
            GL11.glEnable(GL11.GL_TEXTURE_2D);
            GL11.glRotatef(-180 - vector, 0F, 0F, 1.0F);
            GL11.glPopMatrix();
        }

        public static void enableSmoothLine(float width) {
            GL11.glDisable(GL11.GL_ALPHA_TEST);
            GL11.glEnable(GL11.GL_BLEND);
            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
            GL11.glDepthMask(false);
            GL11.glEnable(GL11.GL_LINE_SMOOTH);
            GL11.glHint(GL11.GL_LINE_SMOOTH_HINT, GL11.GL_NICEST);
            GL11.glLineWidth(width);
        }

        public static void disableSmoothLine() {
            GL11.glEnable(GL11.GL_ALPHA_TEST);
            GL11.glDepthMask(true);
            GL11.glDisable(GL11.GL_LINE_SMOOTH);
            GL11.glHint(GL11.GL_LINE_SMOOTH_HINT, GL11.GL_NICEST);
        }

        public static int downloadImage(String url) {
            int texId = -1;
            int identifier = Objects.hash(url);
            if (shadowCache2.containsKey(identifier)) {
                texId = shadowCache2.get(identifier);
            } else {
                URL stringURL = null;
                try {
                    stringURL = new URL(url);
                } catch (MalformedURLException e) {
                    throw new RuntimeException(e);
                }
                BufferedImage img = null;
                try {
                    img = ImageIO.read(stringURL);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }


                try {
                    texId = loadTexture(img);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                shadowCache2.put(identifier, texId);
            }
            return texId;
        }


        private static HashMap<Integer, Integer> shadowCache2 = new HashMap<Integer, Integer>();


        public static void drawShadow(float x, float y, float width, float height, int radius, int color) {
            Optimization optimization = Managment.FUNCTION_MANAGER.optimization;

            if (optimization.state && optimization.optimizeSelection.get(2)) {
                return;
            }

            GlStateManager.enableBlend();
            GlStateManager.blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            GlStateManager.alphaFunc(GL_GREATER, 0.01f);
            GlStateManager.disableAlphaTest();

            x -= radius;
            y -= radius;
            width = width + radius * 2;
            height = height + radius * 2;
            x -= 0.25f;
            y += 0.25f;

            int identifier = Objects.hash(width, height, radius);
            int textureId;

            if (shadowCache.containsKey(identifier)) {
                textureId = shadowCache.get(identifier);
                GlStateManager.bindTexture(textureId);
            } else {
                if (width <= 0) {
                    width = 1;
                }

                if (height <= 0) {
                    height = 1;
                }

                BufferedImage originalImage = new BufferedImage((int) width, (int) height, BufferedImage.TYPE_INT_ARGB_PRE);
                Graphics2D graphics = originalImage.createGraphics();
                graphics.setColor(Color.WHITE);
                graphics.fillRect(radius, radius, (int) (width - radius * 2), (int) (height - radius * 2));
                graphics.dispose();

                GaussianFilter filter = new GaussianFilter(radius);
                BufferedImage blurredImage = filter.filter(originalImage, null);
                DynamicTexture texture = new DynamicTexture(TextureUtils.toNativeImage(blurredImage));
                texture.setBlurMipmap(true, true);
                try {
                    textureId = texture.getGlTextureId();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                shadowCache.put(identifier, textureId);
            }

            float[] startColorComponents = rgb(color);

            buffer.begin(GL_QUADS, POSITION_COLOR_TEX);
            buffer.pos(x, y, 0.0f)
                    .color(startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3])
                    .tex(0.0f, 0.0f)
                    .endVertex();

            buffer.pos(x, y + (float) ((int) height), 0.0f)
                    .color(startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3])
                    .tex(0.0f, 1.0f)
                    .endVertex();

            buffer.pos(x + (float) ((int) width), y + (float) ((int) height), 0.0f)
                    .color(startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3])
                    .tex(1.0f, 1.0f)
                    .endVertex();

            buffer.pos(x + (float) ((int) width), y, 0.0f)
                    .color(startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3])
                    .tex(1.0f, 0.0f)
                    .endVertex();

            tessellator.draw();
            GlStateManager.enableAlphaTest();
            GlStateManager.bindTexture(0);
            GlStateManager.disableBlend();
        }


        public static void drawShadow(float x, float y, float width, float height, int radius, int startColor, int endColor) {
            Optimization optimization = Managment.FUNCTION_MANAGER.optimization;

            if (optimization.state && optimization.optimizeSelection.get(2)) {
                return;
            }

            GlStateManager.enableBlend();
            GlStateManager.blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            GlStateManager.alphaFunc(GL_GREATER, 0.01f);

            x -= radius;
            y -= radius;
            width = width + radius * 2;
            height = height + radius * 2;
            x -= 0.25f;
            y += 0.25f;

            int identifier = Objects.hash(width, height, radius);
            int textureId;

            if (shadowCache.containsKey(identifier)) {
                textureId = shadowCache.get(identifier);
                GlStateManager.bindTexture(textureId);
            } else {
                if (width <= 0) {
                    width = 1;
                }

                if (height <= 0) {
                    height = 1;
                }

                BufferedImage originalImage = new BufferedImage((int) width, (int) height, BufferedImage.TYPE_INT_ARGB_PRE);
                Graphics2D graphics = originalImage.createGraphics();
                graphics.setColor(Color.WHITE);
                graphics.fillRect(radius, radius, (int) (width - radius * 2), (int) (height - radius * 2));
                graphics.dispose();

                GaussianFilter filter = new GaussianFilter(radius);
                BufferedImage blurredImage = filter.filter(originalImage, null);
                DynamicTexture texture = new DynamicTexture(TextureUtils.toNativeImage(blurredImage));
                texture.setBlurMipmap(true, true);
                try {
                    textureId = texture.getGlTextureId();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                shadowCache.put(identifier, textureId);
            }

            float[] startColorComponents = rgb(startColor);
            float[] endColorComponents = rgb(endColor);

            buffer.begin(GL_QUADS, POSITION_COLOR_TEX);
            buffer.pos(x, y, 0.0f)
                    .color(startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3])
                    .tex(0.0f, 0.0f)
                    .endVertex();

            buffer.pos(x, y + (float) ((int) height), 0.0f)
                    .color(startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3])
                    .tex(0.0f, 1.0f)
                    .endVertex();

            buffer.pos(x + (float) ((int) width), y + (float) ((int) height), 0.0f)
                    .color(endColorComponents[0], endColorComponents[1], endColorComponents[2], endColorComponents[3])
                    .tex(1.0f, 1.0f)
                    .endVertex();

            buffer.pos(x + (float) ((int) width), y, 0.0f)
                    .color(endColorComponents[0], endColorComponents[1], endColorComponents[2], endColorComponents[3])
                    .tex(1.0f, 0.0f)
                    .endVertex();

            tessellator.draw();

            GlStateManager.bindTexture(0);
            GlStateManager.disableBlend();
        }

        public static void drawShadow(float x, float y, float width, float height, int radius, int bottomLeft, int topLeft, int bottomRight, int topRight) {
            Optimization optimization = Managment.FUNCTION_MANAGER.optimization;

            if (optimization.state && optimization.optimizeSelection.get(2)) {
                return;
            }

            GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA.param,
                    DestFactor.ONE_MINUS_SRC_ALPHA.param, SourceFactor.ONE.param,
                    DestFactor.ZERO.param);
            GlStateManager.shadeModel(7425);

            GlStateManager.enableBlend();
            GlStateManager.blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            GlStateManager.alphaFunc(GL_GREATER, 0.01f);

            x -= radius;
            y -= radius;
            width = width + radius * 2;
            height = height + radius * 2;
            x -= 0.25f;
            y += 0.25f;

            int identifier = Objects.hash(width, height, radius);
            int textureId;

            if (shadowCache.containsKey(identifier)) {
                textureId = shadowCache.get(identifier);
                GlStateManager.bindTexture(textureId);
            } else {
                if (width <= 0) {
                    width = 1;
                }

                if (height <= 0) {
                    height = 1;
                }

                BufferedImage originalImage = new BufferedImage((int) width, (int) height, BufferedImage.TYPE_INT_ARGB_PRE);
                Graphics2D graphics = originalImage.createGraphics();
                graphics.setColor(Color.WHITE);
                graphics.fillRect(radius, radius, (int) (width - radius * 2), (int) (height - radius * 2));
                graphics.dispose();

                GaussianFilter filter = new GaussianFilter(radius);
                BufferedImage blurredImage = filter.filter(originalImage, null);
                DynamicTexture texture = new DynamicTexture(TextureUtils.toNativeImage(blurredImage));
                texture.setBlurMipmap(true, true);
                try {
                    textureId = texture.getGlTextureId();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                shadowCache.put(identifier, textureId);
            }

            float[] bottomLefts = rgb(bottomLeft);
            float[] topLefts = rgb(topLeft);
            float[] bottomRights = rgb(bottomRight);
            float[] topRights = rgb(topRight);

            buffer.begin(GL_QUADS, POSITION_COLOR_TEX);
            buffer.pos(x, y, 0.0f)
                    .color(bottomLefts[0], bottomLefts[1], bottomLefts[2], bottomLefts[3])
                    .tex(0.0f, 0.0f)
                    .endVertex();

            buffer.pos(x, y + (float) ((int) height), 0.0f)
                    .color(topLefts[0], topLefts[1], topLefts[2], topLefts[3])
                    .tex(0.0f, 1.0f)
                    .endVertex();

            buffer.pos(x + (float) ((int) width), y + (float) ((int) height), 0.0f)
                    .color(topRights[0], topRights[1], topRights[2], topRights[3])
                    .tex(1.0f, 1.0f)
                    .endVertex();

            buffer.pos(x + (float) ((int) width), y, 0.0f)
                    .color(bottomRights[0], bottomRights[1], bottomRights[2], bottomRights[3])
                    .tex(1.0f, 0.0f)
                    .endVertex();

            tessellator.draw();
            GlStateManager.shadeModel(7424);
            GlStateManager.bindTexture(0);
            GlStateManager.disableBlend();
        }


        public static void drawCircle(float x, float y, float start, float end, float radius, float width, boolean filled, Style s) {

            float i;
            float endOffset;
            if (start > end) {
                endOffset = end;
                end = start;
                start = endOffset;
            }
            GlStateManager.enableBlend();
            RenderSystem.disableAlphaTest();
            GL11.glDisable(GL_TEXTURE_2D);
            RenderSystem.blendFuncSeparate(770, 771, 1, 0);
            RenderSystem.shadeModel(7425);
            GL11.glEnable(GL11.GL_LINE_SMOOTH);
            GL11.glLineWidth(width);

            GL11.glBegin(GL11.GL_LINE_STRIP);
            for (i = end; i >= start; i--) {
                ColorUtil.setColor(s.getColor((int) (i * 1)));
                float cos = (float) (MathHelper.cos((float) (i * Math.PI / 180)) * radius);
                float sin = (float) (MathHelper.sin((float) (i * Math.PI / 180)) * radius);
                GL11.glVertex2f(x + cos, y + sin);
            }
            GL11.glEnd();
            GL11.glDisable(GL11.GL_LINE_SMOOTH);
            if (filled) {
                GL11.glBegin(GL11.GL_TRIANGLE_FAN);
                for (i = end; i >= start; i--) {
                    ColorUtil.setColor(s.getColor((int) (i * 1)));
                    float cos = (float) MathHelper.cos((float) (i * Math.PI / 180)) * radius;
                    float sin = (float) MathHelper.sin((float) (i * Math.PI / 180)) * radius;
                    GL11.glVertex2f(x + cos, y + sin);
                }
                GL11.glEnd();
            }

            RenderSystem.enableAlphaTest();
            RenderSystem.shadeModel(7424);
            GL11.glEnable(GL_TEXTURE_2D);
            GlStateManager.disableBlend();
        }

        public static void drawCircle(float x, float y, float start, float end, float radius, float width, boolean filled, int color) {

            float i;
            float endOffset;
            if (start > end) {
                endOffset = end;
                end = start;
                start = endOffset;
            }

            GlStateManager.enableBlend();
            GL11.glDisable(GL_TEXTURE_2D);
            RenderSystem.blendFuncSeparate(770, 771, 1, 0);

            GL11.glEnable(GL11.GL_LINE_SMOOTH);
            GL11.glLineWidth(width);
            GL11.glBegin(GL11.GL_LINE_STRIP);
            for (i = end; i >= start; i--) {
                ColorUtil.setColor(color);
                float cos = (float) (MathHelper.cos((float) (i * Math.PI / 180)) * radius);
                float sin = (float) (MathHelper.sin((float) (i * Math.PI / 180)) * radius);
                GL11.glVertex2f(x + cos, y + sin);
            }
            GL11.glEnd();
            GL11.glDisable(GL11.GL_LINE_SMOOTH);

            if (filled) {
                GL11.glBegin(GL11.GL_TRIANGLE_FAN);
                for (i = end; i >= start; i--) {
                    ColorUtil.setColor(color);
                    float cos = (float) MathHelper.cos((float) (i * Math.PI / 180)) * radius;
                    float sin = (float) MathHelper.sin((float) (i * Math.PI / 180)) * radius;
                    GL11.glVertex2f(x + cos, y + sin);
                }
                GL11.glEnd();
            }

            GL11.glEnable(GL_TEXTURE_2D);
            GlStateManager.disableBlend();
        }

        public static int loadTexture(BufferedImage image) throws Exception {
            int[] pixels = image.getRGB(0, 0, image.getWidth(), image.getHeight(), null, 0, image.getWidth());
            ByteBuffer buffer = BufferUtils.createByteBuffer(pixels.length * 4);

            for (int pixel : pixels) {
                buffer.put((byte) ((pixel >> 16) & 0xFF));
                buffer.put((byte) ((pixel >> 8) & 0xFF));
                buffer.put((byte) (pixel & 0xFF));
                buffer.put((byte) ((pixel >> 24) & 0xFF));
            }
            buffer.flip();

            int textureID = GlStateManager.genTexture();
            GlStateManager.bindTexture(textureID);
            GL30.glTexParameteri(GL30.GL_TEXTURE_2D, GL30.GL_TEXTURE_WRAP_S, GL30.GL_CLAMP_TO_EDGE);
            GL30.glTexParameteri(GL30.GL_TEXTURE_2D, GL30.GL_TEXTURE_WRAP_T, GL30.GL_CLAMP_TO_EDGE);
            GL30.glTexParameteri(GL30.GL_TEXTURE_2D, GL30.GL_TEXTURE_MIN_FILTER, GL30.GL_LINEAR);
            GL30.glTexParameteri(GL30.GL_TEXTURE_2D, GL30.GL_TEXTURE_MAG_FILTER, GL30.GL_LINEAR);
            GL30.glTexImage2D(GL30.GL_TEXTURE_2D, 0, GL30.GL_RGBA8, image.getWidth(), image.getHeight(), 0, GL30.GL_RGBA, GL30.GL_UNSIGNED_BYTE, buffer);
            GlStateManager.bindTexture(0);
            return textureID;
        }

        public static void drawFace(float d,
                                    float y,
                                    float u,
                                    float v,
                                    float uWidth,
                                    float vHeight,
                                    float width,
                                    float height,
                                    float tileWidth,
                                    float tileHeight,
                                    AbstractClientPlayerEntity target) {
            try {
                GL11.glPushMatrix();
                GL11.glEnable(GL11.GL_BLEND);
                ResourceLocation skin = target.getLocationSkin();
                mc.getTextureManager().bindTexture(skin);
                float hurtPercent = getHurtPercent(target);
                GL11.glColor4f(1, 1 - hurtPercent, 1 - hurtPercent, 1);
                AbstractGui.drawScaledCustomSizeModalRect(d, y, u, v, uWidth, vHeight, width, height, tileWidth, tileHeight);
                GL11.glColor4f(1, 1, 1, 1);
                GL11.glPopMatrix();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public static void drawFace(float x, float y, float width, float height) {
            try {
                AbstractGui.drawScaledCustomSizeModalRect(x, y, 8, 8, 8, 8, width, height, 64, 64);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public static float getRenderHurtTime(LivingEntity hurt) {
            return (float) hurt.hurtTime - (hurt.hurtTime != 0 ? mc.timer.renderPartialTicks : 0.0f);
        }

        public static float getHurtPercent(LivingEntity hurt) {
            return getRenderHurtTime(hurt) / (float) 10;
        }

        public static void drawRect(float x,
                                    float y,
                                    float width,
                                    float height,
                                    int color) {

            drawMcRect(x, y, x + width, y + height, color);
        }

        public static void drawRoundCircle(float x,
                                           float y,
                                           float radius,
                                           int color) {
            drawRoundedRect(x - (radius / 2), y - (radius / 2), radius, radius, (radius / 2) - 0.5f, color);
        }

        public static void drawRoundCircle(float x,
                                           float y,
                                           float radius,
                                           int bottomLeft, int topLeft, int bottomRight, int topRight) {
            drawGradientRound(x - (radius / 2), y - (radius / 2), radius, radius, (radius / 2), bottomLeft,topLeft,bottomRight,topRight);
        }

        public static void drawMcRect(double left,
                                      double top,
                                      double right,
                                      double bottom,
                                      int color) {
            if (left < right) {
                double i = left;
                left = right;
                right = i;
            }

            if (top < bottom) {
                double j = top;
                top = bottom;
                bottom = j;
            }

            float f3 = (float) (color >> 24 & 255) / 255.0F;
            float f = (float) (color >> 16 & 255) / 255.0F;
            float f1 = (float) (color >> 8 & 255) / 255.0F;
            float f2 = (float) (color & 255) / 255.0F;
            BufferBuilder bufferbuilder = Tessellator.getInstance().getBuffer();
            RenderSystem.enableBlend();
            RenderSystem.disableTexture();
            RenderSystem.defaultBlendFunc();
            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
            bufferbuilder.pos(left, bottom, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(right, bottom, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(right, top, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(left, top, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.finishDrawing();
            WorldVertexBufferUploader.draw(bufferbuilder);
            RenderSystem.enableTexture();
            RenderSystem.disableBlend();
        }

        public static void drawLine(double x,
                                      double y,
                                      double z,
                                      double w,
                                      int color) {


            float f3 = (float) (color >> 24 & 255) / 255.0F;
            float f = (float) (color >> 16 & 255) / 255.0F;
            float f1 = (float) (color >> 8 & 255) / 255.0F;
            float f2 = (float) (color & 255) / 255.0F;
            BufferBuilder bufferbuilder = Tessellator.getInstance().getBuffer();
            RenderSystem.enableBlend();
            RenderSystem.disableTexture();
            RenderSystem.defaultBlendFunc();
            GL11.glEnable(GL_LINE_SMOOTH);
            RenderSystem.lineWidth(1.5f);
            bufferbuilder.begin(GL_LINES, DefaultVertexFormats.POSITION_COLOR);
            bufferbuilder.pos(x, y, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(z, w, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.finishDrawing();
            WorldVertexBufferUploader.draw(bufferbuilder);
            GL11.glDisable(GL_LINE_SMOOTH);
            RenderSystem.enableTexture();
            RenderSystem.disableBlend();
        }




        public static void drawMcRectBuilding(double left,
                                      double top,
                                      double right,
                                      double bottom,
                                      int color) {
            if (left < right) {
                double i = left;
                left = right;
                right = i;
            }

            if (top < bottom) {
                double j = top;
                top = bottom;
                bottom = j;
            }

            float f3 = (float) (color >> 24 & 255) / 255.0F;
            float f = (float) (color >> 16 & 255) / 255.0F;
            float f1 = (float) (color >> 8 & 255) / 255.0F;
            float f2 = (float) (color & 255) / 255.0F;
            BufferBuilder bufferbuilder = Tessellator.getInstance().getBuffer();
            //bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
            bufferbuilder.pos(left, bottom, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(right, bottom, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(right, top, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(left, top, 0.0F).color(f, f1, f2, f3).endVertex();
            //bufferbuilder.finishDrawing();
            //WorldVertexBufferUploader.draw(bufferbuilder);
        }

        public static void drawRectBuilding(double left,
                                              double top,
                                              double right,
                                              double bottom,
                                              int color) {
            right += left;
            bottom += top;

            if (left < right) {
                double i = left;
                left = right;
                right = i;
            }

            if (top < bottom) {
                double j = top;
                top = bottom;
                bottom = j;
            }

            float f3 = (float) (color >> 24 & 255) / 255.0F;
            float f = (float) (color >> 16 & 255) / 255.0F;
            float f1 = (float) (color >> 8 & 255) / 255.0F;
            float f2 = (float) (color & 255) / 255.0F;
            BufferBuilder bufferbuilder = Tessellator.getInstance().getBuffer();
            //bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
            bufferbuilder.pos(left, bottom, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(right, bottom, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(right, top, 0.0F).color(f, f1, f2, f3).endVertex();
            bufferbuilder.pos(left, top, 0.0F).color(f, f1, f2, f3).endVertex();
            //bufferbuilder.finishDrawing();
            //WorldVertexBufferUploader.draw(bufferbuilder);
        }


        public static void drawRectOutlineBuilding(double x, double y, double width, double height, double size, int color) {
           drawMcRectBuilding(x + size, y, width - size, y + size, color);
           drawMcRectBuilding(x, y, x + size, height, color);
           drawMcRectBuilding(width - size, y, width, height, color);
           drawMcRectBuilding(x + size, height - size, width - size, height, color);
        }
        public static void drawRectOutlineBuildingGradient(double x, double y, double width, double height, double size, Vector4i colors) {
            drawMCHorizontalBuilding(x + size, y, width - size, y + size, colors.x, colors.z);
            drawMCVerticalBuilding(x, y, x + size, height, colors.z, colors.x);

            drawMCVerticalBuilding(width - size, y, width, height, colors.x, colors.z);
            drawMCHorizontalBuilding(x + size, height - size, width - size, height, colors.z, colors.x);
        }

        public static void drawMCHorizontal(double x,
                                            double y,
                                            double width,
                                            double height,
                                          int start,
                                          int end) {


            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;

            RenderSystem.disableTexture();
            RenderSystem.enableBlend();
            RenderSystem.disableAlphaTest();
            RenderSystem.defaultBlendFunc();
            RenderSystem.shadeModel(7425);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f1, f2, f3, f).endVertex();

            tessellator.draw();
            RenderSystem.shadeModel(7424);
            RenderSystem.disableBlend();
            RenderSystem.enableAlphaTest();
            RenderSystem.enableTexture();
        }

        public static void drawMCHorizontalBuilding(double x,
                                            double y,
                                            double width,
                                            double height,
                                            int start,
                                            int end) {


            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;


            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            //bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f1, f2, f3, f).endVertex();

            //tessellator.draw();

        }


        public static void drawHorizontal(float x,
                                          float y,
                                          float width,
                                          float height,
                                          int start,
                                          int end) {

            width += x;
            height += y;

            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;

            RenderSystem.disableTexture();
            RenderSystem.enableBlend();
            RenderSystem.disableAlphaTest();
            RenderSystem.defaultBlendFunc();
            RenderSystem.shadeModel(7425);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f1, f2, f3, f).endVertex();

            tessellator.draw();
            RenderSystem.shadeModel(7424);
            RenderSystem.disableBlend();
            RenderSystem.enableAlphaTest();
            RenderSystem.enableTexture();
        }

        public static void applyGradient(float x, float y, float width, float height, int bottomLeft, int topLeft, int bottomRight, int topRight, Runnable content) {
            GlStateManager.enableBlend();
            GlStateManager.blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            ShaderUtil.GRADIENT_MASK_SHADER.attach();
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("location", (float) (x * 2), (float) ((sr.getHeight() - (height * 2)) - (y * 2)));
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("rectSize", (float) (width * 2), (float) (height * 2));
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("tex", 2);
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("alpha", 1f);

            float[] bottoml = IntColor.rgb(bottomLeft);
            float[] topl = IntColor.rgb(topLeft);
            float[] bottomr = IntColor.rgb(bottomRight);
            float[] topr = IntColor.rgb(topRight);

            // Bottom Left
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("color1", bottoml[0], bottoml[1], bottoml[2]);
            //Top left
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("color2", topl[0], topl[1], topl[2]);
            //Bottom Right
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("color3", bottomr[0], bottomr[1], bottomr[2]);
            //Top Right
            ShaderUtil.GRADIENT_MASK_SHADER.setUniform("color4", topr[0], topr[1], topr[2]);

            //Apply the gradient to whatever is put here
            content.run();

            ShaderUtil.GRADIENT_MASK_SHADER.detach();
            GlStateManager.disableBlend();
        }

        public static void drawVertical(float x,
                                        float y,
                                        float width,
                                        float height,
                                        int start,
                                        int end) {
            width += x;
            height += y;

            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;

            RenderSystem.disableTexture();
            RenderSystem.enableBlend();
            RenderSystem.disableAlphaTest();
            RenderSystem.defaultBlendFunc();
            RenderSystem.shadeModel(7425);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f5, f6, f7, f4).endVertex();

            tessellator.draw();
            RenderSystem.shadeModel(7424);
            RenderSystem.disableBlend();
            RenderSystem.enableAlphaTest();
            RenderSystem.enableTexture();

        }

        public static void drawMCVertical(double x,
                                          double y,
                                          double width,
                                          double height,
                                          int start,
                                          int end) {

            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;

            RenderSystem.disableTexture();
            RenderSystem.enableBlend();
            RenderSystem.disableAlphaTest();
            RenderSystem.defaultBlendFunc();
            RenderSystem.shadeModel(7425);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f5, f6, f7, f4).endVertex();

            tessellator.draw();
            RenderSystem.shadeModel(7424);
            RenderSystem.disableBlend();
            RenderSystem.enableAlphaTest();
            RenderSystem.enableTexture();

        }

        public static void drawMCVerticalBuilding(double x,
                                          double y,
                                          double width,
                                          double height,
                                          int start,
                                          int end) {

            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;

//            RenderSystem.disableTexture();
//            RenderSystem.enableBlend();
//            RenderSystem.disableAlphaTest();
//            RenderSystem.defaultBlendFunc();
//            RenderSystem.shadeModel(7425);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            //bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f5, f6, f7, f4).endVertex();

            //tessellator.draw();
//            RenderSystem.shadeModel(7424);
//            RenderSystem.disableBlend();
//            RenderSystem.enableAlphaTest();
//            RenderSystem.enableTexture();

        }

        public static void drawVerticalBuilding(double x,
                                                  double y,
                                                  double width,
                                                  double height,
                                                  int start,
                                                  int end) {

            width += x;
            height += y;

            float f = (float) (start >> 24 & 255) / 255.0F;
            float f1 = (float) (start >> 16 & 255) / 255.0F;
            float f2 = (float) (start >> 8 & 255) / 255.0F;
            float f3 = (float) (start & 255) / 255.0F;
            float f4 = (float) (end >> 24 & 255) / 255.0F;
            float f5 = (float) (end >> 16 & 255) / 255.0F;
            float f6 = (float) (end >> 8 & 255) / 255.0F;
            float f7 = (float) (end & 255) / 255.0F;

//            RenderSystem.disableTexture();
//            RenderSystem.enableBlend();
//            RenderSystem.disableAlphaTest();
//            RenderSystem.defaultBlendFunc();
//            RenderSystem.shadeModel(7425);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferbuilder = tessellator.getBuffer();
            //bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);

            bufferbuilder.pos(x, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, height, 0f).color(f1, f2, f3, f).endVertex();
            bufferbuilder.pos(width, y, 0f).color(f5, f6, f7, f4).endVertex();
            bufferbuilder.pos(x, y, 0f).color(f5, f6, f7, f4).endVertex();

            //tessellator.draw();
//            RenderSystem.shadeModel(7424);
//            RenderSystem.disableBlend();
//            RenderSystem.enableAlphaTest();
//            RenderSystem.enableTexture();

        }

        public static void drawTexture(final float x,
                                       final float y,
                                       final float width,
                                       final float height,
                                       final float radius,
                                       final float alpha) {
            pushMatrix();
            enableBlend();
            blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            ShaderUtil.TEXTURE_ROUND_SHADER.attach();

            ShaderUtil.TEXTURE_ROUND_SHADER.setUniform("rectSize", (float) (width * 2), (float) (height * 2));
            ShaderUtil.TEXTURE_ROUND_SHADER.setUniform("radius", radius * 2);
            ShaderUtil.TEXTURE_ROUND_SHADER.setUniform("alpha", alpha);

            quadsBegin(x, y, width, height, 7);


            ShaderUtil.TEXTURE_ROUND_SHADER.detach();
            popMatrix();
        }

        private static Framebuffer framebuffer = new Framebuffer(1,1,true, false);

        public static void drawTextureTest(float x, float y, double width, double height,
                                       final float radius,
                                       final float alpha) {
            //setupFram(framebuffer)
            pushMatrix();
            enableBlend();
            blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            ShaderUtil.TEXTURE_ROUND_SHADER.attach();

            ShaderUtil.TEXTURE_ROUND_SHADER.setUniform("rectSize", (float) (width * 2), (float) (height * 2));
            ShaderUtil.TEXTURE_ROUND_SHADER.setUniform("radius", radius * 2);
            ShaderUtil.TEXTURE_ROUND_SHADER.setUniform("alpha", alpha);

            AbstractGui.drawScaledCustomSizeModalRect(x, y, 8F, 8F, 8F, 8F, (float) width, (float) height, 64, 64);
            //quadsBegin(x,y, (float) width, (float) height,7);

            ShaderUtil.TEXTURE_ROUND_SHADER.detach();
            popMatrix();
        }


        public static void quadsBegin(float x, float y, float width, float height, int glQuads) {
            buffer.begin(glQuads, POSITION_TEX);
            {
                buffer.pos(x, y, 0).tex(0, 0).endVertex();
                buffer.pos(x, y + height, 0).tex(0, 1).endVertex();
                buffer.pos(x + width, y + height, 0).tex(1, 1).endVertex();
                buffer.pos(x + width, y, 0).tex(1, 0).endVertex();
            }
            tessellator.draw();
        }

        public static void quadsBeginC(float x, float y, float width, float height, int glQuads, Vector4i color) {
            buffer.begin(glQuads, POSITION_TEX_COLOR);
            {



                buffer.pos(x, y, 0).tex(0, 0).color(color.get(0)).endVertex();
                buffer.pos(x, y + height, 0).tex(0, 1).color(color.get(1)).endVertex();
                buffer.pos(x + width, y + height, 0).tex(1, 1).color(color.get(2)).endVertex();
                buffer.pos(x + width, y, 0).tex(1, 0).color(color.get(3)).endVertex();
            }
            tessellator.draw();
        }


        public static void drawRoundedRect(float x,
                                           float y,
                                           float width,
                                           float height,
                                           float radius,
                                           int color) {
            pushMatrix();
            enableBlend();
            ShaderUtil.ROUND_SHADER.attach();

            ShaderUtil.setupRoundedRectUniforms(x, y, width, height, radius, ShaderUtil.ROUND_SHADER);

            ShaderUtil.ROUND_SHADER.setUniform("blur", 0);
            ShaderUtil.ROUND_SHADER.setUniform("color", getRed(color) / 255f,
                    getGreen(color) / 255f,
                    getBlue(color) / 255f,
                    getAlpha(color) / 255f);

            ShaderUtil.ROUND_SHADER.drawQuads(x, y, width, height);

            ShaderUtil.ROUND_SHADER.detach();
            disableBlend();
            popMatrix();
        }

        public static void drawRoundOutline(float x, float y, float width, float height, float radius, float outlineThickness, int color, Vector4i outlineColor) {
            GlStateManager.color4f(1, 1, 1, 1);
            GlStateManager.enableBlend();
            GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
            ShaderUtil.ROUND_SHADER_OUTLINE.attach();

            MainWindow sr = mc.getMainWindow();
            ShaderUtil.setupRoundedRectUniforms(x, y, width, height, radius, ShaderUtil.ROUND_SHADER_OUTLINE);

            float[] clr = RenderUtil.IntColor.rgb(color);
            ShaderUtil.ROUND_SHADER_OUTLINE.setUniform("outlineThickness", (float) (outlineThickness * 2));
            ShaderUtil.ROUND_SHADER_OUTLINE.setUniform("color", clr[0], clr[1], clr[2],clr[3]);

            for (int i = 0; i < 4;i++) {
                float[] col = RenderUtil.IntColor.rgb(outlineColor.get(i));
                ShaderUtil.ROUND_SHADER_OUTLINE.setUniform("outlineColor" + (i + 1), col[0], col[1], col[2],col[3]);
            }

            ShaderUtil.ROUND_SHADER_OUTLINE.drawQuads(x - (2 + outlineThickness), y - (2 + outlineThickness), width + (4 + outlineThickness * 2), height + (4 + outlineThickness * 2));
            ShaderUtil.ROUND_SHADER_OUTLINE.detach();
            GlStateManager.disableBlend();
        }

        static ShaderUtil out = new ShaderUtil("out");

        public static void drawRoundedOutline(float x, float y, float width, float height, float radius, float outlineThickness, int color, int outlineColor) {
            pushMatrix();
            enableBlend();
           out.attach();

           out.setUniform("size", (float) (width * 2), (float) (height * 2));
           out.setUniform("round", radius * 2, radius * 2, radius * 2, radius * 2);

           out.setUniform("smoothness", 0.f, 1.5f);
           out.setUniform("outlineSize", outlineThickness);
           out.setUniform("color",
                    getRed(color) / 255f,
                    getGreen(color) / 255f,
                    getBlue(color) / 255f,
                    IntColor.getAlpha(color) / 255f);

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("outlineColor",
                    getRed(outlineColor) / 255f,
                    getGreen(outlineColor) / 255f,
                    getBlue(outlineColor) / 255f,
                    IntColor.getAlpha(outlineColor) / 255f);

            ShaderUtil.CORNER_ROUND_SHADER.drawQuads(x, y, width, height);

            ShaderUtil.CORNER_ROUND_SHADER.detach();
            disableBlend();
            popMatrix();
        }


        public static void drawRoundedCorner(float x,
                                             float y,
                                             float width,
                                             float height,
                                             float radius,
                                             int color,
                                             final Corner corner) {
            pushMatrix();
            enableBlend();
            ShaderUtil.CORNER_ROUND_SHADER.attach();

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("size", (float) (width * 2), (float) (height * 2));
            switch (corner) {
                case ALL ->
                        ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", radius * 2, radius * 2, radius * 2, radius * 2);
                case RIGHT -> ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", 0, 0, radius * 2, radius * 2);
                case LEFT -> ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", radius * 2, radius * 2, 0, 0);
                case TOP_RIGHT -> ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", 0, 0, radius * 2, 0);
                case TOP -> ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", radius * 2, 0, radius * 2, 0);
                case DOWN -> ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", 0, radius * 2, 0, radius * 2);
            }

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("smoothness", 0.f, 1.5f);
            ShaderUtil.CORNER_ROUND_SHADER.setUniform("color",
                    getRed(color) / 255f,
                    getGreen(color) / 255f,
                    getBlue(color) / 255f,
                    IntColor.getAlpha(color) / 255f);

            ShaderUtil.CORNER_ROUND_SHADER.drawQuads(x, y, width, height);

            ShaderUtil.CORNER_ROUND_SHADER.detach();
            disableBlend();
            popMatrix();
        }

        public static void drawRoundedCorner(float x,
                                             float y,
                                             float width,
                                             float height,
                                             Vector4f vector4f) {
            pushMatrix();
            enableBlend();
            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.attach();

            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.setUniform("size", (float) (width * 2), (float) (height * 2));
            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.setUniform("round", vector4f.x * 2, vector4f.y * 2, vector4f.z * 2, vector4f.w * 2);

            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.setUniform("smoothness", 0.f, 1.5f);
            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.setUniformf("alpha",1);

            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.drawQuads(x, y, width, height);

            ShaderUtil.CORNER_ROUND_SHADER_TEXTURE.detach();
            disableBlend();
            popMatrix();
        }



        public static void drawRoundedCorner(float x,
                                             float y,
                                             float width,
                                             float height,
                                             float radius,
                                             int color) {
            pushMatrix();
            enableBlend();
            ShaderUtil.CORNER_ROUND_SHADER.attach();

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("size", (float) (width * 2), (float) (height * 2));
            ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", radius * 2, radius * 2, radius * 2, radius * 2);

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("smoothness", 0.f, 1.5f);
            ShaderUtil.CORNER_ROUND_SHADER.setUniform("color",
                    getRed(color) / 255f,
                    getGreen(color) / 255f,
                    getBlue(color) / 255f,
                    IntColor.getAlpha(color) / 255f);

            ShaderUtil.CORNER_ROUND_SHADER.drawQuads(x, y, width, height);

            ShaderUtil.CORNER_ROUND_SHADER.detach();
            disableBlend();
            popMatrix();
        }

        public static void drawRoundedCorner(float x,
                                             float y,
                                             float width,
                                             float height,
                                             Vector4f vector4f,
                                             int color) {
            pushMatrix();
            enableBlend();
            ShaderUtil.CORNER_ROUND_SHADER.attach();

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("size", (float) (width * 2), (float) (height * 2));
            ShaderUtil.CORNER_ROUND_SHADER.setUniform("round", vector4f.x * 2, vector4f.y * 2, vector4f.z * 2, vector4f.w * 2);

            ShaderUtil.CORNER_ROUND_SHADER.setUniform("smoothness", 0.f, 1.5f);
            ShaderUtil.CORNER_ROUND_SHADER.setUniform("color",
                    getRed(color) / 255f,
                    getGreen(color) / 255f,
                    getBlue(color) / 255f,
                    IntColor.getAlpha(color) / 255f);

            ShaderUtil.CORNER_ROUND_SHADER.drawQuads(x, y, width, height);

            ShaderUtil.CORNER_ROUND_SHADER.detach();
            disableBlend();
            popMatrix();
        }

        private static ShaderUtil rounded = new ShaderUtil("cornerGradient");

        public static void drawRoundedCorner(float x,
                                             float y,
                                             float width,
                                             float height,
                                             Vector4f vector4f,
                                             Vector4i color) {
            pushMatrix();
            enableBlend();
            rounded.attach();

            rounded.setUniform("size", (float) (width * 2), (float) (height * 2));
            rounded.setUniform("round", vector4f.x * 2, vector4f.y * 2, vector4f.z * 2, vector4f.w * 2);

            rounded.setUniform("smoothness", 0.f, 1.5f);

            for (int i = 0; i < 4;i++) {
                float[] col = RenderUtil.IntColor.rgb(color.get(i));
                rounded.setUniform("color" + (i + 1), col[0], col[1], col[2],col[3]);
            }

            rounded.drawQuads(x, y, width, height);

            rounded.detach();
            disableBlend();
            popMatrix();
        }


        public static void drawGradientRound(float x, float y, float width, float height, float radius, int bottomLeft, int topLeft, int bottomRight, int topRight) {
            RenderSystem.color4f(1, 1, 1, 1);
            RenderSystem.enableBlend();
            RenderSystem.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
            ShaderUtil.GRADIENT_ROUND_SHADER.attach();
            ShaderUtil.setupRoundedRectUniforms(x, y, width, height, radius, ShaderUtil.GRADIENT_ROUND_SHADER);

            ShaderUtil.GRADIENT_ROUND_SHADER.setUniform("color1", rgb(bottomLeft));
            ShaderUtil.GRADIENT_ROUND_SHADER.setUniform("color2", rgb(topLeft));
            ShaderUtil.GRADIENT_ROUND_SHADER.setUniform("color3", rgb(bottomRight));
            ShaderUtil.GRADIENT_ROUND_SHADER.setUniform("color4", rgb(topRight));

            ShaderUtil.GRADIENT_ROUND_SHADER.drawQuads(x -1,y -1,width + 2,height + 2);
            ShaderUtil.GRADIENT_ROUND_SHADER.detach();
            RenderSystem.disableBlend();
        }


        public static void drawImage(ResourceLocation resourceLocation, float x, float y, float width, float height, int color) {
            RenderSystem.pushMatrix();
            RenderSystem.enableBlend();
            setColor(color);
            
            mc.getTextureManager().bindTexture(resourceLocation);
            AbstractGui.drawModalRectWithCustomSizedTexture(x, y, 0, 0, width, height, width, height);
            RenderSystem.color4f(1, 1, 1, 1);
            RenderSystem.popMatrix();

        }

        public static void drawImage(ResourceLocation resourceLocation, float x, float y, float width, float height, Vector4i color) {
            RenderSystem.pushMatrix();
            RenderSystem.enableBlend();
            RenderSystem.defaultBlendFunc();
            RenderSystem.shadeModel(7425);
            mc.getTextureManager().bindTexture(resourceLocation);
            quadsBeginC(x,y,width,height, 7, color);
            RenderSystem.shadeModel(7424);
            RenderSystem.color4f(1, 1, 1, 1);
            RenderSystem.popMatrix();

        }

        public static void setColor(int color) {
            setColor(color, (float) (color >> 24 & 255) / 255.0F);
        }

        public static void setColor(int color, float alpha) {
            float r = (float) (color >> 16 & 255) / 255.0F;
            float g = (float) (color >> 8 & 255) / 255.0F;
            float b = (float) (color & 255) / 255.0F;
            RenderSystem.color4f(r, g, b, alpha);
        }

        public enum Corner {
            RIGHT,
            LEFT,
            TOP_RIGHT,
            TOP,
            ALL,
            DOWN
        }
    }

    public static class Render3D {

        public static void drawBlockBox(BlockPos blockPos, int color) {
            drawBox(new AxisAlignedBB(blockPos).offset(-mc.getRenderManager().info.getProjectedView().x, -mc.getRenderManager().info.getProjectedView().y, -mc.getRenderManager().info.getProjectedView().z), color);
        }

        public static void drawBox(AxisAlignedBB bb, int color) {
            GL11.glPushMatrix();
            GL11.glDisable(GL11.GL_TEXTURE_2D);
            GL11.glDisable(GL_DEPTH_TEST);
            GL11.glEnable(GL_LINE_SMOOTH);
            GL11.glLineWidth(1);
            float[] rgb = IntColor.rgb(color);
            GlStateManager.color4f(rgb[0], rgb[1], rgb[2], rgb[3]);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder vertexbuffer = tessellator.getBuffer();
            vertexbuffer.begin(3, DefaultVertexFormats.POSITION);
            vertexbuffer.pos(bb.minX, bb.minY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.minY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.minY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.minY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.minY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            tessellator.draw();
            vertexbuffer.begin(3, DefaultVertexFormats.POSITION);
            vertexbuffer.pos(bb.minX, bb.maxY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.maxY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.maxY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.maxY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.maxY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            tessellator.draw();
            vertexbuffer.begin(1, DefaultVertexFormats.POSITION);
            vertexbuffer.pos(bb.minX, bb.minY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.maxY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.minY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.maxY, bb.minZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.minY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.maxX, bb.maxY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.minY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            vertexbuffer.pos(bb.minX, bb.maxY, bb.maxZ).color(rgb[0], rgb[1], rgb[2], rgb[3]).endVertex();
            tessellator.draw();
            GlStateManager.color4f(rgb[0], rgb[1], rgb[2], rgb[3]);
            GL11.glEnable(GL11.GL_TEXTURE_2D);
            GL11.glEnable(GL_DEPTH_TEST);
            GL11.glDisable(GL_LINE_SMOOTH);
            GL11.glPopMatrix();

        }
    }

    public static class SmartScissor {
        private static class State implements Cloneable {
            public boolean enabled;
            public int transX;
            public int transY;
            public int x;
            public int y;
            public int width;
            public int height;

            @Override
            public State clone() {
                try {
                    return (State) super.clone();
                } catch (CloneNotSupportedException e) {
                    throw new AssertionError(e);
                }
            }
        }

        private static State state = new State();

        private static final List<State> stateStack = Lists.newArrayList();

        public static void push() {
            stateStack.add(state.clone());
            GL11.glPushAttrib(GL11.GL_SCISSOR_BIT);
        }

        public static void pop() {
            state = stateStack.remove(stateStack.size() - 1);
            GL11.glPopAttrib();
        }

        public static void unset() {
            GL11.glDisable(GL11.GL_SCISSOR_TEST);
            state.enabled = false;
        }

        public static void setFromComponentCoordinates(int x, int y, int width, int height) {
            int scaleFactor = 2;

            int screenX = x * scaleFactor;
            int screenY = y * scaleFactor;
            int screenWidth = width * scaleFactor;
            int screenHeight = height * scaleFactor;
            screenY = mc.getMainWindow().getHeight() - screenY - screenHeight;
            set(screenX, screenY, screenWidth, screenHeight);
        }

        public static void setFromComponentCoordinates(double x, double y, double width, double height) {
            int scaleFactor = 2;

            int screenX = (int) (x * scaleFactor);
            int screenY = (int) (y * scaleFactor);
            int screenWidth = (int) (width * scaleFactor);
            int screenHeight = (int) (height * scaleFactor);
            screenY = mc.getMainWindow().getHeight() - screenY - screenHeight;
            set(screenX, screenY, screenWidth, screenHeight);
        }

        public static void setFromComponentCoordinates(double x, double y, double width, double height, float scale) {
            float scaleFactor = 2;

            int screenX = (int) (x * scaleFactor);
            int screenY = (int) (y * scaleFactor);
            int screenWidth = (int) (width * scaleFactor);
            int screenHeight = (int) (height * scaleFactor);
            screenY = mc.getMainWindow().getHeight() - screenY - screenHeight;
            set(screenX, screenY, screenWidth, screenHeight);
        }

        public static void set(int x, int y, int width, int height) {
            Rectangle screen = new Rectangle(0, 0, mc.getMainWindow().getWidth(), mc.getMainWindow().getHeight());
            Rectangle current;
            if (state.enabled) {
                current = new Rectangle(state.x, state.y, state.width, state.height);
            } else {
                current = screen;
            }
            Rectangle target = new Rectangle(x + state.transX, y + state.transY, width, height);
            Rectangle result = current.intersection(target);
            result = result.intersection(screen);
            if (result.width < 0) result.width = 0;
            if (result.height < 0) result.height = 0;
            state.enabled = true;
            state.x = result.x;
            state.y = result.y;
            state.width = result.width;
            state.height = result.height;
            GL11.glEnable(GL11.GL_SCISSOR_TEST);
            GL11.glScissor(result.x, result.y, result.width, result.height);
        }

        public static void translate(int x, int y) {
            state.transX = x;
            state.transY = y;
        }

        public static void translateFromComponentCoordinates(int x, int y) {
            int totalHeight = mc.getMainWindow().getScaledHeight();
            int scaleFactor = (int) mc.getMainWindow().getGuiScaleFactor();

            int screenX = x * scaleFactor;
            int screenY = y * scaleFactor;
            screenY = (totalHeight * scaleFactor) - screenY;
            translate(screenX, screenY);
        }

        private SmartScissor() {
        }
    }

    public static class Stencil {

        // Инициализация буфера кадра
        public static void init() {
            mc.getFramebuffer().bindFramebuffer(false); // Привязка буфера кадра

            if (mc.getFramebuffer().depthBuffer > -1) { // Если есть буфер глубины
                EXTFramebufferObject.glDeleteRenderbuffersEXT(mc.getFramebuffer().depthBuffer); // Удаление буфера глубины
                final int stencilDepthBufferID = EXTFramebufferObject.glGenRenderbuffersEXT(); // Создание нового буфера трафарета
                EXTFramebufferObject.glBindRenderbufferEXT(EXTFramebufferObject.GL_RENDERBUFFER_EXT, stencilDepthBufferID); // Привязка буфера трафарета
                EXTFramebufferObject.glRenderbufferStorageEXT(EXTFramebufferObject.GL_RENDERBUFFER_EXT, EXTPackedDepthStencil.GL_DEPTH24_STENCIL8_EXT, mc.getMainWindow().getScaledWidth(), mc.getMainWindow().getScaledHeight()); // Установка параметров буфера трафарета
                EXTFramebufferObject.glFramebufferRenderbufferEXT(EXTFramebufferObject.GL_FRAMEBUFFER_EXT, EXTFramebufferObject.GL_STENCIL_ATTACHMENT_EXT, EXTFramebufferObject.GL_RENDERBUFFER_EXT, stencilDepthBufferID); // Привязка буфера трафарета к фреймбуферу
                EXTFramebufferObject.glFramebufferRenderbufferEXT(EXTFramebufferObject.GL_FRAMEBUFFER_EXT, EXTFramebufferObject.GL_DEPTH_ATTACHMENT_EXT, EXTFramebufferObject.GL_RENDERBUFFER_EXT, stencilDepthBufferID); // Привязка буфера трафарета к фреймбуферу
                mc.getFramebuffer().depthBuffer = -1; // Отключение буфера глубины
            }

            glClear(GL_STENCIL_BUFFER_BIT); // Очистка буфера трафарета
            glEnable(GL_STENCIL_TEST); // Включение теста трафарета

            glStencilFunc(GL_ALWAYS, 1, 0xFF); // Установка функции теста трафарета
            glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); // Установка операций трафарета
            glColorMask(false, false, false, false); // Отключение записи в буфер цвета
        }

        // Чтение значения трафарета
        public static void read(int ref) {
            glColorMask(true, true, true, true); // Включение записи в буфер цвета
            glStencilFunc(GL_EQUAL, ref, 0xFF); // Установка функции теста трафарета
            glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); // Установка операций трафарета
        }

        // Выключение теста трафарета
        public static void unload() {
            glDisable(GL_STENCIL_TEST);
        }
    }
}

Minecraft.java:
package net.minecraft.client;

import baritone.api.BaritoneAPI;
import baritone.api.IBaritone;
import baritone.api.event.events.TickEvent;
import baritone.api.event.events.WorldEvent;
import baritone.api.event.events.type.EventState;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Queues;
import com.google.gson.JsonElement;
import com.mojang.authlib.AuthenticationService;
import com.mojang.authlib.GameProfile;
import com.mojang.authlib.GameProfileRepository;
import com.mojang.authlib.exceptions.AuthenticationException;
import com.mojang.authlib.minecraft.MinecraftSessionService;
import com.mojang.authlib.minecraft.OfflineSocialInteractions;
import com.mojang.authlib.minecraft.SocialInteractionsService;
import com.mojang.authlib.properties.PropertyMap;
import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
import com.mojang.blaze3d.matrix.MatrixStack;
import com.mojang.blaze3d.platform.PlatformDescriptors;
import com.mojang.blaze3d.systems.RenderSystem;
import com.mojang.datafixers.DataFixer;
import com.mojang.datafixers.util.Function4;
import com.mojang.serialization.DataResult;
import com.mojang.serialization.JsonOps;
import com.mojang.serialization.Lifecycle;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.Proxy;
import java.net.SocketAddress;
import java.nio.ByteOrder;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Stream;
import javax.annotation.Nullable;

import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.client.audio.BackgroundMusicSelector;
import net.minecraft.client.audio.BackgroundMusicTracks;
import net.minecraft.client.audio.MusicTicker;
import net.minecraft.client.audio.SoundHandler;
import net.minecraft.client.entity.player.ClientPlayerEntity;
import net.minecraft.client.gui.DialogTexts;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.IngameGui;
import net.minecraft.client.gui.LoadingGui;
import net.minecraft.client.gui.ResourceLoadProgressGui;
import net.minecraft.client.gui.ScreenManager;
import net.minecraft.client.gui.advancements.AdvancementsScreen;
import net.minecraft.client.gui.chat.NarratorChatListener;
import net.minecraft.client.gui.fonts.FontResourceManager;
import net.minecraft.client.gui.recipebook.RecipeList;
import net.minecraft.client.gui.screen.ChatScreen;
import net.minecraft.client.gui.screen.ConfirmBackupScreen;
import net.minecraft.client.gui.screen.ConfirmScreen;
import net.minecraft.client.gui.screen.ConnectingScreen;
import net.minecraft.client.gui.screen.DatapackFailureScreen;
import net.minecraft.client.gui.screen.DeathScreen;
import net.minecraft.client.gui.screen.DirtMessageScreen;
import net.minecraft.client.gui.screen.EditWorldScreen;
import net.minecraft.client.gui.screen.IngameMenuScreen;
import net.minecraft.client.gui.screen.MainMenuScreen;
import net.minecraft.client.gui.screen.MemoryErrorScreen;
import net.minecraft.client.gui.screen.MultiplayerScreen;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.screen.SleepInMultiplayerScreen;
import net.minecraft.client.gui.screen.WinGameScreen;
import net.minecraft.client.gui.screen.WorkingScreen;
import net.minecraft.client.gui.screen.WorldLoadProgressScreen;
import net.minecraft.client.gui.screen.inventory.CreativeScreen;
import net.minecraft.client.gui.screen.inventory.InventoryScreen;
import net.minecraft.client.gui.social.FilterManager;
import net.minecraft.client.gui.social.SocialInteractionsScreen;
import net.minecraft.client.gui.toasts.SystemToast;
import net.minecraft.client.gui.toasts.ToastGui;
import net.minecraft.client.gui.toasts.TutorialToast;
import net.minecraft.client.multiplayer.PlayerController;
import net.minecraft.client.multiplayer.ServerData;
import net.minecraft.client.network.login.ClientLoginNetHandler;
import net.minecraft.client.network.play.ClientPlayNetHandler;
import net.minecraft.client.particle.ParticleManager;
import net.minecraft.client.renderer.BlockModelShapes;
import net.minecraft.client.renderer.BlockRendererDispatcher;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.FirstPersonRenderer;
import net.minecraft.client.renderer.FogRenderer;
import net.minecraft.client.renderer.GPUWarning;
import net.minecraft.client.renderer.GameRenderer;
import net.minecraft.client.renderer.IWindowEventListener;
import net.minecraft.client.renderer.ItemRenderer;
import net.minecraft.client.renderer.RenderTypeBuffers;
import net.minecraft.client.renderer.ScreenSize;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.VirtualScreen;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.color.BlockColors;
import net.minecraft.client.renderer.color.ItemColors;
import net.minecraft.client.renderer.debug.DebugRenderer;
import net.minecraft.client.renderer.entity.EntityRendererManager;
import net.minecraft.client.renderer.model.IBakedModel;
import net.minecraft.client.renderer.model.ModelManager;
import net.minecraft.client.renderer.texture.PaintingSpriteUploader;
import net.minecraft.client.renderer.texture.PotionSpriteUploader;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.resources.DownloadingPackFinder;
import net.minecraft.client.resources.FoliageColorReloadListener;
import net.minecraft.client.resources.GrassColorReloadListener;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.resources.LanguageManager;
import net.minecraft.client.resources.LegacyResourcePackWrapper;
import net.minecraft.client.resources.LegacyResourcePackWrapperV4;
import net.minecraft.client.resources.SkinManager;
import net.minecraft.client.settings.AmbientOcclusionStatus;
import net.minecraft.client.settings.CloudOption;
import net.minecraft.client.settings.CreativeSettings;
import net.minecraft.client.settings.GraphicsFanciness;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.client.settings.PointOfView;
import net.minecraft.client.shader.Framebuffer;
import net.minecraft.client.tutorial.Tutorial;
import net.minecraft.client.util.IMutableSearchTree;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.client.util.SearchTree;
import net.minecraft.client.util.SearchTreeManager;
import net.minecraft.client.util.SearchTreeReloadable;
import net.minecraft.client.util.Splashes;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.command.Commands;
import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.crash.ReportedException;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.item.ArmorStandEntity;
import net.minecraft.entity.item.BoatEntity;
import net.minecraft.entity.item.EnderCrystalEntity;
import net.minecraft.entity.item.ItemFrameEntity;
import net.minecraft.entity.item.LeashKnotEntity;
import net.minecraft.entity.item.PaintingEntity;
import net.minecraft.entity.item.minecart.AbstractMinecartEntity;
import net.minecraft.entity.player.ChatVisibility;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.PlayerInventory;
import net.minecraft.item.Item;
import net.minecraft.item.ItemGroup;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.item.SkullItem;
import net.minecraft.item.SpawnEggItem;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.INBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.nbt.NBTDynamicOps;
import net.minecraft.nbt.StringNBT;
import net.minecraft.network.NetworkManager;
import net.minecraft.network.ProtocolType;
import net.minecraft.network.handshake.client.CHandshakePacket;
import net.minecraft.network.login.client.CLoginStartPacket;
import net.minecraft.network.play.client.CPlayerDiggingPacket;
import net.minecraft.profiler.DataPoint;
import net.minecraft.profiler.EmptyProfiler;
import net.minecraft.profiler.IProfileResult;
import net.minecraft.profiler.IProfiler;
import net.minecraft.profiler.ISnooperInfo;
import net.minecraft.profiler.LongTickDetector;
import net.minecraft.profiler.Snooper;
import net.minecraft.profiler.TimeTracker;
import net.minecraft.resources.DataPackRegistries;
import net.minecraft.resources.FolderPackFinder;
import net.minecraft.resources.IPackNameDecorator;
import net.minecraft.resources.IReloadableResourceManager;
import net.minecraft.resources.IResourceManager;
import net.minecraft.resources.IResourcePack;
import net.minecraft.resources.ResourcePackInfo;
import net.minecraft.resources.ResourcePackList;
import net.minecraft.resources.ResourcePackType;
import net.minecraft.resources.ServerPackFinder;
import net.minecraft.resources.SimpleReloadableResourceManager;
import net.minecraft.resources.data.PackMetadataSection;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.integrated.IntegratedServer;
import net.minecraft.server.management.PlayerProfileCache;
import net.minecraft.tags.ItemTags;
import net.minecraft.tileentity.SkullTileEntity;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.*;
import net.minecraft.util.concurrent.RecursiveEventLoop;
import net.minecraft.util.datafix.DataFixesManager;
import net.minecraft.util.datafix.codec.DatapackCodec;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.BlockRayTraceResult;
import net.minecraft.util.math.EntityRayTraceResult;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.registry.Bootstrap;
import net.minecraft.util.registry.DynamicRegistries;
import net.minecraft.util.registry.Registry;
import net.minecraft.util.registry.WorldGenSettingsExport;
import net.minecraft.util.registry.WorldSettingsImport;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.KeybindTextComponent;
import net.minecraft.util.text.StringTextComponent;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.util.text.TranslationTextComponent;
import net.minecraft.world.World;
import net.minecraft.world.WorldSettings;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.chunk.listener.ChainedChunkStatusListener;
import net.minecraft.world.chunk.listener.TrackingChunkStatusListener;
import net.minecraft.world.gen.settings.DimensionGeneratorSettings;
import net.minecraft.world.storage.FolderName;
import net.minecraft.world.storage.IServerConfiguration;
import net.minecraft.world.storage.SaveFormat;
import net.minecraft.world.storage.ServerWorldInfo;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import arctic.tech.Initilization;
import arctic.tech.events.EventManager;
import arctic.tech.events.impl.player.EventInteractEntity;
import arctic.tech.managment.Managment;
import arctic.tech.modules.impl.player.GappleCooldownFunction;
import arctic.tech.util.ClientUtil;
import arctic.tech.util.font.Fonts;

public class Minecraft extends RecursiveEventLoop<Runnable> implements ISnooperInfo, IWindowEventListener {
    private static Minecraft instance;
    private static final Logger LOGGER = LogManager.getLogger();
    public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.OS.OSX;
    public static final ResourceLocation DEFAULT_FONT_RENDERER_NAME = new ResourceLocation("default");
    public static final ResourceLocation UNIFORM_FONT_RENDERER_NAME = new ResourceLocation("uniform");
    public static final ResourceLocation standardGalacticFontRenderer = new ResourceLocation("alt");
    private static final CompletableFuture<Unit> RESOURCE_RELOAD_INIT_TASK = CompletableFuture.completedFuture(Unit.INSTANCE);
    private static final ITextComponent field_244596_I = new TranslationTextComponent("multiplayer.socialInteractions.not_available");
    public File fileResourcepacks;

    /**
     * The player's GameProfile properties
     */
    private final PropertyMap profileProperties;
    private final TextureManager textureManager;
    private final DataFixer dataFixer;
    private final VirtualScreen virtualScreen;
    private final MainWindow mainWindow;
    public final Timer timer = new Timer(20.0F, 0L);
    private final Snooper snooper = new Snooper("client", this, Util.milliTime());
    private final RenderTypeBuffers renderTypeBuffers;
    public final WorldRenderer worldRenderer;
    private final EntityRendererManager renderManager;
    private final ItemRenderer itemRenderer;
    private final FirstPersonRenderer firstPersonRenderer;
    public final ParticleManager particles;
    private final SearchTreeManager searchTreeManager = new SearchTreeManager();
    public Session session;
    public final FontRenderer fontRenderer;
    public final GameRenderer gameRenderer;
    public final DebugRenderer debugRenderer;
    private final AtomicReference<TrackingChunkStatusListener> refChunkStatusListener = new AtomicReference<>();
    public final IngameGui ingameGUI;
    public final GameSettings gameSettings;
    private final CreativeSettings creativeSettings;
    public final MouseHelper mouseHelper;
    public final KeyboardListener keyboardListener;
    public File gameDir;
    private final String launchedVersion;
    private final String versionType;
    private final Proxy proxy;
    private final SaveFormat saveFormat;

    /**
     * The FrameTimer's instance
     */
    public final FrameTimer frameTimer = new FrameTimer();
    private final boolean jvm64bit;
    private final boolean isDemo;
    private final boolean enableMultiplayer;
    private final boolean enableChat;
    private final IReloadableResourceManager resourceManager;
    private final DownloadingPackFinder packFinder;
    private final ResourcePackList resourcePackRepository;
    private final LanguageManager languageManager;
    private final BlockColors blockColors;
    private final ItemColors itemColors;
    private final Framebuffer framebuffer;
    private final SoundHandler soundHandler;
    private final MusicTicker musicTicker;
    private final FontResourceManager fontResourceMananger;
    private final Splashes splashes;
    private final GPUWarning warningGPU;
    private final MinecraftSessionService sessionService;
    private final SocialInteractionsService field_244734_au;
    private final SkinManager skinManager;
    private final ModelManager modelManager;

    /**
     * The BlockRenderDispatcher instance that will be used based off gamesettings
     */
    private final BlockRendererDispatcher blockRenderDispatcher;
    private final PaintingSpriteUploader paintingSprites;
    private final PotionSpriteUploader potionSprites;
    private final ToastGui toastGui;
    private final MinecraftGame game = new MinecraftGame(this);
    private final Tutorial tutorial;
    private final FilterManager field_244597_aC;
    public static byte[] memoryReserve = new byte[10485760];
    @Nullable
    public PlayerController playerController;
    @Nullable
    public ClientWorld world;
    @Nullable
    public ClientPlayerEntity player;
    @Nullable
    private IntegratedServer integratedServer;
    @Nullable
    private ServerData currentServerData;
    @Nullable
    private NetworkManager networkManager;
    private boolean integratedServerIsRunning;
    @Nullable
    public Entity renderViewEntity;
    @Nullable
    public Entity pointedEntity;
    @Nullable
    public RayTraceResult objectMouseOver;
    public int rightClickDelayTimer;
    public int leftClickCounter;
    private boolean isGamePaused;
    private float renderPartialTicksPaused;

    /**
     * Time in nanoseconds of when the class is loaded
     */
    private long startNanoTime = Util.nanoTime();
    private long debugUpdateTime;
    public int fpsCounter;
    public boolean skipRenderWorld;
    @Nullable
    public Screen currentScreen;
    @Nullable
    public LoadingGui loadingGui;

    /**
     * True if the player is connected to a realms server
     */
    private boolean connectedToRealms;
    private Thread thread;
    private volatile boolean running = true;
    @Nullable
    private CrashReport crashReporter;
    public static int debugFPS;
    public String debug = "";
    public boolean debugWireframe;
    public boolean debugChunkPath;
    public boolean renderChunksMany = true;
    private boolean isWindowFocused;
    private final Queue<Runnable> queueChunkTracking = Queues.newConcurrentLinkedQueue();
    @Nullable
    private CompletableFuture<Void> futureRefreshResources;
    @Nullable
    private TutorialToast field_244598_aV;
    private IProfiler profiler = EmptyProfiler.INSTANCE;
    private int gameTime;
    private final TimeTracker gameTimeTracker = new TimeTracker(Util.nanoTimeSupplier, () ->
    {
        return this.gameTime;
    });
    @Nullable
    private IProfileResult profilerResult;
    private String debugProfilerName = "root";

    public Minecraft(GameConfiguration gameConfig) {
        super("Client");
        instance = this;

        Fonts.init();

        this.gameDir = gameConfig.folderInfo.gameDir;
        File file1 = gameConfig.folderInfo.assetsDir;
        this.fileResourcepacks = gameConfig.folderInfo.resourcePacksDir;
        this.launchedVersion = gameConfig.gameInfo.version;
        this.versionType = gameConfig.gameInfo.versionType;
        this.profileProperties = gameConfig.userInfo.profileProperties;
        this.packFinder = new DownloadingPackFinder(new File(this.gameDir, "server-resource-packs"), gameConfig.folderInfo.getAssetsIndex());
        this.resourcePackRepository = new ResourcePackList(Minecraft::makePackInfo, this.packFinder, new FolderPackFinder(this.fileResourcepacks, IPackNameDecorator.PLAIN));
        this.proxy = gameConfig.userInfo.proxy;
        YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(this.proxy);
        this.sessionService = yggdrasilauthenticationservice.createMinecraftSessionService();
        this.field_244734_au = this.func_244735_a(yggdrasilauthenticationservice, gameConfig);
        this.session = gameConfig.userInfo.session;
        LOGGER.info("Setting user: {}", (Object) this.session.getUsername());
        LOGGER.debug("(Session ID is {})", (Object) this.session.getSessionID());
        this.isDemo = gameConfig.gameInfo.isDemo;
        this.enableMultiplayer = !gameConfig.gameInfo.disableMultiplayer;
        this.enableChat = !gameConfig.gameInfo.disableChat;
        this.jvm64bit = isJvm64bit();
        this.integratedServer = null;
        String s;
        int i;

        if (this.isMultiplayerEnabled() && gameConfig.serverInfo.serverName != null) {
            s = gameConfig.serverInfo.serverName;
            i = gameConfig.serverInfo.serverPort;
        } else {
            s = null;
            i = 0;
        }

        KeybindTextComponent.func_240696_a_(KeyBinding::getDisplayString);
        this.dataFixer = DataFixesManager.getDataFixer();
        this.toastGui = new ToastGui(this);
        this.tutorial = new Tutorial(this);
        this.thread = Thread.currentThread();
        this.gameSettings = new GameSettings(this, this.gameDir);
        this.creativeSettings = new CreativeSettings(this.gameDir, this.dataFixer);
        LOGGER.info("Backend library: {}", (Object) RenderSystem.getBackendDescription());
        ScreenSize screensize;

        if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0) {
            screensize = new ScreenSize(this.gameSettings.overrideWidth, this.gameSettings.overrideHeight, gameConfig.displayInfo.fullscreenWidth, gameConfig.displayInfo.fullscreenHeight, gameConfig.displayInfo.fullscreen);
        } else {
            screensize = gameConfig.displayInfo;
        }

        Util.nanoTimeSupplier = RenderSystem.initBackendSystem();
        this.virtualScreen = new VirtualScreen(this);
        this.mainWindow = this.virtualScreen.create(screensize, this.gameSettings.fullscreenResolution, this.getWindowTitle());
        this.setGameFocused(true);

        try {
            InputStream inputstream = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_16x16.png"));
            InputStream inputstream1 = this.getPackFinder().getVanillaPack().getResourceStream(ResourcePackType.CLIENT_RESOURCES, new ResourceLocation("icons/icon_32x32.png"));
            this.mainWindow.setWindowIcon(inputstream, inputstream1);
        } catch (IOException ioexception) {
            LOGGER.error("Couldn't set icon", (Throwable) ioexception);
        }

        this.mainWindow.setFramerateLimit(this.gameSettings.framerateLimit);
        this.mouseHelper = new MouseHelper(this);
        this.mouseHelper.registerCallbacks(this.mainWindow.getHandle());
        this.keyboardListener = new KeyboardListener(this);
        this.keyboardListener.setupCallbacks(this.mainWindow.getHandle());
        RenderSystem.initRenderer(this.gameSettings.glDebugVerbosity, false);
        this.framebuffer = new Framebuffer(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), true, IS_RUNNING_ON_MAC);
        this.framebuffer.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
        this.resourceManager = new SimpleReloadableResourceManager(ResourcePackType.CLIENT_RESOURCES);
        this.resourcePackRepository.reloadPacksFromFinders();
        this.gameSettings.fillResourcePackList(this.resourcePackRepository);
        this.languageManager = new LanguageManager(this.gameSettings.language);
        this.resourceManager.addReloadListener(this.languageManager);
        this.textureManager = new TextureManager(this.resourceManager);
        this.resourceManager.addReloadListener(this.textureManager);
        this.skinManager = new SkinManager(this.textureManager, new File(file1, "skins"), this.sessionService);
        this.saveFormat = new SaveFormat(this.gameDir.toPath().resolve("saves"), this.gameDir.toPath().resolve("backups"), this.dataFixer);
        this.soundHandler = new SoundHandler(this.resourceManager, this.gameSettings);
        this.resourceManager.addReloadListener(this.soundHandler);
        this.splashes = new Splashes(this.session);
        this.resourceManager.addReloadListener(this.splashes);
        this.musicTicker = new MusicTicker(this);
        this.fontResourceMananger = new FontResourceManager(this.textureManager);
        this.fontRenderer = this.fontResourceMananger.func_238548_a_();
        this.resourceManager.addReloadListener(this.fontResourceMananger.getReloadListener());
        this.forceUnicodeFont(this.getForceUnicodeFont());
        this.resourceManager.addReloadListener(new GrassColorReloadListener());
        this.resourceManager.addReloadListener(new FoliageColorReloadListener());
        this.mainWindow.setRenderPhase("Startup");
        RenderSystem.setupDefaultState(0, 0, this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
        this.mainWindow.setRenderPhase("Post startup");
        this.blockColors = BlockColors.init();
        this.itemColors = ItemColors.init(this.blockColors);
        this.modelManager = new ModelManager(this.textureManager, this.blockColors, this.gameSettings.mipmapLevels);
        this.resourceManager.addReloadListener(this.modelManager);
        this.itemRenderer = new ItemRenderer(this.textureManager, this.modelManager, this.itemColors);
        this.renderManager = new EntityRendererManager(this.textureManager, this.itemRenderer, this.resourceManager, this.fontRenderer, this.gameSettings);
        this.firstPersonRenderer = new FirstPersonRenderer(this);
        this.resourceManager.addReloadListener(this.itemRenderer);
        this.renderTypeBuffers = new RenderTypeBuffers();
        this.gameRenderer = new GameRenderer(this, this.resourceManager, this.renderTypeBuffers);
        this.resourceManager.addReloadListener(this.gameRenderer);
        this.field_244597_aC = new FilterManager(this, this.field_244734_au);
        this.blockRenderDispatcher = new BlockRendererDispatcher(this.modelManager.getBlockModelShapes(), this.blockColors);
        this.resourceManager.addReloadListener(this.blockRenderDispatcher);
        this.worldRenderer = new WorldRenderer(this, this.renderTypeBuffers);
        this.resourceManager.addReloadListener(this.worldRenderer);
        this.populateSearchTreeManager();
        this.resourceManager.addReloadListener(this.searchTreeManager);
        this.particles = new ParticleManager(this.world, this.textureManager);
        this.resourceManager.addReloadListener(this.particles);
        this.paintingSprites = new PaintingSpriteUploader(this.textureManager);
        this.resourceManager.addReloadListener(this.paintingSprites);
        this.potionSprites = new PotionSpriteUploader(this.textureManager);
        this.resourceManager.addReloadListener(this.potionSprites);
        this.warningGPU = new GPUWarning();
        this.resourceManager.addReloadListener(this.warningGPU);
        this.ingameGUI = new IngameGui(this);
        this.debugRenderer = new DebugRenderer(this);

        Initilization initilization = new Initilization();
        initilization.init();

        RenderSystem.setErrorCallback(this::disableVSyncAfterGlError);

        if (this.gameSettings.fullscreen && !this.mainWindow.isFullscreen()) {
            this.mainWindow.toggleFullscreen();
            this.gameSettings.fullscreen = this.mainWindow.isFullscreen();
        }

        this.mainWindow.setVsync(this.gameSettings.vsync);
        this.mainWindow.setRawMouseInput(this.gameSettings.rawMouseInput);
        this.mainWindow.setLogOnGlError();
        this.updateWindowSize();

        if (s != null) {
            this.displayGuiScreen(new ConnectingScreen(new MainMenuScreen(), this, s, i));
        } else {
            this.displayGuiScreen(new MainMenuScreen(true));
        }

        ResourceLoadProgressGui.loadLogoTexture(this);
        List<IResourcePack> list = this.resourcePackRepository.func_232623_f_();
        this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (throwable) ->
        {
            Util.acceptOrElse(throwable, this::restoreResourcePacks, () -> {
                if (SharedConstants.developmentMode) {
                    this.checkMissingData();
                }
            });
        }, false));
    }

    public void setDefaultMinecraftTitle() {
        this.mainWindow.setWindowTitle("Minecraft 1.16.5");
    }

    private String getWindowTitle() {
        StringBuilder stringbuilder = new StringBuilder("Minecraft");

        if (this.isModdedClient()) {
            stringbuilder.append("*");
        }

        stringbuilder.append(" ");
        stringbuilder.append(SharedConstants.getVersion().getName());
        ClientPlayNetHandler clientplaynethandler = this.getConnection();

        if (clientplaynethandler != null && clientplaynethandler.getNetworkManager().isChannelOpen()) {
            stringbuilder.append(" - ");

            if (this.integratedServer != null && !this.integratedServer.getPublic()) {
                stringbuilder.append(I18n.format("title.singleplayer"));
            } else if (this.isConnectedToRealms()) {
                stringbuilder.append(I18n.format("title.multiplayer.realms"));
            } else if (this.integratedServer == null && (this.currentServerData == null || !this.currentServerData.isOnLAN())) {
                stringbuilder.append(I18n.format("title.multiplayer.other"));
            } else {
                stringbuilder.append(I18n.format("title.multiplayer.lan"));
            }
        }

        return stringbuilder.toString();
    }

    private SocialInteractionsService func_244735_a(YggdrasilAuthenticationService p_244735_1_, GameConfiguration p_244735_2_) {
        try {
            return p_244735_1_.createSocialInteractionsService(p_244735_2_.userInfo.session.getToken());
        } catch (AuthenticationException authenticationexception) {
            LOGGER.error("Failed to verify authentication", (Throwable) authenticationexception);
            return new OfflineSocialInteractions();
        }
    }

    public boolean isModdedClient() {
        return !"vanilla".equals(ClientBrandRetriever.getClientModName()) || Minecraft.class.getSigners() == null;
    }

    private void restoreResourcePacks(Throwable throwableIn) {
        if (this.resourcePackRepository.func_232621_d_().size() > 1) {
            ITextComponent itextcomponent;

            if (throwableIn instanceof SimpleReloadableResourceManager.FailedPackException) {
                itextcomponent = new StringTextComponent(((SimpleReloadableResourceManager.FailedPackException) throwableIn).getPack().getName());
            } else {
                itextcomponent = null;
            }

            this.throwResourcePackLoadError(throwableIn, itextcomponent);
        } else {
            Util.toRuntimeException(throwableIn);
        }
    }

    public void throwResourcePackLoadError(Throwable throwable, @Nullable ITextComponent errorMessage) {
        LOGGER.info("Caught error loading resourcepacks, removing all selected resourcepacks", throwable);
        this.resourcePackRepository.setEnabledPacks(Collections.emptyList());
        this.gameSettings.resourcePacks.clear();
        this.gameSettings.incompatibleResourcePacks.clear();
        this.gameSettings.saveOptions();
        this.reloadResources().thenRun(() ->
        {
            ToastGui toastgui = this.getToastGui();
            SystemToast.addOrUpdate(toastgui, SystemToast.Type.PACK_LOAD_FAILURE, new TranslationTextComponent("resourcePack.load_fail"), errorMessage);
        });
    }

    public void run() {
        this.thread = Thread.currentThread();

        try {
            boolean flag = false;

            while (this.running) {
                if (this.crashReporter != null) {
                    displayCrashReport(this.crashReporter);
                    return;
                }

                try {
                    LongTickDetector longtickdetector = LongTickDetector.func_233524_a_("Renderer");
                    boolean flag1 = this.isDebugMode();
                    this.tick(flag1, longtickdetector);
                    this.profiler.startTick();
                    this.runGameLoop(!flag);
                    this.profiler.endTick();
                    this.func_238210_b_(flag1, longtickdetector);
                } catch (OutOfMemoryError outofmemoryerror) {
                    if (flag) {
                        throw outofmemoryerror;
                    }

                    this.freeMemory();
                    this.displayGuiScreen(new MemoryErrorScreen());
                    System.gc();
                    LOGGER.fatal("Out of memory", (Throwable) outofmemoryerror);
                    flag = true;
                }
            }
        } catch (ReportedException reportedexception) {
            this.addGraphicsAndWorldToCrashReport(reportedexception.getCrashReport());
            this.freeMemory();
            LOGGER.fatal("Reported exception thrown!", (Throwable) reportedexception);
            displayCrashReport(reportedexception.getCrashReport());
        } catch (Throwable throwable) {
            CrashReport crashreport = this.addGraphicsAndWorldToCrashReport(new CrashReport("Unexpected error", throwable));
            LOGGER.fatal("Unreported exception thrown!", throwable);
            this.freeMemory();
            displayCrashReport(crashreport);
        }
    }

    void forceUnicodeFont(boolean forced) {
        this.fontResourceMananger.func_238551_a_(forced ? ImmutableMap.of(DEFAULT_FONT_RENDERER_NAME, UNIFORM_FONT_RENDERER_NAME) : ImmutableMap.of());
    }

    /**
     * Fills {@link #searchTreeManager} with the current item and recipe registry contents.
     */
    private void populateSearchTreeManager() {
        SearchTree<ItemStack> searchtree = new SearchTree<>((stack) ->
        {
            return stack.getTooltip((PlayerEntity) null, ITooltipFlag.TooltipFlags.NORMAL).stream().map((textComponent) -> {
                return TextFormatting.getTextWithoutFormattingCodes(textComponent.getString()).trim();
            }).filter((name) -> {
                return !name.isEmpty();
            });
        }, (stack) ->
        {
            return Stream.of(Registry.ITEM.getKey(stack.getItem()));
        });
        SearchTreeReloadable<ItemStack> searchtreereloadable = new SearchTreeReloadable<>((stack) ->
        {
            return ItemTags.getCollection().getOwningTags(stack.getItem()).stream();
        });
        NonNullList<ItemStack> nonnulllist = NonNullList.create();

        for (Item item : Registry.ITEM) {
            item.fillItemGroup(ItemGroup.SEARCH, nonnulllist);
        }

        nonnulllist.forEach((stack) ->
        {
            searchtree.func_217872_a(stack);
            searchtreereloadable.func_217872_a(stack);
        });
        SearchTree<RecipeList> searchtree1 = new SearchTree<>((recipeList) ->
        {
            return recipeList.getRecipes().stream().flatMap((recipe) -> {
                return recipe.getRecipeOutput().getTooltip((PlayerEntity) null, ITooltipFlag.TooltipFlags.NORMAL).stream();
            }).map((textComponent) -> {
                return TextFormatting.getTextWithoutFormattingCodes(textComponent.getString()).trim();
            }).filter((name) -> {
                return !name.isEmpty();
            });
        }, (recipeList) ->
        {
            return recipeList.getRecipes().stream().map((recipe) -> {
                return Registry.ITEM.getKey(recipe.getRecipeOutput().getItem());
            });
        });
        this.searchTreeManager.add(SearchTreeManager.ITEMS, searchtree);
        this.searchTreeManager.add(SearchTreeManager.TAGS, searchtreereloadable);
        this.searchTreeManager.add(SearchTreeManager.RECIPES, searchtree1);
    }

    private void disableVSyncAfterGlError(int error, long description) {
        this.gameSettings.vsync = false;
        this.gameSettings.saveOptions();
    }

    private static boolean isJvm64bit() {
        String[] astring = new String[]{"sun.arch.data.model", "com.ibm.vm.bitmode", "os.arch"};

        for (String s : astring) {
            String s1 = System.getProperty(s);

            if (s1 != null && s1.contains("64")) {
                return true;
            }
        }

        return false;
    }

    public Framebuffer getFramebuffer() {
        return this.framebuffer;
    }

    /**
     * Gets the version that Minecraft was launched under (the name of a version JSON). Specified via the
     * <code>--version</code> flag.
     */
    public String getVersion() {
        return ClientUtil.legitMode ? "Optifine 1.16.5" : this.launchedVersion;
    }

    /**
     * Gets the type of version that Minecraft was launched under (as specified in the version JSON). Specified via the
     * <code>--versionType</code> flag.
     */
    public String getVersionType() {
        return this.versionType;
    }

    public void crashed(CrashReport crash) {
        this.crashReporter = crash;
    }

    /**
     * Wrapper around displayCrashReportInternal
     */
    public static void displayCrashReport(CrashReport report) {
        File file1 = new File(getInstance().gameDir, "crash-reports");
        File file2 = new File(file1, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
        Bootstrap.printToSYSOUT(report.getCompleteReport());

        if (report.getFile() != null) {
            Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + report.getFile());
            System.exit(-1);
        } else if (report.saveToFile(file2)) {
            Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
            System.exit(-1);
        } else {
            Bootstrap.printToSYSOUT("#@?@# Game crashed! Crash report could not be saved. #@?@#");
            System.exit(-2);
        }
    }

    public boolean getForceUnicodeFont() {
        return this.gameSettings.forceUnicodeFont;
    }

    public CompletableFuture<Void> reloadResources() {
        if (this.futureRefreshResources != null) {
            return this.futureRefreshResources;
        } else {
            CompletableFuture<Void> completablefuture = new CompletableFuture<>();

            if (this.loadingGui instanceof ResourceLoadProgressGui) {
                this.futureRefreshResources = completablefuture;
                return completablefuture;
            } else {
                this.resourcePackRepository.reloadPacksFromFinders();
                List<IResourcePack> list = this.resourcePackRepository.func_232623_f_();
                this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (throwable) ->
                {
                    Util.acceptOrElse(throwable, this::restoreResourcePacks, () -> {
                        this.worldRenderer.loadRenderers();
                        completablefuture.complete((Void) null);
                    });
                }, true));
                return completablefuture;
            }
        }
    }

    private void checkMissingData() {
        boolean flag = false;
        BlockModelShapes blockmodelshapes = this.getBlockRendererDispatcher().getBlockModelShapes();
        IBakedModel ibakedmodel = blockmodelshapes.getModelManager().getMissingModel();

        for (Block block : Registry.BLOCK) {
            for (BlockState blockstate : block.getStateContainer().getValidStates()) {
                if (blockstate.getRenderType() == BlockRenderType.MODEL) {
                    IBakedModel ibakedmodel1 = blockmodelshapes.getModel(blockstate);

                    if (ibakedmodel1 == ibakedmodel) {
                        LOGGER.debug("Missing model for: {}", (Object) blockstate);
                        flag = true;
                    }
                }
            }
        }

        TextureAtlasSprite textureatlassprite1 = ibakedmodel.getParticleTexture();

        for (Block block1 : Registry.BLOCK) {
            for (BlockState blockstate1 : block1.getStateContainer().getValidStates()) {
                TextureAtlasSprite textureatlassprite = blockmodelshapes.getTexture(blockstate1);

                if (!blockstate1.isAir() && textureatlassprite == textureatlassprite1) {
                    LOGGER.debug("Missing particle icon for: {}", (Object) blockstate1);
                    flag = true;
                }
            }
        }

        NonNullList<ItemStack> nonnulllist = NonNullList.create();

        for (Item item : Registry.ITEM) {
            nonnulllist.clear();
            item.fillItemGroup(ItemGroup.SEARCH, nonnulllist);

            for (ItemStack itemstack : nonnulllist) {
                String s = itemstack.getTranslationKey();
                String s1 = (new TranslationTextComponent(s)).getString();

                if (s1.toLowerCase(Locale.ROOT).equals(item.getTranslationKey())) {
                    LOGGER.debug("Missing translation for: {} {} {}", itemstack, s, itemstack.getItem());
                }
            }
        }

        flag = flag | ScreenManager.isMissingScreen();

        if (flag) {
            throw new IllegalStateException("Your game data is foobar, fix the errors above!");
        }
    }

    /**
     * Returns the save loader that is currently being used
     */
    public SaveFormat getSaveLoader() {
        return this.saveFormat;
    }

    private void openChatScreen(String defaultText) {
        if (!this.isIntegratedServerRunning() && !this.isChatEnabled()) {
            if (this.player != null) {
                this.player.sendMessage((new TranslationTextComponent("chat.cannotSend")).mergeStyle(TextFormatting.RED), Util.DUMMY_UUID);
            }
        } else {
            this.displayGuiScreen(new ChatScreen(defaultText));
        }
    }

    public void displayGuiScreen(@Nullable Screen guiScreenIn) {
        if (this.currentScreen != null) {
            this.currentScreen.onClose();
        }

        if (guiScreenIn == null && this.world == null) {
            guiScreenIn = new MainMenuScreen();
        } else if (guiScreenIn == null && this.player.getShouldBeDead()) {
            if (this.player.isShowDeathScreen()) {
                guiScreenIn = new DeathScreen((ITextComponent) null, this.world.getWorldInfo().isHardcore());
            } else {
                this.player.respawnPlayer();
            }
        }

        if (guiScreenIn instanceof MainMenuScreen || guiScreenIn instanceof MultiplayerScreen) {
            this.gameSettings.showDebugInfo = false;
            this.ingameGUI.getChatGUI().clearChatMessages(true);
        }

        this.currentScreen = guiScreenIn;

        if (guiScreenIn != null) {
            this.mouseHelper.ungrabMouse();
            KeyBinding.unPressAllKeys();
            guiScreenIn.init(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
            this.skipRenderWorld = false;
            NarratorChatListener.INSTANCE.say(guiScreenIn.getNarrationMessage());
        } else {
            this.soundHandler.resume();
            this.mouseHelper.grabMouse();
        }

        this.setDefaultMinecraftTitle();
    }

    public void setLoadingGui(@Nullable LoadingGui loadingGuiIn) {
        this.loadingGui = loadingGuiIn;
    }

    /**
     * Shuts down the minecraft applet by stopping the resource downloads, and clearing up GL stuff; called when the
     * application (or web page) is exited.
     */
    public void shutdownMinecraftApplet() {
        try {
            LOGGER.info("Stopping!");

            try {
                NarratorChatListener.INSTANCE.close();
            } catch (Throwable throwable1) {
            }

            try {
                if (this.world != null) {
                    this.world.sendQuittingDisconnectingPacket();
                }

                this.unloadWorld();
            } catch (Throwable throwable) {
            }

            if (this.currentScreen != null) {
                this.currentScreen.onClose();
            }

            this.close();
        } finally {
            Util.nanoTimeSupplier = System::nanoTime;

            if (this.crashReporter == null) {
                System.exit(0);
            }
        }
    }

    public void close() {
        try {
            this.modelManager.close();
            this.fontResourceMananger.close();
            this.gameRenderer.close();
            this.worldRenderer.close();
            this.soundHandler.unloadSounds();
            this.resourcePackRepository.close();
            this.particles.close();
            this.potionSprites.close();
            this.paintingSprites.close();
            this.textureManager.close();
            this.resourceManager.close();
            Util.shutdown();
        } catch (Throwable throwable) {
            LOGGER.error("Shutdown failure!", throwable);
            throw throwable;
        } finally {
            this.virtualScreen.close();
            this.mainWindow.close();
        }
    }

    private void runGameLoop(boolean renderWorldIn) {
        this.mainWindow.setRenderPhase("Pre render");
        long i = Util.nanoTime();

        if (this.mainWindow.shouldClose()) {
            this.shutdown();
        }

        if (this.futureRefreshResources != null && !(this.loadingGui instanceof ResourceLoadProgressGui)) {
            CompletableFuture<Void> completablefuture = this.futureRefreshResources;
            this.futureRefreshResources = null;
            this.reloadResources().thenRun(() ->
            {
                completablefuture.complete((Void) null);
            });
        }

        Runnable runnable;

        while ((runnable = this.queueChunkTracking.poll()) != null) {
            runnable.run();
        }

        if (renderWorldIn) {
            int j = this.timer.getPartialTicks(Util.milliTime());
            this.profiler.startSection("scheduledExecutables");
            this.drainTasks();
            this.profiler.endSection();
            this.profiler.startSection("tick");

            for (int k = 0; k < Math.min(10, j); ++k) {
                this.profiler.func_230035_c_("clientTick");
                this.runTick();
            }

            this.profiler.endSection();
        }

        this.mouseHelper.updatePlayerLook();
        this.mainWindow.setRenderPhase("Render");
        this.profiler.startSection("sound");
        this.soundHandler.updateListener(this.gameRenderer.getActiveRenderInfo());
        this.profiler.endSection();
        this.profiler.startSection("render");
        RenderSystem.pushMatrix();
        RenderSystem.clear(16640, IS_RUNNING_ON_MAC);
        this.framebuffer.bindFramebuffer(true);
        FogRenderer.resetFog();
        this.profiler.startSection("display");
        RenderSystem.enableTexture();
        RenderSystem.enableCull();
        this.profiler.endSection();

        if (!this.skipRenderWorld) {
            this.profiler.endStartSection("gameRenderer");
            this.gameRenderer.updateCameraAndRender(this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks, i, renderWorldIn);
            this.profiler.endStartSection("toasts");
            this.toastGui.func_238541_a_(new MatrixStack());
            this.profiler.endSection();
        }

        if (this.profilerResult != null) {
            this.profiler.startSection("fpsPie");
            this.func_238183_a_(new MatrixStack(), this.profilerResult);
            this.profiler.endSection();
        }

        this.profiler.startSection("blit");
        this.framebuffer.unbindFramebuffer();
        RenderSystem.popMatrix();
        RenderSystem.pushMatrix();
        this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
        RenderSystem.popMatrix();
        this.profiler.endStartSection("updateDisplay");
        this.mainWindow.flipFrame();
        int i1 = this.getFramerateLimit();

        if ((double) i1 < AbstractOption.FRAMERATE_LIMIT.getMaxValue()) {
            RenderSystem.limitDisplayFPS(i1);
        }

        this.profiler.endStartSection("yield");
        Thread.yield();
        this.profiler.endSection();
        this.mainWindow.setRenderPhase("Post render");
        ++this.fpsCounter;
        boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();

        if (this.isGamePaused != flag) {
            if (this.isGamePaused) {
                this.renderPartialTicksPaused = this.timer.renderPartialTicks;
            } else {
                this.timer.renderPartialTicks = this.renderPartialTicksPaused;
            }

            this.isGamePaused = flag;
        }

        long l = Util.nanoTime();
        this.frameTimer.addFrame(l - this.startNanoTime);
        this.startNanoTime = l;
        this.profiler.startSection("fpsUpdate");

        while (Util.milliTime() >= this.debugUpdateTime + 1000L) {
            debugFPS = this.fpsCounter;
            this.debug = String.format("%d fps T: %s%s%s%s B: %d", debugFPS, (double) this.gameSettings.framerateLimit == AbstractOption.FRAMERATE_LIMIT.getMaxValue() ? "inf" : this.gameSettings.framerateLimit, this.gameSettings.vsync ? " vsync" : "", this.gameSettings.graphicFanciness.toString(), this.gameSettings.cloudOption == CloudOption.OFF ? "" : (this.gameSettings.cloudOption == CloudOption.FAST ? " fast-clouds" : " fancy-clouds"), this.gameSettings.biomeBlendRadius);
            this.debugUpdateTime += 1000L;
            this.fpsCounter = 0;
            this.snooper.addMemoryStatsToSnooper();

            if (!this.snooper.isSnooperRunning()) {
                this.snooper.start();
            }
        }


        this.profiler.endSection();
    }

    private boolean isDebugMode() {
        return this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI;
    }

    private void tick(boolean isDebug, @Nullable LongTickDetector detector) {
        if (isDebug) {
            if (!this.gameTimeTracker.func_233505_a_()) {
                this.gameTime = 0;
                this.gameTimeTracker.func_233507_c_();
            }

            ++this.gameTime;
        } else {
            this.gameTimeTracker.func_233506_b_();
        }

        this.profiler = LongTickDetector.func_233523_a_(this.gameTimeTracker.func_233508_d_(), detector);
    }

    private void func_238210_b_(boolean isDebug, @Nullable LongTickDetector detector) {
        if (detector != null) {
            detector.func_233525_b_();
        }

        if (isDebug) {
            this.profilerResult = this.gameTimeTracker.func_233509_e_();
        } else {
            this.profilerResult = null;
        }

        this.profiler = this.gameTimeTracker.func_233508_d_();
    }

    public void updateWindowSize() {
        int i = this.mainWindow.calcGuiScale(this.gameSettings.guiScale, this.getForceUnicodeFont());
        this.mainWindow.setGuiScale((double) i);

        if (this.currentScreen != null) {
            this.currentScreen.resize(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
        }

        Framebuffer framebuffer = this.getFramebuffer();
        framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
        this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
        this.mouseHelper.setIgnoreFirstMove();
    }

    public void updateWindowSize(int val) {
        this.mainWindow.setGuiScale(val);

        if (this.currentScreen != null) {
            this.currentScreen.resize(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
        }

        Framebuffer framebuffer = this.getFramebuffer();
        framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
        this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
        this.mouseHelper.setIgnoreFirstMove();
    }

    public void ignoreFirstMove() {
        this.mouseHelper.ignoreFirstMove();
    }

    private int getFramerateLimit() {
        return this.world != null || this.currentScreen == null && this.loadingGui == null ? this.mainWindow.getLimitFramerate() : 60;
    }

    /**
     * Attempts to free as much memory as possible, including leaving the world and running the garbage collector.
     */
    public void freeMemory() {
        try {
            memoryReserve = new byte[0];
            this.worldRenderer.deleteAllDisplayLists();
        } catch (Throwable throwable1) {
        }

        try {
            System.gc();

            if (this.integratedServerIsRunning && this.integratedServer != null) {
                this.integratedServer.initiateShutdown(true);
            }

            this.unloadWorld(new DirtMessageScreen(new TranslationTextComponent("menu.savingLevel")));
        } catch (Throwable throwable) {
        }

        System.gc();
    }

    /**
     * Update debugProfilerName in response to number keys in debug screen
     */
    void updateDebugProfilerName(int keyCount) {
        if (this.profilerResult != null) {
            List<DataPoint> list = this.profilerResult.getDataPoints(this.debugProfilerName);

            if (!list.isEmpty()) {
                DataPoint datapoint = list.remove(0);

                if (keyCount == 0) {
                    if (!datapoint.name.isEmpty()) {
                        int i = this.debugProfilerName.lastIndexOf(30);

                        if (i >= 0) {
                            this.debugProfilerName = this.debugProfilerName.substring(0, i);
                        }
                    }
                } else {
                    --keyCount;

                    if (keyCount < list.size() && !"unspecified".equals((list.get(keyCount)).name)) {
                        if (!this.debugProfilerName.isEmpty()) {
                            this.debugProfilerName = this.debugProfilerName + '\u001e';
                        }

                        this.debugProfilerName = this.debugProfilerName + (list.get(keyCount)).name;
                    }
                }
            }
        }
    }

    private void func_238183_a_(MatrixStack matrixStack, IProfileResult profilerResult) {
        List<DataPoint> list = profilerResult.getDataPoints(this.debugProfilerName);
        DataPoint datapoint = list.remove(0);
        RenderSystem.clear(256, IS_RUNNING_ON_MAC);
        RenderSystem.matrixMode(5889);
        RenderSystem.loadIdentity();
        RenderSystem.ortho(0.0D, (double) this.mainWindow.getFramebufferWidth(), (double) this.mainWindow.getFramebufferHeight(), 0.0D, 1000.0D, 3000.0D);
        RenderSystem.matrixMode(5888);
        RenderSystem.loadIdentity();
        RenderSystem.translatef(0.0F, 0.0F, -2000.0F);
        RenderSystem.lineWidth(1.0F);
        RenderSystem.disableTexture();
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder bufferbuilder = tessellator.getBuffer();
        int i = 160;
        int j = this.mainWindow.getFramebufferWidth() - 160 - 10;
        int k = this.mainWindow.getFramebufferHeight() - 320;
        RenderSystem.enableBlend();
        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
        bufferbuilder.pos((double) ((float) j - 176.0F), (double) ((float) k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
        bufferbuilder.pos((double) ((float) j - 176.0F), (double) (k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
        bufferbuilder.pos((double) ((float) j + 176.0F), (double) (k + 320), 0.0D).color(200, 0, 0, 0).endVertex();
        bufferbuilder.pos((double) ((float) j + 176.0F), (double) ((float) k - 96.0F - 16.0F), 0.0D).color(200, 0, 0, 0).endVertex();
        tessellator.draw();
        RenderSystem.disableBlend();
        double d0 = 0.0D;

        for (DataPoint datapoint1 : list) {
            int l = MathHelper.floor(datapoint1.relTime / 4.0D) + 1;
            bufferbuilder.begin(6, DefaultVertexFormats.POSITION_COLOR);
            int i1 = datapoint1.getTextColor();
            int j1 = i1 >> 16 & 255;
            int k1 = i1 >> 8 & 255;
            int l1 = i1 & 255;
            bufferbuilder.pos((double) j, (double) k, 0.0D).color(j1, k1, l1, 255).endVertex();

            for (int i2 = l; i2 >= 0; --i2) {
                float f = (float) ((d0 + datapoint1.relTime * (double) i2 / (double) l) * (double) ((float) Math.PI * 2F) / 100.0D);
                float f1 = MathHelper.sin(f) * 160.0F;
                float f2 = MathHelper.cos(f) * 160.0F * 0.5F;
                bufferbuilder.pos((double) ((float) j + f1), (double) ((float) k - f2), 0.0D).color(j1, k1, l1, 255).endVertex();
            }

            tessellator.draw();
            bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);

            for (int l2 = l; l2 >= 0; --l2) {
                float f3 = (float) ((d0 + datapoint1.relTime * (double) l2 / (double) l) * (double) ((float) Math.PI * 2F) / 100.0D);
                float f4 = MathHelper.sin(f3) * 160.0F;
                float f5 = MathHelper.cos(f3) * 160.0F * 0.5F;

                if (!(f5 > 0.0F)) {
                    bufferbuilder.pos((double) ((float) j + f4), (double) ((float) k - f5), 0.0D).color(j1 >> 1, k1 >> 1, l1 >> 1, 255).endVertex();
                    bufferbuilder.pos((double) ((float) j + f4), (double) ((float) k - f5 + 10.0F), 0.0D).color(j1 >> 1, k1 >> 1, l1 >> 1, 255).endVertex();
                }
            }

            tessellator.draw();
            d0 += datapoint1.relTime;
        }

        DecimalFormat decimalformat = new DecimalFormat("##0.00");
        decimalformat.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.ROOT));
        RenderSystem.enableTexture();
        String s = IProfileResult.decodePath(datapoint.name);
        String s1 = "";

        if (!"unspecified".equals(s)) {
            s1 = s1 + "[0] ";
        }

        if (s.isEmpty()) {
            s1 = s1 + "ROOT ";
        } else {
            s1 = s1 + s + ' ';
        }

        int k2 = 16777215;
        this.fontRenderer.drawStringWithShadow(matrixStack, s1, (float) (j - 160), (float) (k - 80 - 16), 16777215);
        s1 = decimalformat.format(datapoint.rootRelTime) + "%";
        this.fontRenderer.drawStringWithShadow(matrixStack, s1, (float) (j + 160 - this.fontRenderer.getStringWidth(s1)), (float) (k - 80 - 16), 16777215);

        for (int j2 = 0; j2 < list.size(); ++j2) {
            DataPoint datapoint2 = list.get(j2);
            StringBuilder stringbuilder = new StringBuilder();

            if ("unspecified".equals(datapoint2.name)) {
                stringbuilder.append("[?] ");
            } else {
                stringbuilder.append("[").append(j2 + 1).append("] ");
            }

            String s2 = stringbuilder.append(datapoint2.name).toString();
            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float) (j - 160), (float) (k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
            s2 = decimalformat.format(datapoint2.relTime) + "%";
            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float) (j + 160 - 50 - this.fontRenderer.getStringWidth(s2)), (float) (k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
            s2 = decimalformat.format(datapoint2.rootRelTime) + "%";
            this.fontRenderer.drawStringWithShadow(matrixStack, s2, (float) (j + 160 - this.fontRenderer.getStringWidth(s2)), (float) (k + 80 + j2 * 8 + 20), datapoint2.getTextColor());
        }
    }

    /**
     * Called when the window is closing. Sets 'running' to false which allows the game loop to exit cleanly.
     */
    public void shutdown() {
        this.running = false;
    }

    public boolean isRunning() {
        return this.running;
    }

    /**
     * Displays the ingame menu
     */
    public void displayInGameMenu(boolean pauseOnly) {
        if (this.currentScreen == null) {
            boolean flag = this.isSingleplayer() && !this.integratedServer.getPublic();

            if (flag) {
                this.displayGuiScreen(new IngameMenuScreen(!pauseOnly));
                this.soundHandler.pause();
            } else {
                this.displayGuiScreen(new IngameMenuScreen(true));
            }
        }
    }

    private void sendClickBlockToController(boolean leftClick) {
        if (!leftClick) {
            this.leftClickCounter = 0;
        }

        if (this.leftClickCounter <= 0 && !this.player.isHandActive()) {
            if (leftClick && this.objectMouseOver != null && this.objectMouseOver.getType() == RayTraceResult.Type.BLOCK) {
                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult) this.objectMouseOver;
                BlockPos blockpos = blockraytraceresult.getPos();

                if (!this.world.getBlockState(blockpos).isAir()) {
                    Direction direction = blockraytraceresult.getFace();

                    if (this.playerController.onPlayerDamageBlock(blockpos, direction)) {
                        this.particles.addBlockHitEffects(blockpos, direction);
                        this.player.swingArm(Hand.MAIN_HAND);
                    }
                }
            } else {
                this.playerController.resetBlockRemoving();
            }
        }
    }

    public void  clickMouse() {
        if (this.leftClickCounter <= 0) {
            if (this.objectMouseOver == null) {
                LOGGER.error("Null returned as 'hitResult', this shouldn't happen!");

                if (this.playerController.isNotCreative()) {
                    this.leftClickCounter = 10;
                }
            } else if (!this.player.isRowingBoat()) {
                switch (this.objectMouseOver.getType()) {
                    case ENTITY:
                        this.playerController.attackEntity(this.player, ((EntityRayTraceResult) this.objectMouseOver).getEntity());
                        break;

                    case BLOCK:
                        BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult) this.objectMouseOver;
                        BlockPos blockpos = blockraytraceresult.getPos();

                        if (!this.world.getBlockState(blockpos).isAir()) {
                            this.playerController.clickBlock(blockpos, blockraytraceresult.getFace());
                            break;
                        }

                    case MISS:
                        if (this.playerController.isNotCreative()) {
                            this.leftClickCounter = 10;
                        }

                        this.player.resetCooldown();
                }

                this.player.swingArm(Hand.MAIN_HAND);
            }
        }
    }

    /**
     * Called when user clicked he's mouse right button (place)
     */
    private void rightClickMouse() {
        if (!this.playerController.getIsHittingBlock()) {
            this.rightClickDelayTimer = 4;

            if (!this.player.isRowingBoat()) {
                if (this.objectMouseOver == null) {
                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
                }

                for (Hand hand : Hand.values()) {
                    ItemStack itemstack = this.player.getHeldItem(hand);
                    if (this.objectMouseOver != null) {
                        switch (this.objectMouseOver.getType()) {
                            case ENTITY -> {

                                EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult) this.objectMouseOver;
                                Entity entity = entityraytraceresult.getEntity();
                                ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);

                                EventInteractEntity eiwe = new EventInteractEntity(entity);
                                EventManager.call(eiwe);

                                if (!eiwe.isCancel()) {
                                    if (!actionresulttype.isSuccessOrConsume()) {
                                        actionresulttype = this.playerController.interactWithEntity(this.player, entity, hand);
                                    }
                                    if (actionresulttype.isSuccessOrConsume()) {
                                        if (actionresulttype.isSuccess()) {
                                            this.player.swingArm(hand);
                                        }

                                        return;
                                    }
                                }
                            }
                            case BLOCK -> {

                                BlockRayTraceResult blockraytraceresult = (BlockRayTraceResult) this.objectMouseOver;
                                int i = itemstack.getCount();
                                ActionResultType actionresulttype1 = this.playerController.processRightClickBlock(this.player, this.world, hand, blockraytraceresult);


                                if (actionresulttype1.isSuccessOrConsume()) {
                                    if (actionresulttype1.isSuccess()) {
                                        this.player.swingArm(hand);

                                        if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode())) {
                                            this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
                                        }
                                    }

                                    return;
                                }
                                if (actionresulttype1 == ActionResultType.FAIL) {
                                    return;
                                }
                            }
                        }
                    }
                    GappleCooldownFunction cooldown = Managment.FUNCTION_MANAGER.gappleCooldownFunction;
                    GappleCooldownFunction.ItemEnum itemEnum = GappleCooldownFunction.ItemEnum.getItemEnum(itemstack.getItem());



                    if (!itemstack.isEmpty()) {
                        ActionResultType actionresulttype2;

                        if (cooldown.state && itemEnum != null && cooldown.isCurrentItem(itemEnum) && player.getCooldownTracker().hasCooldown(itemEnum.getItem())) {
                            actionresulttype2 = ActionResultType.FAIL;
                        } else {
                            actionresulttype2 = this.playerController.processRightClick(this.player, this.world, hand);
                        }

                        if (actionresulttype2.isSuccessOrConsume()) {
                            if (actionresulttype2.isSuccess()) {
                                this.player.swingArm(hand);
                            }

                            this.gameRenderer.itemRenderer.resetEquippedProgress(hand);
                            return;
                        }
                    }
                }
            }
        }
    }

    /**
     * Return the musicTicker's instance
     */
    public MusicTicker getMusicTicker() {
        return this.musicTicker;
    }

    private boolean passEvents(Screen screen) {
        // allow user input is only the primary baritone
        return (BaritoneAPI.getProvider().getPrimaryBaritone().getPathingBehavior().isPathing() && player != null) || screen.passEvents;
    }

    /**
     * Runs the current tick.
     */
    public void runTick() {
        if (this.rightClickDelayTimer > 0) {
            --this.rightClickDelayTimer;
        }

        this.profiler.startSection("gui");

        if (!this.isGamePaused) {
            this.ingameGUI.tick();
        }

        this.profiler.endSection();
        this.gameRenderer.getMouseOver(1.0F);
        this.tutorial.onMouseHover(this.world, this.objectMouseOver);
        this.profiler.startSection("gameMode");

        if (!this.isGamePaused && this.world != null) {
            this.playerController.tick();
        }

        this.profiler.endStartSection("textures");

        if (this.world != null) {
            this.textureManager.tick();
        }

        if (this.currentScreen == null && this.player != null) {
            final BiFunction<EventState, TickEvent.Type, TickEvent> tickProvider = TickEvent.createNextProvider();

            for (IBaritone baritone : BaritoneAPI.getProvider().getAllBaritones()) {

                TickEvent.Type type = baritone.getPlayerContext().player() != null && baritone.getPlayerContext().world() != null
                        ? TickEvent.Type.IN
                        : TickEvent.Type.OUT;

                baritone.getGameEventHandler().onTick(tickProvider.apply(EventState.PRE, type));
            }
            if (this.player.getShouldBeDead() && !(this.currentScreen instanceof DeathScreen)) {
                this.displayGuiScreen((Screen) null);
            } else if (this.player.isSleeping() && this.world != null) {
                this.displayGuiScreen(new SleepInMultiplayerScreen());
            }
        } else if (this.currentScreen != null && this.currentScreen instanceof SleepInMultiplayerScreen && !this.player.isSleeping()) {
            this.displayGuiScreen((Screen) null);
        }

        if (this.currentScreen != null) {
            this.leftClickCounter = 10000;
        }

        if (this.currentScreen != null) {
            Screen.wrapScreenError(() ->
            {
                this.currentScreen.tick();
            }, "Ticking screen", this.currentScreen.getClass().getCanonicalName());
        }

        if (!this.gameSettings.showDebugInfo) {
            this.ingameGUI.reset();
        }

        if (this.loadingGui == null && (this.currentScreen == null || passEvents(currentScreen))) {
            this.profiler.endStartSection("Keybindings");
            this.processKeyBinds();

            if (this.leftClickCounter > 0) {
                --this.leftClickCounter;
            }
        }

        if (this.world != null) {
            this.profiler.endStartSection("gameRenderer");

            if (!this.isGamePaused) {
                this.gameRenderer.tick();
            }

            this.profiler.endStartSection("levelRenderer");

            if (!this.isGamePaused) {
                this.worldRenderer.tick();
            }

            this.profiler.endStartSection("level");

            if (!this.isGamePaused) {
                if (this.world.getTimeLightningFlash() > 0) {
                    this.world.setTimeLightningFlash(this.world.getTimeLightningFlash() - 1);
                }

                this.world.tickEntities();
            }
        } else if (this.gameRenderer.getShaderGroup() != null) {
            this.gameRenderer.stopUseShader();
        }

        if (!this.isGamePaused) {
            this.musicTicker.tick();
        }

        this.soundHandler.tick(this.isGamePaused);

        if (this.world != null) {
            if (!this.isGamePaused) {
                if (!this.gameSettings.field_244601_E && this.func_244600_aM()) {
                    ITextComponent itextcomponent = new TranslationTextComponent("tutorial.socialInteractions.title");
                    ITextComponent itextcomponent1 = new TranslationTextComponent("tutorial.socialInteractions.description", Tutorial.createKeybindComponent("socialInteractions"));
                    this.field_244598_aV = new TutorialToast(TutorialToast.Icons.SOCIAL_INTERACTIONS, itextcomponent, itextcomponent1, true);
                    this.tutorial.func_244698_a(this.field_244598_aV, 160);
                    this.gameSettings.field_244601_E = true;
                    this.gameSettings.saveOptions();
                }

                this.tutorial.tick();

                try {
                    this.world.tick(() ->
                    {
                        return true;
                    });
                } catch (Throwable throwable) {
                    CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception in world tick");

                    if (this.world == null) {
                        CrashReportCategory crashreportcategory = crashreport.makeCategory("Affected level");
                        crashreportcategory.addDetail("Problem", "Level is null!");
                    } else {
                        this.world.fillCrashReport(crashreport);
                    }

                    throw new ReportedException(crashreport);
                }
            }

            this.profiler.endStartSection("animateTick");

            if (!this.isGamePaused && this.world != null) {
                this.world.animateTick(MathHelper.floor(this.player.getPosX()), MathHelper.floor(this.player.getPosY()), MathHelper.floor(this.player.getPosZ()));
            }

            this.profiler.endStartSection("particles");

            if (!this.isGamePaused) {
                this.particles.tick();
            }
        } else if (this.networkManager != null) {
            this.profiler.endStartSection("pendingConnection");
            this.networkManager.tick();
        }

        this.profiler.endStartSection("keyboard");
        this.keyboardListener.tick();
        this.profiler.endSection();
    }

    private boolean func_244600_aM() {
        return !this.integratedServerIsRunning || this.integratedServer != null && this.integratedServer.getPublic();
    }

    private void processKeyBinds() {
        for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer.setDisplayListEntitiesDirty()) {
            PointOfView pointofview = this.gameSettings.getPointOfView();
            this.gameSettings.setPointOfView(this.gameSettings.getPointOfView().func_243194_c());

            if (pointofview.func_243192_a() != this.gameSettings.getPointOfView().func_243192_a()) {
                this.gameRenderer.loadEntityShader(this.gameSettings.getPointOfView().func_243192_a() ? this.getRenderViewEntity() : null);
            }
        }

        while (this.gameSettings.keyBindSmoothCamera.isPressed()) {
            this.gameSettings.smoothCamera = !this.gameSettings.smoothCamera;
        }

        for (int i = 0; i < 9; ++i) {
            boolean flag = this.gameSettings.keyBindSaveToolbar.isKeyDown();
            boolean flag1 = this.gameSettings.keyBindLoadToolbar.isKeyDown();

            if (this.gameSettings.keyBindsHotbar[i].isPressed()) {
                if (this.player.isSpectator()) {
                    this.ingameGUI.getSpectatorGui().onHotbarSelected(i);
                } else if (!this.player.isCreative() || this.currentScreen != null || !flag1 && !flag) {
                    this.player.inventory.currentItem = i;
                } else {
                    CreativeScreen.handleHotbarSnapshots(this, i, flag1, flag);
                }
            }
        }

        while (this.gameSettings.field_244602_au.isPressed()) {
            if (!this.func_244600_aM()) {
                this.player.sendStatusMessage(field_244596_I, true);
                NarratorChatListener.INSTANCE.say(field_244596_I.getString());
            } else {
                if (this.field_244598_aV != null) {
                    this.tutorial.func_244697_a(this.field_244598_aV);
                    this.field_244598_aV = null;
                }

                this.displayGuiScreen(new SocialInteractionsScreen());
            }
        }

        while (this.gameSettings.keyBindInventory.isPressed()) {
            if (this.playerController.isRidingHorse()) {
                this.player.sendHorseInventory();
            } else {
                this.tutorial.openInventory();
                this.displayGuiScreen(new InventoryScreen(this.player));
            }
        }

        while (this.gameSettings.keyBindAdvancements.isPressed()) {
            this.displayGuiScreen(new AdvancementsScreen(this.player.connection.getAdvancementManager()));
        }

        while (this.gameSettings.keyBindSwapHands.isPressed()) {
            if (!this.player.isSpectator()) {
                this.getConnection().sendPacket(new CPlayerDiggingPacket(CPlayerDiggingPacket.Action.SWAP_ITEM_WITH_OFFHAND, BlockPos.ZERO, Direction.DOWN));
            }
        }

        while (this.gameSettings.keyBindDrop.isPressed()) {
            if (!this.player.isSpectator() && this.player.drop(Screen.hasControlDown())) {
                this.player.swingArm(Hand.MAIN_HAND);
            }
        }

        boolean flag2 = this.gameSettings.chatVisibility != ChatVisibility.HIDDEN;

        if (flag2) {
            while (this.gameSettings.keyBindChat.isPressed()) {
                this.openChatScreen("");
            }

            if (this.currentScreen == null && this.loadingGui == null && this.gameSettings.keyBindCommand.isPressed()) {
                this.openChatScreen("/");
            }
        }

        if (this.player.isHandActive()) {
            if (!this.gameSettings.keyBindUseItem.isKeyDown()) {
                this.playerController.onStoppedUsingItem(this.player);
            }

            while (this.gameSettings.keyBindAttack.isPressed()) {
            }

            while (this.gameSettings.keyBindUseItem.isPressed()) {
            }

            while (this.gameSettings.keyBindPickBlock.isPressed()) {
            }
        } else {
            while (this.gameSettings.keyBindAttack.isPressed()) {
                this.clickMouse();
            }

            while (this.gameSettings.keyBindUseItem.isPressed()) {
                this.rightClickMouse();
            }

            while (this.gameSettings.keyBindPickBlock.isPressed()) {
                this.middleClickMouse();
            }
        }

        if (this.gameSettings.keyBindUseItem.isKeyDown() && this.rightClickDelayTimer == 0 && !this.player.isHandActive()) {
            this.rightClickMouse();
        }
        if (this.currentScreen != null && !(Managment.FUNCTION_MANAGER.autoGApple.state && Managment.FUNCTION_MANAGER.autoGApple.canEat()))
            return;
        this.sendClickBlockToController(this.gameSettings.keyBindAttack.isKeyDown() && this.mouseHelper.isMouseGrabbed());
    }

    public static DatapackCodec loadDataPackCodec(SaveFormat.LevelSave worldStorage) {
        MinecraftServer.func_240777_a_(worldStorage);
        DatapackCodec datapackcodec = worldStorage.readDatapackCodec();

        if (datapackcodec == null) {
            throw new IllegalStateException("Failed to load data pack config");
        } else {
            return datapackcodec;
        }
    }

    public static IServerConfiguration loadWorld(SaveFormat.LevelSave worldStorage, DynamicRegistries.Impl dynamicRegistries, IResourceManager resourceManager, DatapackCodec datapackCodec) {



        WorldSettingsImport<INBT> worldsettingsimport = WorldSettingsImport.create(NBTDynamicOps.INSTANCE, resourceManager, dynamicRegistries);
        IServerConfiguration iserverconfiguration = worldStorage.readServerConfiguration(worldsettingsimport, datapackCodec);

        if (iserverconfiguration == null) {
            throw new IllegalStateException("Failed to load world");
        } else {
            return iserverconfiguration;
        }
    }
    public void loadWorld(String worldName) {
        this.loadWorld(worldName, DynamicRegistries.func_239770_b_(), Minecraft::loadDataPackCodec, Minecraft::loadWorld, false, WorldSelectionType.BACKUP);
    }

    public void createWorld(String worldName, WorldSettings worldSettings, DynamicRegistries.Impl dynamicRegistriesIn, DimensionGeneratorSettings dimensionGeneratorSettings) {
        this.loadWorld(worldName, dynamicRegistriesIn, (worldStorage) ->
        {
            return worldSettings.getDatapackCodec();
        }, (worldStorage, dynamicRegistries, resourceManager, datapackCodec) ->
        {
            WorldGenSettingsExport<JsonElement> worldgensettingsexport = WorldGenSettingsExport.create(JsonOps.INSTANCE, dynamicRegistriesIn);
            WorldSettingsImport<JsonElement> worldsettingsimport = WorldSettingsImport.create(JsonOps.INSTANCE, resourceManager, dynamicRegistriesIn);
            DataResult<DimensionGeneratorSettings> dataresult = DimensionGeneratorSettings.field_236201_a_.encodeStart(worldgensettingsexport, dimensionGeneratorSettings).setLifecycle(Lifecycle.stable()).flatMap((p_243209_1_) -> {
                return DimensionGeneratorSettings.field_236201_a_.parse(worldsettingsimport, p_243209_1_);
            });
            DimensionGeneratorSettings dimensiongeneratorsettings = dataresult.resultOrPartial(Util.func_240982_a_("Error reading worldgen settings after loading data packs: ", LOGGER::error)).orElse(dimensionGeneratorSettings);
            return new ServerWorldInfo(worldSettings, dimensiongeneratorsettings, dataresult.lifecycle());
        }, false, WorldSelectionType.CREATE);
    }

    private void loadWorld(String worldName, DynamicRegistries.Impl dynamicRegistries, Function<SaveFormat.LevelSave, DatapackCodec> levelSaveToDatapackFunction, Function4<SaveFormat.LevelSave, DynamicRegistries.Impl, IResourceManager, DatapackCodec, IServerConfiguration> quadFunction, boolean vanillaOnly, WorldSelectionType selectionType) {
        SaveFormat.LevelSave saveformat$levelsave;
        try {
            saveformat$levelsave = this.saveFormat.getLevelSave(worldName);
        } catch (IOException ioexception2) {
            LOGGER.warn("Failed to read level {} data", worldName, ioexception2);
            SystemToast.func_238535_a_(this, worldName);
            this.displayGuiScreen((Screen) null);
            return;
        }

        PackManager minecraft$packmanager;

        try {
            minecraft$packmanager = this.reloadDatapacks(dynamicRegistries, levelSaveToDatapackFunction, quadFunction, vanillaOnly, saveformat$levelsave);
        } catch (Exception exception) {
            LOGGER.warn("Failed to load datapacks, can't proceed with server load", (Throwable) exception);
            this.displayGuiScreen(new DatapackFailureScreen(() ->
            {
                this.loadWorld(worldName, dynamicRegistries, levelSaveToDatapackFunction, quadFunction, true, selectionType);
            }));

            try {
                saveformat$levelsave.close();
            } catch (IOException ioexception) {
                LOGGER.warn("Failed to unlock access to level {}", worldName, ioexception);
            }

            return;
        }

        IServerConfiguration iserverconfiguration = minecraft$packmanager.getServerConfiguration();
        boolean flag = iserverconfiguration.getDimensionGeneratorSettings().func_236229_j_();
        boolean flag1 = iserverconfiguration.getLifecycle() != Lifecycle.stable();

        if (selectionType == WorldSelectionType.NONE || !flag && !flag1) {
            this.unloadWorld();
            this.refChunkStatusListener.set((TrackingChunkStatusListener) null);

            try {
                saveformat$levelsave.saveLevel(dynamicRegistries, iserverconfiguration);
                minecraft$packmanager.getDataPackRegistries().updateTags();
                YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(this.proxy);
                MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
                GameProfileRepository gameprofilerepository = yggdrasilauthenticationservice.createProfileRepository();
                PlayerProfileCache playerprofilecache = new PlayerProfileCache(gameprofilerepository, new File(this.gameDir, MinecraftServer.USER_CACHE_FILE.getName()));
                SkullTileEntity.setProfileCache(playerprofilecache);
                SkullTileEntity.setSessionService(minecraftsessionservice);
                PlayerProfileCache.setOnlineMode(false);
                this.integratedServer = MinecraftServer.func_240784_a_((thread) ->
                {
                    return new IntegratedServer(thread, this, dynamicRegistries, saveformat$levelsave, minecraft$packmanager.getResourcePacks(), minecraft$packmanager.getDataPackRegistries(), iserverconfiguration, minecraftsessionservice, gameprofilerepository, playerprofilecache, (radius) -> {
                        TrackingChunkStatusListener trackingchunkstatuslistener = new TrackingChunkStatusListener(radius + 0);
                        trackingchunkstatuslistener.startTracking();
                        this.refChunkStatusListener.set(trackingchunkstatuslistener);
                        return new ChainedChunkStatusListener(trackingchunkstatuslistener, this.queueChunkTracking::add);
                    });
                });
                this.integratedServerIsRunning = true;
            } catch (Throwable throwable) {
                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Starting integrated server");
                CrashReportCategory crashreportcategory = crashreport.makeCategory("Starting integrated server");
                crashreportcategory.addDetail("Level ID", worldName);
                crashreportcategory.addDetail("Level Name", iserverconfiguration.getWorldName());
                throw new ReportedException(crashreport);
            }

            while (this.refChunkStatusListener.get() == null) {
                Thread.yield();
            }

            WorldLoadProgressScreen worldloadprogressscreen = new WorldLoadProgressScreen(this.refChunkStatusListener.get());
            this.displayGuiScreen(worldloadprogressscreen);
            this.profiler.startSection("waitForServer");

            while (!this.integratedServer.serverIsInRunLoop()) {
                worldloadprogressscreen.tick();
                this.runGameLoop(false);

                try {
                    Thread.sleep(16L);
                } catch (InterruptedException interruptedexception) {
                }

                if (this.crashReporter != null) {
                    displayCrashReport(this.crashReporter);
                    return;
                }
            }

            this.profiler.endSection();
            SocketAddress socketaddress = this.integratedServer.getNetworkSystem().addLocalEndpoint();
            NetworkManager networkmanager = NetworkManager.provideLocalClient(socketaddress);
            networkmanager.setNetHandler(new ClientLoginNetHandler(networkmanager, this, (Screen) null, (statusMessage) ->
            {
            }));
            networkmanager.sendPacket(new CHandshakePacket(socketaddress.toString(), 0, ProtocolType.LOGIN));
            networkmanager.sendPacket(new CLoginStartPacket(this.getSession().getProfile()));
            this.networkManager = networkmanager;
        } else {
            this.deleteWorld(selectionType, worldName, flag, () ->
            {
                this.loadWorld(worldName, dynamicRegistries, levelSaveToDatapackFunction, quadFunction, vanillaOnly, WorldSelectionType.NONE);
            });
            minecraft$packmanager.close();

            try {
                saveformat$levelsave.close();
            } catch (IOException ioexception1) {
                LOGGER.warn("Failed to unlock access to level {}", worldName, ioexception1);
            }
        }
    }

    private void deleteWorld(WorldSelectionType selectionType, String worldName, boolean customized, Runnable runnable) {
        if (selectionType == WorldSelectionType.BACKUP) {
            ITextComponent itextcomponent;
            ITextComponent itextcomponent1;

            if (customized) {
                itextcomponent = new TranslationTextComponent("selectWorld.backupQuestion.customized");
                itextcomponent1 = new TranslationTextComponent("selectWorld.backupWarning.customized");
            } else {
                itextcomponent = new TranslationTextComponent("selectWorld.backupQuestion.experimental");
                itextcomponent1 = new TranslationTextComponent("selectWorld.backupWarning.experimental");
            }

            this.displayGuiScreen(new ConfirmBackupScreen((Screen) null, (editMode, checkedBox) ->
            {
                if (editMode) {
                    EditWorldScreen.func_241651_a_(this.saveFormat, worldName);
                }

                runnable.run();
            }, itextcomponent, itextcomponent1, false));
        } else {
            this.displayGuiScreen(new ConfirmScreen((confirm) ->
            {
                if (confirm) {
                    runnable.run();
                } else {
                    this.displayGuiScreen((Screen) null);

                    try (SaveFormat.LevelSave saveformat$levelsave = this.saveFormat.getLevelSave(worldName)) {
                        saveformat$levelsave.deleteSave();
                    } catch (IOException ioexception) {
                        SystemToast.func_238538_b_(this, worldName);
                        LOGGER.error("Failed to delete world {}", worldName, ioexception);
                    }
                }
            }, new TranslationTextComponent("selectWorld.backupQuestion.experimental"), new TranslationTextComponent("selectWorld.backupWarning.experimental"), DialogTexts.GUI_PROCEED, DialogTexts.GUI_CANCEL));
        }
    }

    public PackManager reloadDatapacks(DynamicRegistries.Impl dynamicRegistries, Function<SaveFormat.LevelSave, DatapackCodec> worldStorageToDatapackFunction, Function4<SaveFormat.LevelSave, DynamicRegistries.Impl, IResourceManager, DatapackCodec, IServerConfiguration> quadFunction, boolean vanillaOnly, SaveFormat.LevelSave worldStorage) throws InterruptedException, ExecutionException {
        DatapackCodec datapackcodec = worldStorageToDatapackFunction.apply(worldStorage);
        ResourcePackList resourcepacklist = new ResourcePackList(new ServerPackFinder(), new FolderPackFinder(worldStorage.resolveFilePath(FolderName.DATAPACKS).toFile(), IPackNameDecorator.WORLD));

        try {
            DatapackCodec datapackcodec1 = MinecraftServer.func_240772_a_(resourcepacklist, datapackcodec, vanillaOnly);
            CompletableFuture<DataPackRegistries> completablefuture = DataPackRegistries.func_240961_a_(resourcepacklist.func_232623_f_(), Commands.EnvironmentType.INTEGRATED, 2, Util.getServerExecutor(), this);
            this.driveUntil(completablefuture::isDone);
            DataPackRegistries datapackregistries = completablefuture.get();
            IServerConfiguration iserverconfiguration = quadFunction.apply(worldStorage, dynamicRegistries, datapackregistries.getResourceManager(), datapackcodec1);
            return new PackManager(resourcepacklist, datapackregistries, iserverconfiguration);
        } catch (ExecutionException | InterruptedException interruptedexception) {
            resourcepacklist.close();
            throw interruptedexception;
        }
    }

    /**
     * unloads the current world first
     */
    public void loadWorld(ClientWorld worldClientIn) {

        BaritoneAPI.getProvider().getPrimaryBaritone().getGameEventHandler().onWorldEvent(
                new WorldEvent(
                        worldClientIn,
                        EventState.PRE
                )
        );

        WorkingScreen workingscreen = new WorkingScreen();
        workingscreen.displaySavingString(new TranslationTextComponent("connect.joining"));
        this.updateScreenTick(workingscreen);
        this.world = worldClientIn;
        this.updateWorldRenderer(worldClientIn);

        if (!this.integratedServerIsRunning) {
            AuthenticationService authenticationservice = new YggdrasilAuthenticationService(this.proxy);
            MinecraftSessionService minecraftsessionservice = authenticationservice.createMinecraftSessionService();
            GameProfileRepository gameprofilerepository = authenticationservice.createProfileRepository();
            PlayerProfileCache playerprofilecache = new PlayerProfileCache(gameprofilerepository, new File(this.gameDir, MinecraftServer.USER_CACHE_FILE.getName()));
            SkullTileEntity.setProfileCache(playerprofilecache);
            SkullTileEntity.setSessionService(minecraftsessionservice);
            PlayerProfileCache.setOnlineMode(false);
        }
        BaritoneAPI.getProvider().getPrimaryBaritone().getGameEventHandler().onWorldEvent(
                new WorldEvent(
                        worldClientIn,
                        EventState.POST
                )
        );
    }

    public void unloadWorld() {
        this.unloadWorld(new WorkingScreen());
    }

    public void unloadWorld(Screen screenIn) {
        ClientPlayNetHandler clientplaynethandler = this.getConnection();

        if (clientplaynethandler != null) {
            this.dropTasks();
            clientplaynethandler.cleanup();
        }

        IntegratedServer integratedserver = this.integratedServer;
        this.integratedServer = null;
        this.gameRenderer.resetData();
        this.playerController = null;
        NarratorChatListener.INSTANCE.clear();
        this.updateScreenTick(screenIn);

        if (this.world != null) {
            if (integratedserver != null) {
                this.profiler.startSection("waitForServer");

                while (!integratedserver.isThreadAlive()) {
                    this.runGameLoop(false);
                }

                this.profiler.endSection();
            }

            this.packFinder.clearResourcePack();
            this.ingameGUI.resetPlayersOverlayFooterHeader();
            this.currentServerData = null;
            this.integratedServerIsRunning = false;
            this.game.leaveGameSession();
        }

        this.world = null;
        this.updateWorldRenderer((ClientWorld) null);
        this.player = null;
    }

    private void updateScreenTick(Screen screenIn) {
        this.profiler.startSection("forcedTick");
        this.soundHandler.stop();
        this.renderViewEntity = null;
        this.networkManager = null;
        this.displayGuiScreen(screenIn);
        this.runGameLoop(false);
        this.profiler.endSection();
    }

    public void forcedScreenTick(Screen screen) {
        this.profiler.startSection("forcedTick");
        this.displayGuiScreen(screen);
        this.runGameLoop(false);
        this.profiler.endSection();
    }

    private void updateWorldRenderer(@Nullable ClientWorld worldIn) {
        this.worldRenderer.setWorldAndLoadRenderers(worldIn);
        this.particles.clearEffects(worldIn);
        TileEntityRendererDispatcher.instance.setWorld(worldIn);
        this.setDefaultMinecraftTitle();
    }

    public boolean isMultiplayerEnabled() {
        return true;
    }

    public boolean cannotSendChatMessages(UUID playerUUID) {
        if (this.isChatEnabled()) {
            return this.field_244597_aC.func_244756_c(playerUUID);
        } else {
            return (this.player == null || !playerUUID.equals(this.player.getUniqueID())) && !playerUUID.equals(Util.DUMMY_UUID);
        }
    }

    public boolean isChatEnabled() {
        return true;
    }

    /**
     * Gets whether this is a demo or not.
     */
    public final boolean isDemo() {
        return this.isDemo;
    }

    @Nullable
    public ClientPlayNetHandler getConnection() {
        return this.player == null ? null : this.player.connection;
    }

    public static boolean isGuiEnabled() {
        return !instance.gameSettings.hideGUI;
    }

    public static boolean isFancyGraphicsEnabled() {
        return instance.gameSettings.graphicFanciness.func_238162_a_() >= GraphicsFanciness.FANCY.func_238162_a_();
    }

    public static boolean isFabulousGraphicsEnabled() {
        return instance.gameSettings.graphicFanciness.func_238162_a_() >= GraphicsFanciness.FABULOUS.func_238162_a_();
    }

    /**
     * Returns if ambient occlusion is enabled
     */
    public static boolean isAmbientOcclusionEnabled() {
        return instance.gameSettings.ambientOcclusionStatus != AmbientOcclusionStatus.OFF;
    }

    /**
     * Called when user clicked he's mouse middle button (pick block)
     */
    private void middleClickMouse() {
        if (this.objectMouseOver != null && this.objectMouseOver.getType() != RayTraceResult.Type.MISS) {
            boolean flag = this.player.abilities.isCreativeMode;
            TileEntity tileentity = null;
            RayTraceResult.Type raytraceresult$type = this.objectMouseOver.getType();
            ItemStack itemstack;

            if (raytraceresult$type == RayTraceResult.Type.BLOCK) {
                BlockPos blockpos = ((BlockRayTraceResult) this.objectMouseOver).getPos();
                BlockState blockstate = this.world.getBlockState(blockpos);
                Block block = blockstate.getBlock();

                if (blockstate.isAir()) {
                    return;
                }

                itemstack = block.getItem(this.world, blockpos, blockstate);

                if (itemstack.isEmpty()) {
                    return;
                }

                if (flag && Screen.hasControlDown() && block.isTileEntityProvider()) {
                    tileentity = this.world.getTileEntity(blockpos);
                }
            } else {
                if (raytraceresult$type != RayTraceResult.Type.ENTITY || !flag) {
                    return;
                }

                Entity entity = ((EntityRayTraceResult) this.objectMouseOver).getEntity();

                if (entity instanceof PaintingEntity) {
                    itemstack = new ItemStack(Items.PAINTING);
                } else if (entity instanceof LeashKnotEntity) {
                    itemstack = new ItemStack(Items.LEAD);
                } else if (entity instanceof ItemFrameEntity) {
                    ItemFrameEntity itemframeentity = (ItemFrameEntity) entity;
                    ItemStack itemstack1 = itemframeentity.getDisplayedItem();

                    if (itemstack1.isEmpty()) {
                        itemstack = new ItemStack(Items.ITEM_FRAME);
                    } else {
                        itemstack = itemstack1.copy();
                    }
                } else if (entity instanceof AbstractMinecartEntity) {
                    AbstractMinecartEntity abstractminecartentity = (AbstractMinecartEntity) entity;
                    Item item;

                    switch (abstractminecartentity.getMinecartType()) {
                        case FURNACE:
                            item = Items.FURNACE_MINECART;
                            break;

                        case CHEST:
                            item = Items.CHEST_MINECART;
                            break;

                        case TNT:
                            item = Items.TNT_MINECART;
                            break;

                        case HOPPER:
                            item = Items.HOPPER_MINECART;
                            break;

                        case COMMAND_BLOCK:
                            item = Items.COMMAND_BLOCK_MINECART;
                            break;

                        default:
                            item = Items.MINECART;
                    }

                    itemstack = new ItemStack(item);
                } else if (entity instanceof BoatEntity) {
                    itemstack = new ItemStack(((BoatEntity) entity).getItemBoat());
                } else if (entity instanceof ArmorStandEntity) {
                    itemstack = new ItemStack(Items.ARMOR_STAND);
                } else if (entity instanceof EnderCrystalEntity) {
                    itemstack = new ItemStack(Items.END_CRYSTAL);
                } else {
                    SpawnEggItem spawneggitem = SpawnEggItem.getEgg(entity.getType());

                    if (spawneggitem == null) {
                        return;
                    }

                    itemstack = new ItemStack(spawneggitem);
                }
            }

            if (itemstack.isEmpty()) {
                String s = "";

                if (raytraceresult$type == RayTraceResult.Type.BLOCK) {
                    s = Registry.BLOCK.getKey(this.world.getBlockState(((BlockRayTraceResult) this.objectMouseOver).getPos()).getBlock()).toString();
                } else if (raytraceresult$type == RayTraceResult.Type.ENTITY) {
                    s = Registry.ENTITY_TYPE.getKey(((EntityRayTraceResult) this.objectMouseOver).getEntity().getType()).toString();
                }

                LOGGER.warn("Picking on: [{}] {} gave null item", raytraceresult$type, s);
            } else {
                PlayerInventory playerinventory = this.player.inventory;

                if (tileentity != null) {
                    this.storeTEInStack(itemstack, tileentity);
                }

                int i = playerinventory.getSlotFor(itemstack);

                if (flag) {
                    playerinventory.setPickedItemStack(itemstack);
                    this.playerController.sendSlotPacket(this.player.getHeldItem(Hand.MAIN_HAND), 36 + playerinventory.currentItem);
                } else if (i != -1) {
                    if (PlayerInventory.isHotbar(i)) {
                        playerinventory.currentItem = i;
                    } else {
                        this.playerController.pickItem(i);
                    }
                }
            }
        }
    }

    private ItemStack storeTEInStack(ItemStack stack, TileEntity te) {
        CompoundNBT compoundnbt = te.write(new CompoundNBT());

        if (stack.getItem() instanceof SkullItem && compoundnbt.contains("SkullOwner")) {
            CompoundNBT compoundnbt2 = compoundnbt.getCompound("SkullOwner");
            stack.getOrCreateTag().put("SkullOwner", compoundnbt2);
            return stack;
        } else {
            stack.setTagInfo("BlockEntityTag", compoundnbt);
            CompoundNBT compoundnbt1 = new CompoundNBT();
            ListNBT listnbt = new ListNBT();
            listnbt.add(StringNBT.valueOf("\"(+NBT)\""));
            compoundnbt1.put("Lore", listnbt);
            stack.setTagInfo("display", compoundnbt1);
            return stack;
        }
    }

    /**
     * adds core server Info (GL version , Texture pack, isModded, type), and the worldInfo to the crash report
     */
    public CrashReport addGraphicsAndWorldToCrashReport(CrashReport theCrash) {
        fillCrashReport(this.languageManager, this.launchedVersion, this.gameSettings, theCrash);

        if (this.world != null) {
            this.world.fillCrashReport(theCrash);
        }

        return theCrash;
    }

    public static void fillCrashReport(@Nullable LanguageManager languageManagerIn, String versionIn, @Nullable GameSettings settingsIn, CrashReport crashReportIn) {
        CrashReportCategory crashreportcategory = crashReportIn.getCategory();
        crashreportcategory.addDetail("Launched Version", () ->
        {
            return versionIn;
        });
        crashreportcategory.addDetail("Backend library", RenderSystem::getBackendDescription);
        crashreportcategory.addDetail("Backend API", RenderSystem::getApiDescription);
        crashreportcategory.addDetail("GL Caps", RenderSystem::getCapsString);
        crashreportcategory.addDetail("Using VBOs", () ->
        {
            return "Yes";
        });
        crashreportcategory.addDetail("Is Modded", () ->
        {
            String s1 = ClientBrandRetriever.getClientModName();

            if (!"vanilla".equals(s1)) {
                return "Definitely; Client brand changed to '" + s1 + "'";
            } else {
                return Minecraft.class.getSigners() == null ? "Very likely; Jar signature invalidated" : "Probably not. Jar signature remains and client brand is untouched.";
            }
        });
        crashreportcategory.addDetail("Type", "Client (map_client.txt)");

        if (settingsIn != null) {
            if (instance != null) {
                String s = instance.getGPUWarning().func_243499_m();

                if (s != null) {
                    crashreportcategory.addDetail("GPU Warnings", s);
                }
            }

            crashreportcategory.addDetail("Graphics mode", settingsIn.graphicFanciness);
            crashreportcategory.addDetail("Resource Packs", () ->
            {
                StringBuilder stringbuilder = new StringBuilder();

                for (String s1 : settingsIn.resourcePacks) {
                    if (stringbuilder.length() > 0) {
                        stringbuilder.append(", ");
                    }

                    stringbuilder.append(s1);

                    if (settingsIn.incompatibleResourcePacks.contains(s1)) {
                        stringbuilder.append(" (incompatible)");
                    }
                }

                return stringbuilder.toString();
            });
        }

        if (languageManagerIn != null) {
            crashreportcategory.addDetail("Current Language", () ->
            {
                return languageManagerIn.getCurrentLanguage().toString();
            });
        }

        crashreportcategory.addDetail("CPU", PlatformDescriptors::getCpuInfo);
    }

    /**
     * Return the singleton Minecraft instance for the game
     */
    public static Minecraft getInstance() {
        return instance;
    }

    public CompletableFuture<Void> scheduleResourcesRefresh() {
        return this.supplyAsync(this::reloadResources).thenCompose((voidIn) ->
        {
            return voidIn;
        });
    }

    public void fillSnooper(Snooper snooper) {
        snooper.addClientStat("fps", debugFPS);
        snooper.addClientStat("vsync_enabled", this.gameSettings.vsync);
        snooper.addClientStat("display_frequency", this.mainWindow.getRefreshRate());
        snooper.addClientStat("display_type", this.mainWindow.isFullscreen() ? "fullscreen" : "windowed");
        snooper.addClientStat("run_time", (Util.milliTime() - snooper.getMinecraftStartTimeMillis()) / 60L * 1000L);
        snooper.addClientStat("current_action", this.getCurrentAction());
        snooper.addClientStat("language", this.gameSettings.language == null ? "en_us" : this.gameSettings.language);
        String s = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN ? "little" : "big";
        snooper.addClientStat("endianness", s);
        snooper.addClientStat("subtitles", this.gameSettings.showSubtitles);
        snooper.addClientStat("touch", this.gameSettings.touchscreen ? "touch" : "mouse");
        int i = 0;

        for (ResourcePackInfo resourcepackinfo : this.resourcePackRepository.getEnabledPacks()) {
            if (!resourcepackinfo.isAlwaysEnabled() && !resourcepackinfo.isOrderLocked()) {
                snooper.addClientStat("resource_pack[" + i++ + "]", resourcepackinfo.getName());
            }
        }

        snooper.addClientStat("resource_packs", i);

        if (this.integratedServer != null) {
            snooper.addClientStat("snooper_partner", this.integratedServer.getSnooper().getUniqueID());
        }
    }

    /**
     * Return the current action's name
     */
    private String getCurrentAction() {
        if (this.integratedServer != null) {
            return this.integratedServer.getPublic() ? "hosting_lan" : "singleplayer";
        } else if (this.currentServerData != null) {
            return this.currentServerData.isOnLAN() ? "playing_lan" : "multiplayer";
        } else {
            return "out_of_game";
        }
    }

    /**
     * Set the current ServerData instance.
     */
    public void setServerData(@Nullable ServerData serverDataIn) {
        this.currentServerData = serverDataIn;
    }

    @Nullable
    public ServerData getCurrentServerData() {
        return this.currentServerData;
    }

    public boolean isIntegratedServerRunning() {
        return this.integratedServerIsRunning;
    }

    /**
     * Returns true if there is only one player playing, and the current server is the integrated one.
     */
    public boolean isSingleplayer() {
        return this.integratedServerIsRunning && this.integratedServer != null;
    }

    @Nullable

    /**
     * Returns the currently running integrated server
     */
    public IntegratedServer getIntegratedServer() {
        return this.integratedServer;
    }

    /**
     * Returns the PlayerUsageSnooper instance.
     */
    public Snooper getSnooper() {
        return this.snooper;
    }

    public Session getSession() {
        return this.session;
    }

    /**
     * Return the player's GameProfile properties
     */
    public PropertyMap getProfileProperties() {
        if (this.profileProperties.isEmpty()) {
            GameProfile gameprofile = this.getSessionService().fillProfileProperties(this.session.getProfile(), false);
            this.profileProperties.putAll(gameprofile.getProperties());
        }

        return this.profileProperties;
    }

    public Proxy getProxy() {
        return this.proxy;
    }

    public TextureManager getTextureManager() {
        return this.textureManager;
    }

    public IResourceManager getResourceManager() {
        return this.resourceManager;
    }

    public ResourcePackList getResourcePackList() {
        return this.resourcePackRepository;
    }

    public DownloadingPackFinder getPackFinder() {
        return this.packFinder;
    }

    public File getFileResourcePacks() {
        return this.fileResourcepacks;
    }

    public LanguageManager getLanguageManager() {
        return this.languageManager;
    }

    public Function<ResourceLocation, TextureAtlasSprite> getAtlasSpriteGetter(ResourceLocation locationIn) {
        return this.modelManager.getAtlasTexture(locationIn)::getSprite;
    }

    public boolean isJava64bit() {
        return this.jvm64bit;
    }

    public boolean isGamePaused() {
        return this.isGamePaused;
    }

    public GPUWarning getGPUWarning() {
        return this.warningGPU;
    }

    public SoundHandler getSoundHandler() {
        return this.soundHandler;
    }

    public BackgroundMusicSelector getBackgroundMusicSelector() {
        if (this.currentScreen instanceof WinGameScreen) {
            return BackgroundMusicTracks.CREDITS_MUSIC;
        } else if (this.player != null) {
            if (this.player.world.getDimensionKey() == World.THE_END) {
                return this.ingameGUI.getBossOverlay().shouldPlayEndBossMusic() ? BackgroundMusicTracks.DRAGON_FIGHT_MUSIC : BackgroundMusicTracks.END_MUSIC;
            } else {
                Biome.Category biome$category = this.player.world.getBiome(this.player.getPosition()).getCategory();

                if (!this.musicTicker.isBackgroundMusicPlaying(BackgroundMusicTracks.UNDER_WATER_MUSIC) && (!this.player.canSwim() || biome$category != Biome.Category.OCEAN && biome$category != Biome.Category.RIVER)) {
                    return this.player.world.getDimensionKey() != World.THE_NETHER && this.player.abilities.isCreativeMode && this.player.abilities.allowFlying ? BackgroundMusicTracks.CREATIVE_MODE_MUSIC : this.world.getBiomeManager().getBiomeAtPosition(this.player.getPosition()).getBackgroundMusic().orElse(BackgroundMusicTracks.WORLD_MUSIC);
                } else {
                    return BackgroundMusicTracks.UNDER_WATER_MUSIC;
                }
            }
        } else {
            return BackgroundMusicTracks.MAIN_MENU_MUSIC;
        }
    }

    public MinecraftSessionService getSessionService() {
        return this.sessionService;
    }

    public SkinManager getSkinManager() {
        return this.skinManager;
    }

    @Nullable
    public Entity getRenderViewEntity() {
        return this.renderViewEntity;
    }

    public void setRenderViewEntity(Entity viewingEntity) {
        this.renderViewEntity = viewingEntity;
        this.gameRenderer.loadEntityShader(viewingEntity);
    }

    public boolean isEntityGlowing(Entity entity) {
        return entity.isGlowing() || this.player != null && this.player.isSpectator() && this.gameSettings.keyBindSpectatorOutlines.isKeyDown() && entity.getType() == EntityType.PLAYER;
    }

    protected Thread getExecutionThread() {
        return this.thread;
    }

    protected Runnable wrapTask(Runnable runnable) {
        return runnable;
    }

    protected boolean canRun(Runnable runnable) {
        return true;
    }

    public BlockRendererDispatcher getBlockRendererDispatcher() {
        return this.blockRenderDispatcher;
    }

    public EntityRendererManager getRenderManager() {
        return this.renderManager;
    }

    public ItemRenderer getItemRenderer() {
        return this.itemRenderer;
    }

    public FirstPersonRenderer getFirstPersonRenderer() {
        return this.firstPersonRenderer;
    }

    public <T> IMutableSearchTree<T> getSearchTree(SearchTreeManager.Key<T> key) {
        return this.searchTreeManager.get(key);
    }

    /**
     * Return the FrameTimer's instance
     */
    public FrameTimer getFrameTimer() {
        return this.frameTimer;
    }

    /**
     * Return true if the player is connected to a realms server
     */
    public boolean isConnectedToRealms() {
        return this.connectedToRealms;
    }

    /**
     * Set if the player is connected to a realms server
     */
    public void setConnectedToRealms(boolean isConnected) {
        this.connectedToRealms = isConnected;
    }

    public DataFixer getDataFixer() {
        return this.dataFixer;
    }

    public float getRenderPartialTicks() {
        return this.timer.renderPartialTicks;
    }

    public float getTickLength() {
        return this.timer.elapsedPartialTicks;
    }

    public BlockColors getBlockColors() {
        return this.blockColors;
    }

    /**
     * Whether to use reduced debug info
     */
    public boolean isReducedDebug() {
        return this.player != null && this.player.hasReducedDebug() || this.gameSettings.reducedDebugInfo;
    }

    public ToastGui getToastGui() {
        return this.toastGui;
    }

    public Tutorial getTutorial() {
        return this.tutorial;
    }

    public boolean isGameFocused() {
        return this.isWindowFocused;
    }

    public CreativeSettings getCreativeSettings() {
        return this.creativeSettings;
    }

    public ModelManager getModelManager() {
        return this.modelManager;
    }

    /**
     * Gets the sprite uploader used for paintings.
     */
    public PaintingSpriteUploader getPaintingSpriteUploader() {
        return this.paintingSprites;
    }

    /**
     * Gets the sprite uploader used for potions.
     */
    public PotionSpriteUploader getPotionSpriteUploader() {
        return this.potionSprites;
    }

    public void setGameFocused(boolean focused) {
        this.isWindowFocused = focused;
    }

    public IProfiler getProfiler() {
        return this.profiler;
    }

    public MinecraftGame getMinecraftGame() {
        return this.game;
    }

    public Splashes getSplashes() {
        return this.splashes;
    }

    @Nullable
    public LoadingGui getLoadingGui() {
        return this.loadingGui;
    }

    public FilterManager func_244599_aA() {
        return this.field_244597_aC;
    }

    public boolean isRenderOnThread() {
        return false;
    }

    public MainWindow getMainWindow() {
        return this.mainWindow;
    }

    public RenderTypeBuffers getRenderTypeBuffers() {
        return this.renderTypeBuffers;
    }

    private static ResourcePackInfo makePackInfo(String name, boolean isAlwaysEnabled, Supplier<IResourcePack> resourceSupplier, IResourcePack resourcePack, PackMetadataSection resourcePackMeta, ResourcePackInfo.Priority priority, IPackNameDecorator decorator) {
        int i = resourcePackMeta.getPackFormat();
        Supplier<IResourcePack> supplier = resourceSupplier;

        if (i <= 3) {
            supplier = wrapV3(resourceSupplier);
        }

        if (i <= 4) {
            supplier = wrapV4(supplier);
        }

        return new ResourcePackInfo(name, isAlwaysEnabled, supplier, resourcePack, resourcePackMeta, priority, decorator);
    }

    private static Supplier<IResourcePack> wrapV3(Supplier<IResourcePack> resourcePackSupplier) {
        return () ->
        {
            return new LegacyResourcePackWrapper(resourcePackSupplier.get(), LegacyResourcePackWrapper.NEW_TO_LEGACY_MAP);
        };
    }

    private static Supplier<IResourcePack> wrapV4(Supplier<IResourcePack> resourcePackSupplier) {
        return () ->
        {
            return new LegacyResourcePackWrapperV4(resourcePackSupplier.get());
        };
    }

    public void setMipmapLevels(int mipMapLevel) {
        this.modelManager.setMaxMipmapLevel(mipMapLevel);
    }

    public static final class PackManager implements AutoCloseable {
        private final ResourcePackList resourcePackList;
        private final DataPackRegistries datapackRegistries;
        private final IServerConfiguration serverConfiguration;

        private PackManager(ResourcePackList resourcePackList, DataPackRegistries datapackRegistries, IServerConfiguration serverConfiguration) {
            this.resourcePackList = resourcePackList;
            this.datapackRegistries = datapackRegistries;
            this.serverConfiguration = serverConfiguration;
        }

        public ResourcePackList getResourcePacks() {
            return this.resourcePackList;
        }

        public DataPackRegistries getDataPackRegistries() {
            return this.datapackRegistries;
        }

        public IServerConfiguration getServerConfiguration() {
            return this.serverConfiguration;
        }

        public void close() {
            this.resourcePackList.close();
            this.datapackRegistries.close();
        }
    }

    static enum WorldSelectionType {
        NONE,
        CREATE,
        BACKUP;
    }
}

PlayerEntity
package net.minecraft.entity.player;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.mojang.authlib.GameProfile;
import com.mojang.datafixers.util.Either;

import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.UUID;
import java.util.function.Predicate;
import javax.annotation.Nullable;

import net.minecraft.advancements.CriteriaTriggers;
import net.minecraft.block.BedBlock;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.RespawnAnchorBlock;
import net.minecraft.client.entity.player.ClientPlayerEntity;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.CreatureAttribute;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntitySize;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.MobEntity;
import net.minecraft.entity.MoverType;
import net.minecraft.entity.Pose;
import net.minecraft.entity.ai.attributes.AttributeModifierMap;
import net.minecraft.entity.ai.attributes.Attributes;
import net.minecraft.entity.boss.dragon.EnderDragonPartEntity;
import net.minecraft.entity.item.ArmorStandEntity;
import net.minecraft.entity.item.BoatEntity;
import net.minecraft.entity.item.ItemEntity;
import net.minecraft.entity.item.minecart.AbstractMinecartEntity;
import net.minecraft.entity.passive.ParrotEntity;
import net.minecraft.entity.passive.PigEntity;
import net.minecraft.entity.passive.StriderEntity;
import net.minecraft.entity.passive.TameableEntity;
import net.minecraft.entity.passive.horse.AbstractHorseEntity;
import net.minecraft.entity.projectile.FishingBobberEntity;
import net.minecraft.inventory.EnderChestInventory;
import net.minecraft.inventory.EquipmentSlotType;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.container.Container;
import net.minecraft.inventory.container.INamedContainerProvider;
import net.minecraft.inventory.container.PlayerContainer;
import net.minecraft.item.ArmorItem;
import net.minecraft.item.AxeItem;
import net.minecraft.item.ElytraItem;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.item.MerchantOffers;
import net.minecraft.item.ShootableItem;
import net.minecraft.item.SwordItem;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.network.datasync.DataParameter;
import net.minecraft.network.datasync.DataSerializers;
import net.minecraft.network.datasync.EntityDataManager;
import net.minecraft.network.play.server.SEntityVelocityPacket;
import net.minecraft.particles.IParticleData;
import net.minecraft.particles.ParticleTypes;
import net.minecraft.potion.EffectInstance;
import net.minecraft.potion.EffectUtils;
import net.minecraft.potion.Effects;
import net.minecraft.scoreboard.ScorePlayerTeam;
import net.minecraft.scoreboard.Scoreboard;
import net.minecraft.scoreboard.Team;
import net.minecraft.stats.Stat;
import net.minecraft.stats.Stats;
import net.minecraft.tags.FluidTags;
import net.minecraft.tileentity.CommandBlockLogic;
import net.minecraft.tileentity.CommandBlockTileEntity;
import net.minecraft.tileentity.JigsawTileEntity;
import net.minecraft.tileentity.SignTileEntity;
import net.minecraft.tileentity.StructureBlockTileEntity;
import net.minecraft.util.ActionResultType;
import net.minecraft.util.CachedBlockInfo;
import net.minecraft.util.CooldownTracker;
import net.minecraft.util.DamageSource;
import net.minecraft.util.Direction;
import net.minecraft.util.FoodStats;
import net.minecraft.util.Hand;
import net.minecraft.util.HandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.SharedConstants;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.SoundEvents;
import net.minecraft.util.Unit;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.util.text.IFormattableTextComponent;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.StringTextComponent;
import net.minecraft.util.text.TranslationTextComponent;
import net.minecraft.util.text.event.ClickEvent;
import net.minecraft.world.Difficulty;
import net.minecraft.world.GameRules;
import net.minecraft.world.GameType;
import net.minecraft.world.World;
import net.minecraft.world.server.ServerWorld;
import arctic.tech.events.EventManager;
import arctic.tech.events.impl.player.EventLivingUpdate;
import arctic.tech.managment.Managment;
import arctic.tech.modules.impl.movement.SprintFunction;

public abstract class PlayerEntity extends LivingEntity {
    public static final EntitySize STANDING_SIZE = EntitySize.flexible(0.6F, 1.8F);
    private static final Map<Pose, EntitySize> SIZE_BY_POSE = ImmutableMap.<Pose, EntitySize>builder().put(Pose.STANDING, STANDING_SIZE).put(Pose.SLEEPING, SLEEPING_SIZE).put(Pose.FALL_FLYING, EntitySize.flexible(0.6F, 0.6F)).put(Pose.SWIMMING, EntitySize.flexible(0.6F, 0.6F)).put(Pose.SPIN_ATTACK, EntitySize.flexible(0.6F, 0.6F)).put(Pose.CROUCHING, EntitySize.flexible(0.6F, 1.5F)).put(Pose.DYING, EntitySize.fixed(0.2F, 0.2F)).build();
    private static final DataParameter<Float> ABSORPTION = EntityDataManager.createKey(PlayerEntity.class, DataSerializers.FLOAT);
    private static final DataParameter<Integer> PLAYER_SCORE = EntityDataManager.createKey(PlayerEntity.class, DataSerializers.VARINT);
    protected static final DataParameter<Byte> PLAYER_MODEL_FLAG = EntityDataManager.createKey(PlayerEntity.class, DataSerializers.BYTE);
    protected static final DataParameter<Byte> MAIN_HAND = EntityDataManager.createKey(PlayerEntity.class, DataSerializers.BYTE);
    protected static final DataParameter<CompoundNBT> LEFT_SHOULDER_ENTITY = EntityDataManager.createKey(PlayerEntity.class, DataSerializers.COMPOUND_NBT);
    protected static final DataParameter<CompoundNBT> RIGHT_SHOULDER_ENTITY = EntityDataManager.createKey(PlayerEntity.class, DataSerializers.COMPOUND_NBT);
    public boolean isBot;
    private long timeEntitySatOnShoulder;
    public final PlayerInventory inventory = new PlayerInventory(this);
    protected EnderChestInventory enterChestInventory = new EnderChestInventory();
    public final PlayerContainer container;

    public float animationPerc;
    public Container openContainer;
    protected FoodStats foodStats = new FoodStats();
    protected int flyToggleTimer;
    public float prevCameraYaw;
    public float cameraYaw;
    public int xpCooldown;
    public double prevChasingPosX;
    public double prevChasingPosY;
    public double prevChasingPosZ;
    public double chasingPosX;
    public double chasingPosY;
    public double chasingPosZ;
    private int sleepTimer;
    protected boolean eyesInWaterPlayer;
    public final PlayerAbilities abilities = new PlayerAbilities();
    public int experienceLevel;
    public int experienceTotal;
    public float experience;
    protected int xpSeed;
    protected final float speedInAir = 0.02F;
    private int lastXPSound;

    public double realX, realY,realZ;
    public double realXI, realYI,realZI;

    /**
     * The player's unique game profile
     */
    private final GameProfile gameProfile;
    private boolean hasReducedDebug;
    private ItemStack itemStackMainHand = ItemStack.EMPTY;
    private final CooldownTracker cooldownTracker = this.createCooldownTracker();
    @Nullable
    public FishingBobberEntity fishingBobber;

    public PlayerEntity(World p_i241920_1_, BlockPos p_i241920_2_, float p_i241920_3_, GameProfile p_i241920_4_) {
        super(EntityType.PLAYER, p_i241920_1_);
        this.setUniqueId(getUUID(p_i241920_4_));
        this.gameProfile = p_i241920_4_;
        this.container = new PlayerContainer(this.inventory, !p_i241920_1_.isRemote, this);
        this.openContainer = this.container;
        this.setLocationAndAngles((double) p_i241920_2_.getX() + 0.5D, (double) (p_i241920_2_.getY() + 1), (double) p_i241920_2_.getZ() + 0.5D, p_i241920_3_, 0.0F);
        this.unused180 = 180.0F;
    }

    public boolean blockActionRestricted(World worldIn, BlockPos pos, GameType gameMode) {
        if (!gameMode.hasLimitedInteractions()) {
            return false;
        } else if (gameMode == GameType.SPECTATOR) {
            return true;
        } else if (this.isAllowEdit()) {
            return false;
        } else {
            ItemStack itemstack = this.getHeldItemMainhand();
            return itemstack.isEmpty() || !itemstack.canDestroy(worldIn.getTags(), new CachedBlockInfo(worldIn, pos, false));
        }
    }

    public static AttributeModifierMap.MutableAttribute func_234570_el_() {
        return LivingEntity.registerAttributes().createMutableAttribute(Attributes.ATTACK_DAMAGE, 1.0D).createMutableAttribute(Attributes.MOVEMENT_SPEED, (double) 0.1F).createMutableAttribute(Attributes.ATTACK_SPEED).createMutableAttribute(Attributes.LUCK);
    }

    protected void registerData() {
        super.registerData();
        this.dataManager.register(ABSORPTION, 0.0F);
        this.dataManager.register(PLAYER_SCORE, 0);
        this.dataManager.register(PLAYER_MODEL_FLAG, (byte) 0);
        this.dataManager.register(MAIN_HAND, (byte) 1);
        this.dataManager.register(LEFT_SHOULDER_ENTITY, new CompoundNBT());
        this.dataManager.register(RIGHT_SHOULDER_ENTITY, new CompoundNBT());
    }

    /**
     * Called to update the entity's position/logic.
     */
    public void tick() {
        this.noClip = this.isSpectator();

        EventLivingUpdate event = new EventLivingUpdate();
        EventManager.call(event);

        if (event.isCancel()) {
            return;
        }

        if (this.isSpectator()) {
            this.onGround = false;
        }

        if (this.xpCooldown > 0) {
            --this.xpCooldown;
        }

        if (this.isSleeping()) {
            ++this.sleepTimer;

            if (this.sleepTimer > 100) {
                this.sleepTimer = 100;
            }

            if (!this.world.isRemote && this.world.isDaytime()) {
                this.stopSleepInBed(false, true);
            }
        } else if (this.sleepTimer > 0) {
            ++this.sleepTimer;

            if (this.sleepTimer >= 110) {
                this.sleepTimer = 0;
            }
        }

        this.updateEyesInWaterPlayer();
        super.tick();

        if (!this.world.isRemote && this.openContainer != null && !this.openContainer.canInteractWith(this)) {
            this.closeScreen();
            this.openContainer = this.container;
        }

        this.updateCape();

        if (!this.world.isRemote) {
            this.foodStats.tick(this);
            this.addStat(Stats.PLAY_ONE_MINUTE);

            if (this.isAlive()) {
                this.addStat(Stats.TIME_SINCE_DEATH);
            }

            if (this.isDiscrete()) {
                this.addStat(Stats.SNEAK_TIME);
            }

            if (!this.isSleeping()) {
                this.addStat(Stats.TIME_SINCE_REST);
            }
        }

        int i = 29999999;
        double d0 = MathHelper.clamp(this.getPosX(), -2.9999999E7D, 2.9999999E7D);
        double d1 = MathHelper.clamp(this.getPosZ(), -2.9999999E7D, 2.9999999E7D);

        if (d0 != this.getPosX() || d1 != this.getPosZ()) {
            this.setPosition(d0, this.getPosY(), d1);
        }

        ++this.ticksSinceLastSwing;
        ItemStack itemstack = this.getHeldItemMainhand();

        if (!ItemStack.areItemStacksEqual(this.itemStackMainHand, itemstack)) {
            if (!ItemStack.areItemsEqualIgnoreDurability(this.itemStackMainHand, itemstack)) {
                this.resetCooldown();
            }

            this.itemStackMainHand = itemstack.copy();
        }

        this.updateTurtleHelmet();
        this.cooldownTracker.tick();
        this.updatePose();
    }

    public boolean isSecondaryUseActive() {
        return this.isSneaking();
    }

    protected boolean wantsToStopRiding() {
        return this.isSneaking();
    }

    protected boolean isStayingOnGroundSurface() {
        return this.isSneaking();
    }

    protected boolean updateEyesInWaterPlayer() {
        this.eyesInWaterPlayer = this.areEyesInFluid(FluidTags.WATER);
        return this.eyesInWaterPlayer;
    }

    private void updateTurtleHelmet() {
        ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.HEAD);

        if (itemstack.getItem() == Items.TURTLE_HELMET && !this.areEyesInFluid(FluidTags.WATER)) {
            this.addPotionEffect(new EffectInstance(Effects.WATER_BREATHING, 200, 0, false, false, true));
        }
    }

    protected CooldownTracker createCooldownTracker() {
        return new CooldownTracker();
    }

    private void updateCape() {
        this.prevChasingPosX = this.chasingPosX;
        this.prevChasingPosY = this.chasingPosY;
        this.prevChasingPosZ = this.chasingPosZ;
        double d0 = this.getPosX() - this.chasingPosX;
        double d1 = this.getPosY() - this.chasingPosY;
        double d2 = this.getPosZ() - this.chasingPosZ;
        double d3 = 10.0D;

        if (d0 > 10.0D) {
            this.chasingPosX = this.getPosX();
            this.prevChasingPosX = this.chasingPosX;
        }

        if (d2 > 10.0D) {
            this.chasingPosZ = this.getPosZ();
            this.prevChasingPosZ = this.chasingPosZ;
        }

        if (d1 > 10.0D) {
            this.chasingPosY = this.getPosY();
            this.prevChasingPosY = this.chasingPosY;
        }

        if (d0 < -10.0D) {
            this.chasingPosX = this.getPosX();
            this.prevChasingPosX = this.chasingPosX;
        }

        if (d2 < -10.0D) {
            this.chasingPosZ = this.getPosZ();
            this.prevChasingPosZ = this.chasingPosZ;
        }

        if (d1 < -10.0D) {
            this.chasingPosY = this.getPosY();
            this.prevChasingPosY = this.chasingPosY;
        }

        this.chasingPosX += d0 * 0.25D;
        this.chasingPosZ += d2 * 0.25D;
        this.chasingPosY += d1 * 0.25D;
    }

    protected void updatePose() {
        if (this.isPoseClear(Pose.SWIMMING)) {
            Pose pose;

            if (this.isElytraFlying()) {
                pose = Pose.FALL_FLYING;
            } else if (this.isSleeping()) {
                pose = Pose.SLEEPING;
            } else if (this.isSwimming()) {
                pose = Pose.SWIMMING;
            } else if (this.isSpinAttacking()) {
                pose = Pose.SPIN_ATTACK;
            } else if (this.isSneaking() && !this.abilities.isFlying) {
                pose = Pose.CROUCHING;
            } else {
                pose = Pose.STANDING;
            }

            Pose pose1;

            if (!this.isSpectator() && !this.isPassenger() && !this.isPoseClear(pose)) {
                if (this.isPoseClear(Pose.CROUCHING)) {
                    pose1 = Pose.CROUCHING;
                } else {
                    pose1 = Pose.SWIMMING;
                }
            } else {
                pose1 = pose;
            }

            this.setPose(pose1);
        }
    }

    /**
     * Return the amount of time this entity should stay in a portal before being transported.
     */
    public int getMaxInPortalTime() {
        return this.abilities.disableDamage ? 1 : 80;
    }

    protected SoundEvent getSwimSound() {
        return SoundEvents.ENTITY_PLAYER_SWIM;
    }

    protected SoundEvent getSplashSound() {
        return SoundEvents.ENTITY_PLAYER_SPLASH;
    }

    protected SoundEvent getHighspeedSplashSound() {
        return SoundEvents.ENTITY_PLAYER_SPLASH_HIGH_SPEED;
    }

    /**
     * Return the amount of cooldown before this entity can use a portal again.
     */
    public int getPortalCooldown() {
        return 10;
    }

    public void playSound(SoundEvent soundIn, float volume, float pitch) {
        this.world.playSound(this, this.getPosX(), this.getPosY(), this.getPosZ(), soundIn, this.getSoundCategory(), volume, pitch);
    }

    public void playSound(SoundEvent p_213823_1_, SoundCategory p_213823_2_, float p_213823_3_, float p_213823_4_) {
    }

    public SoundCategory getSoundCategory() {
        return SoundCategory.PLAYERS;
    }

    protected int getFireImmuneTicks() {
        return 20;
    }

    /**
     * Handler for {@link World#setEntityState}
     */
    public void handleStatusUpdate(byte id) {
        if (id == 9) {
            this.onItemUseFinish();
        } else if (id == 23) {
            this.hasReducedDebug = false;
        } else if (id == 22) {
            this.hasReducedDebug = true;
        } else if (id == 43) {
            this.addParticlesAroundSelf(ParticleTypes.CLOUD);
        } else {
            super.handleStatusUpdate(id);
        }
    }

    private void addParticlesAroundSelf(IParticleData p_213824_1_) {
        for (int i = 0; i < 5; ++i) {
            double d0 = this.rand.nextGaussian() * 0.02D;
            double d1 = this.rand.nextGaussian() * 0.02D;
            double d2 = this.rand.nextGaussian() * 0.02D;
            this.world.addParticle(p_213824_1_, this.getPosXRandom(1.0D), this.getPosYRandom() + 1.0D, this.getPosZRandom(1.0D), d0, d1, d2);
        }
    }

    /**
     * set current crafting inventory back to the 2x2 square
     */
    protected void closeScreen() {
        this.openContainer = this.container;
    }

    /**
     * Handles updating while riding another entity
     */
    public void updateRidden() {
        if (this.wantsToStopRiding() && this.isPassenger()) {
            this.stopRiding();
            this.setSneaking(false);
        } else {
            double d0 = this.getPosX();
            double d1 = this.getPosY();
            double d2 = this.getPosZ();
            super.updateRidden();
            this.prevCameraYaw = this.cameraYaw;
            this.cameraYaw = 0.0F;
            this.addMountedMovementStat(this.getPosX() - d0, this.getPosY() - d1, this.getPosZ() - d2);
        }
    }

    /**
     * Keeps moving the entity up so it isn't colliding with blocks and other requirements for this entity to be spawned
     * (only actually used on players though its also on Entity)
     */
    public void preparePlayerToSpawn() {
        this.setPose(Pose.STANDING);
        super.preparePlayerToSpawn();
        this.setHealth(this.getMaxHealth());
        this.deathTime = 0;
    }

    protected void updateEntityActionState() {
        super.updateEntityActionState();
        this.updateArmSwingProgress();
        this.rotationYawHead = this.rotationYaw;
        this.rotationPitchHead = this.rotationPitch;
    }

    /**
     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
     * use this to react to sunlight and start to burn.
     */
    public void livingTick() {
        if (this.flyToggleTimer > 0) {
            --this.flyToggleTimer;
        }

        if (this.world.getDifficulty() == Difficulty.PEACEFUL && this.world.getGameRules().getBoolean(GameRules.NATURAL_REGENERATION)) {
            if (this.getHealth() < this.getMaxHealth() && this.ticksExisted % 20 == 0) {
                this.heal(1.0F);
            }

            if (this.foodStats.needFood() && this.ticksExisted % 10 == 0) {
                this.foodStats.setFoodLevel(this.foodStats.getFoodLevel() + 1);
            }
        }

        this.inventory.tick();
        this.prevCameraYaw = this.cameraYaw;
        super.livingTick();
        this.jumpMovementFactor = 0.02F;

        if (this.isSprinting()) {
            this.jumpMovementFactor = (float) ((double) this.jumpMovementFactor + 0.005999999865889549D);
        }

        this.setAIMoveSpeed((float) this.getAttributeValue(Attributes.MOVEMENT_SPEED));
        float f;

        if (this.onGround && !this.getShouldBeDead() && !this.isSwimming()) {
            f = Math.min(0.1F, MathHelper.sqrt(horizontalMag(this.getMotion())));
        } else {
            f = 0.0F;
        }

        this.cameraYaw += (f - this.cameraYaw) * 0.4F;

        if (this.getHealth() > 0.0F && !this.isSpectator()) {
            AxisAlignedBB axisalignedbb;

            if (this.isPassenger() && !this.getRidingEntity().removed) {
                axisalignedbb = this.getBoundingBox().union(this.getRidingEntity().getBoundingBox()).grow(1.0D, 0.0D, 1.0D);
            } else {
                axisalignedbb = this.getBoundingBox().grow(1.0D, 0.5D, 1.0D);
            }

            List<Entity> list = this.world.getEntitiesWithinAABBExcludingEntity(this, axisalignedbb);

            for (int i = 0; i < list.size(); ++i) {
                Entity entity = list.get(i);

                if (!entity.removed) {
                    this.collideWithPlayer(entity);
                }
            }
        }

        this.playShoulderEntityAmbientSound(this.getLeftShoulderEntity());
        this.playShoulderEntityAmbientSound(this.getRightShoulderEntity());

        if (!this.world.isRemote && (this.fallDistance > 0.5F || this.isInWater()) || this.abilities.isFlying || this.isSleeping()) {
            this.spawnShoulderEntities();
        }
    }

    private void playShoulderEntityAmbientSound(@Nullable CompoundNBT p_192028_1_) {
        if (p_192028_1_ != null && (!p_192028_1_.contains("Silent") || !p_192028_1_.getBoolean("Silent")) && this.world.rand.nextInt(200) == 0) {
            String s = p_192028_1_.getString("id");
            EntityType.byKey(s).filter((p_213830_0_) ->
            {
                return p_213830_0_ == EntityType.PARROT;
            }).ifPresent((p_213834_1_) ->
            {
                if (!ParrotEntity.playMimicSound(this.world, this)) {
                    this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), ParrotEntity.func_234212_a_(this.world, this.world.rand), this.getSoundCategory(), 1.0F, ParrotEntity.getPitch(this.world.rand));
                }
            });
        }
    }

    private void collideWithPlayer(Entity entityIn) {
        entityIn.onCollideWithPlayer(this);
    }

    public int getScore() {
        return this.dataManager.get(PLAYER_SCORE);
    }

    /**
     * Set player's score
     */
    public void setScore(int scoreIn) {
        this.dataManager.set(PLAYER_SCORE, scoreIn);
    }

    /**
     * Add to player's score
     */
    public void addScore(int scoreIn) {
        int i = this.getScore();
        this.dataManager.set(PLAYER_SCORE, i + scoreIn);
    }

    /**
     * Called when the mob's health reaches 0.
     */
    public void onDeath(DamageSource cause) {
        super.onDeath(cause);
        this.recenterBoundingBox();

        if (!this.isSpectator()) {
            this.spawnDrops(cause);
        }

        if (cause != null) {
            this.setMotion((double) (-MathHelper.cos((this.attackedAtYaw + this.rotationYaw) * ((float) Math.PI / 180F)) * 0.1F), (double) 0.1F, (double) (-MathHelper.sin((this.attackedAtYaw + this.rotationYaw) * ((float) Math.PI / 180F)) * 0.1F));
        } else {
            this.setMotion(0.0D, 0.1D, 0.0D);
        }

        this.addStat(Stats.DEATHS);
        this.takeStat(Stats.CUSTOM.get(Stats.TIME_SINCE_DEATH));
        this.takeStat(Stats.CUSTOM.get(Stats.TIME_SINCE_REST));
        this.extinguish();
        this.setFlag(0, false);
    }

    protected void dropInventory() {
        super.dropInventory();

        if (!this.world.getGameRules().getBoolean(GameRules.KEEP_INVENTORY)) {
            this.destroyVanishingCursedItems();
            this.inventory.dropAllItems();
        }
    }

    protected void destroyVanishingCursedItems() {
        for (int i = 0; i < this.inventory.getSizeInventory(); ++i) {
            ItemStack itemstack = this.inventory.getStackInSlot(i);

            if (!itemstack.isEmpty() && EnchantmentHelper.hasVanishingCurse(itemstack)) {
                this.inventory.removeStackFromSlot(i);
            }
        }
    }

    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
        if (damageSourceIn == DamageSource.ON_FIRE) {
            return SoundEvents.ENTITY_PLAYER_HURT_ON_FIRE;
        } else if (damageSourceIn == DamageSource.DROWN) {
            return SoundEvents.ENTITY_PLAYER_HURT_DROWN;
        } else {
            return damageSourceIn == DamageSource.SWEET_BERRY_BUSH ? SoundEvents.ENTITY_PLAYER_HURT_SWEET_BERRY_BUSH : SoundEvents.ENTITY_PLAYER_HURT;
        }
    }

    protected SoundEvent getDeathSound() {
        return SoundEvents.ENTITY_PLAYER_DEATH;
    }

    public boolean drop(boolean p_225609_1_) {
        return this.dropItem(this.inventory.decrStackSize(this.inventory.currentItem, p_225609_1_ && !this.inventory.getCurrentItem().isEmpty() ? this.inventory.getCurrentItem().getCount() : 1), false, true) != null;
    }

    @Nullable

    /**
     * Drops an item into the world.
     */
    public ItemEntity dropItem(ItemStack itemStackIn, boolean unused) {
        return this.dropItem(itemStackIn, false, unused);
    }

    @Nullable

    /**
     * Creates and drops the provided item. Depending on the dropAround, it will drop teh item around the player,
     * instead of dropping the item from where the player is pointing at. Likewise, if traceItem is true, the dropped
     * item entity will have the thrower set as the player.
     */
    public ItemEntity dropItem(ItemStack droppedItem, boolean dropAround, boolean traceItem) {
        if (droppedItem.isEmpty()) {
            return null;
        } else {
            if (this.world.isRemote) {
                this.swingArm(Hand.MAIN_HAND);
            }

            double d0 = this.getPosYEye() - (double) 0.3F;
            ItemEntity itementity = new ItemEntity(this.world, this.getPosX(), d0, this.getPosZ(), droppedItem);
            itementity.setPickupDelay(40);

            if (traceItem) {
                itementity.setThrowerId(this.getUniqueID());
            }

            if (dropAround) {
                float f = this.rand.nextFloat() * 0.5F;
                float f1 = this.rand.nextFloat() * ((float) Math.PI * 2F);
                itementity.setMotion((double) (-MathHelper.sin(f1) * f), (double) 0.2F, (double) (MathHelper.cos(f1) * f));
            } else {
                float f7 = 0.3F;
                float f8 = MathHelper.sin(this.rotationPitch * ((float) Math.PI / 180F));
                float f2 = MathHelper.cos(this.rotationPitch * ((float) Math.PI / 180F));
                float f3 = MathHelper.sin(this.rotationYaw * ((float) Math.PI / 180F));
                float f4 = MathHelper.cos(this.rotationYaw * ((float) Math.PI / 180F));
                float f5 = this.rand.nextFloat() * ((float) Math.PI * 2F);
                float f6 = 0.02F * this.rand.nextFloat();
                itementity.setMotion((double) (-f3 * f2 * 0.3F) + Math.cos((double) f5) * (double) f6, (double) (-f8 * 0.3F + 0.1F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.1F), (double) (f4 * f2 * 0.3F) + Math.sin((double) f5) * (double) f6);
            }

            return itementity;
        }
    }

    public float getDigSpeed(BlockState state) {
        float f = this.inventory.getDestroySpeed(state);

        if (f > 1.0F) {
            int i = EnchantmentHelper.getEfficiencyModifier(this);
            ItemStack itemstack = this.getHeldItemMainhand();

            if (i > 0 && !itemstack.isEmpty()) {
                f += (float) (i * i + 1);
            }
        }

        if (EffectUtils.hasMiningSpeedup(this)) {
            f *= 1.0F + (float) (EffectUtils.getMiningSpeedup(this) + 1) * 0.2F;
        }

        if (this.isPotionActive(Effects.MINING_FATIGUE)) {
            float f1;

            switch (this.getActivePotionEffect(Effects.MINING_FATIGUE).getAmplifier()) {
                case 0:
                    f1 = 0.3F;
                    break;

                case 1:
                    f1 = 0.09F;
                    break;

                case 2:
                    f1 = 0.0027F;
                    break;

                case 3:
                default:
                    f1 = 8.1E-4F;
            }

            f *= f1;
        }

        if (this.areEyesInFluid(FluidTags.WATER) && !EnchantmentHelper.hasAquaAffinity(this)) {
            f /= 5.0F;
        }

        if (!this.onGround) {
            f /= 5.0F;
        }

        return f;
    }

    public boolean func_234569_d_(BlockState p_234569_1_) {
        return !p_234569_1_.getRequiresTool() || this.inventory.getCurrentItem().canHarvestBlock(p_234569_1_);
    }

    /**
     * (abstract) Protected helper method to read subclass entity data from NBT.
     */
    public void readAdditional(CompoundNBT compound) {
        super.readAdditional(compound);
        this.setUniqueId(getUUID(this.gameProfile));
        ListNBT listnbt = compound.getList("Inventory", 10);
        this.inventory.read(listnbt);
        this.inventory.currentItem = compound.getInt("SelectedItemSlot");
        this.sleepTimer = compound.getShort("SleepTimer");
        this.experience = compound.getFloat("XpP");
        this.experienceLevel = compound.getInt("XpLevel");
        this.experienceTotal = compound.getInt("XpTotal");
        this.xpSeed = compound.getInt("XpSeed");

        if (this.xpSeed == 0) {
            this.xpSeed = this.rand.nextInt();
        }

        this.setScore(compound.getInt("Score"));
        this.foodStats.read(compound);
        this.abilities.read(compound);
        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue((double) this.abilities.getWalkSpeed());

        if (compound.contains("EnderItems", 9)) {
            this.enterChestInventory.read(compound.getList("EnderItems", 10));
        }

        if (compound.contains("ShoulderEntityLeft", 10)) {
            this.setLeftShoulderEntity(compound.getCompound("ShoulderEntityLeft"));
        }

        if (compound.contains("ShoulderEntityRight", 10)) {
            this.setRightShoulderEntity(compound.getCompound("ShoulderEntityRight"));
        }
    }

    public void writeAdditional(CompoundNBT compound) {
        super.writeAdditional(compound);
        compound.putInt("DataVersion", SharedConstants.getVersion().getWorldVersion());
        compound.put("Inventory", this.inventory.write(new ListNBT()));
        compound.putInt("SelectedItemSlot", this.inventory.currentItem);
        compound.putShort("SleepTimer", (short) this.sleepTimer);
        compound.putFloat("XpP", this.experience);
        compound.putInt("XpLevel", this.experienceLevel);
        compound.putInt("XpTotal", this.experienceTotal);
        compound.putInt("XpSeed", this.xpSeed);
        compound.putInt("Score", this.getScore());
        this.foodStats.write(compound);
        this.abilities.write(compound);
        compound.put("EnderItems", this.enterChestInventory.write());

        if (!this.getLeftShoulderEntity().isEmpty()) {
            compound.put("ShoulderEntityLeft", this.getLeftShoulderEntity());
        }

        if (!this.getRightShoulderEntity().isEmpty()) {
            compound.put("ShoulderEntityRight", this.getRightShoulderEntity());
        }
    }

    /**
     * Returns whether this Entity is invulnerable to the given DamageSource.
     */
    public boolean isInvulnerableTo(DamageSource source) {
        if (super.isInvulnerableTo(source)) {
            return true;
        } else if (source == DamageSource.DROWN) {
            return !this.world.getGameRules().getBoolean(GameRules.DROWNING_DAMAGE);
        } else if (source == DamageSource.FALL) {
            return !this.world.getGameRules().getBoolean(GameRules.FALL_DAMAGE);
        } else if (source.isFireDamage()) {
            return !this.world.getGameRules().getBoolean(GameRules.FIRE_DAMAGE);
        } else {
            return false;
        }
    }

    /**
     * Called when the entity is attacked.
     */
    public boolean attackEntityFrom(DamageSource source, float amount) {
        if (this.isInvulnerableTo(source)) {
            return false;
        } else if (this.abilities.disableDamage && !source.canHarmInCreative()) {
            return false;
        } else {
            this.idleTime = 0;

            if (this.getShouldBeDead()) {
                return false;
            } else {
                this.spawnShoulderEntities();

                if (source.isDifficultyScaled()) {
                    if (this.world.getDifficulty() == Difficulty.PEACEFUL) {
                        amount = 0.0F;
                    }

                    if (this.world.getDifficulty() == Difficulty.EASY) {
                        amount = Math.min(amount / 2.0F + 1.0F, amount);
                    }

                    if (this.world.getDifficulty() == Difficulty.HARD) {
                        amount = amount * 3.0F / 2.0F;
                    }
                }

                return amount == 0.0F ? false : super.attackEntityFrom(source, amount);
            }
        }
    }

    protected void blockUsingShield(LivingEntity entityIn) {
        super.blockUsingShield(entityIn);

        if (entityIn.getHeldItemMainhand().getItem() instanceof AxeItem) {
            this.disableShield(true);
        }
    }

    public boolean canAttackPlayer(PlayerEntity other) {
        Team team = this.getTeam();
        Team team1 = other.getTeam();

        if (team == null) {
            return true;
        } else {
            return !team.isSameTeam(team1) ? true : team.getAllowFriendlyFire();
        }
    }

    protected void damageArmor(DamageSource damageSource, float damage) {
        this.inventory.func_234563_a_(damageSource, damage);
    }

    protected void damageShield(float damage) {
        if (this.activeItemStack.getItem() == Items.SHIELD) {
            if (!this.world.isRemote) {
                this.addStat(Stats.ITEM_USED.get(this.activeItemStack.getItem()));
            }

            if (damage >= 3.0F) {
                int i = 1 + MathHelper.floor(damage);
                Hand hand = this.getActiveHand();
                this.activeItemStack.damageItem(i, this, (p_213833_1_) ->
                {
                    p_213833_1_.sendBreakAnimation(hand);
                });

                if (this.activeItemStack.isEmpty()) {
                    if (hand == Hand.MAIN_HAND) {
                        this.setItemStackToSlot(EquipmentSlotType.MAINHAND, ItemStack.EMPTY);
                    } else {
                        this.setItemStackToSlot(EquipmentSlotType.OFFHAND, ItemStack.EMPTY);
                    }

                    this.activeItemStack = ItemStack.EMPTY;
                    this.playSound(SoundEvents.ITEM_SHIELD_BREAK, 0.8F, 0.8F + this.world.rand.nextFloat() * 0.4F);
                }
            }
        }
    }

    /**
     * Deals damage to the entity. This will take the armor of the entity into consideration before damaging the health
     * bar.
     */
    protected void damageEntity(DamageSource damageSrc, float damageAmount) {
        if (!this.isInvulnerableTo(damageSrc)) {
            damageAmount = this.applyArmorCalculations(damageSrc, damageAmount);
            damageAmount = this.applyPotionDamageCalculations(damageSrc, damageAmount);
            float f2 = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
            this.setAbsorptionAmount(this.getAbsorptionAmount() - (damageAmount - f2));
            float f = damageAmount - f2;

            if (f > 0.0F && f < 3.4028235E37F) {
                this.addStat(Stats.DAMAGE_ABSORBED, Math.round(f * 10.0F));
            }

            if (f2 != 0.0F) {
                this.addExhaustion(damageSrc.getHungerDamage());
                float f1 = this.getHealth();
                this.setHealth(this.getHealth() - f2);
                this.getCombatTracker().trackDamage(damageSrc, f1, f2);

                if (f2 < 3.4028235E37F) {
                    this.addStat(Stats.DAMAGE_TAKEN, Math.round(f2 * 10.0F));
                }
            }
        }
    }

    protected boolean func_230296_cM_() {
        return !this.abilities.isFlying && super.func_230296_cM_();
    }

    public void openSignEditor(SignTileEntity signTile) {
    }

    public void openMinecartCommandBlock(CommandBlockLogic commandBlock) {
    }

    public void openCommandBlock(CommandBlockTileEntity commandBlock) {
    }

    public void openStructureBlock(StructureBlockTileEntity structure) {
    }

    public void openJigsaw(JigsawTileEntity p_213826_1_) {
    }

    public void openHorseInventory(AbstractHorseEntity horse, IInventory inventoryIn) {
    }

    public OptionalInt openContainer(@Nullable INamedContainerProvider p_213829_1_) {
        return OptionalInt.empty();
    }

    public void openMerchantContainer(int containerId, MerchantOffers offers, int level, int xp, boolean p_213818_5_, boolean p_213818_6_) {
    }

    public void openBook(ItemStack stack, Hand hand) {
    }

    public ActionResultType interactOn(Entity entityToInteractOn, Hand hand) {
        if (this.isSpectator()) {
            if (entityToInteractOn instanceof INamedContainerProvider) {
                this.openContainer((INamedContainerProvider) entityToInteractOn);
            }

            return ActionResultType.PASS;
        } else {
            ItemStack itemstack = this.getHeldItem(hand);
            ItemStack itemstack1 = itemstack.copy();
            ActionResultType actionresulttype = entityToInteractOn.processInitialInteract(this, hand);

            if (actionresulttype.isSuccessOrConsume()) {
                if (this.abilities.isCreativeMode && itemstack == this.getHeldItem(hand) && itemstack.getCount() < itemstack1.getCount()) {
                    itemstack.setCount(itemstack1.getCount());
                }

                return actionresulttype;
            } else {
                if (!itemstack.isEmpty() && entityToInteractOn instanceof LivingEntity) {
                    if (this.abilities.isCreativeMode) {
                        itemstack = itemstack1;
                    }

                    ActionResultType actionresulttype1 = itemstack.interactWithEntity(this, (LivingEntity) entityToInteractOn, hand);

                    if (actionresulttype1.isSuccessOrConsume()) {
                        if (itemstack.isEmpty() && !this.abilities.isCreativeMode) {
                            this.setHeldItem(hand, ItemStack.EMPTY);
                        }

                        return actionresulttype1;
                    }
                }

                return ActionResultType.PASS;
            }
        }
    }

    /**
     * Returns the Y Offset of this entity.
     */
    public double getYOffset() {
        return -0.35D;
    }

    public void dismount() {
        super.dismount();
        this.rideCooldown = 0;
    }

    /**
     * Dead and sleeping entities cannot move
     */
    protected boolean isMovementBlocked() {
        return super.isMovementBlocked() || this.isSleeping();
    }

    public boolean func_241208_cS_() {
        return !this.abilities.isFlying;
    }

    protected Vector3d maybeBackOffFromEdge(Vector3d vec, MoverType mover) {
        if (!this.abilities.isFlying && (mover == MoverType.SELF || mover == MoverType.PLAYER) && this.isStayingOnGroundSurface() && this.func_242375_q()) {
            double d0 = vec.x;
            double d1 = vec.z;
            double d2 = 0.05D;

            while (d0 != 0.0D && this.world.hasNoCollisions(this, this.getBoundingBox().offset(d0, (double) (-this.stepHeight), 0.0D))) {
                if (d0 < 0.05D && d0 >= -0.05D) {
                    d0 = 0.0D;
                } else if (d0 > 0.0D) {
                    d0 -= 0.05D;
                } else {
                    d0 += 0.05D;
                }
            }

            while (d1 != 0.0D && this.world.hasNoCollisions(this, this.getBoundingBox().offset(0.0D, (double) (-this.stepHeight), d1))) {
                if (d1 < 0.05D && d1 >= -0.05D) {
                    d1 = 0.0D;
                } else if (d1 > 0.0D) {
                    d1 -= 0.05D;
                } else {
                    d1 += 0.05D;
                }
            }

            while (d0 != 0.0D && d1 != 0.0D && this.world.hasNoCollisions(this, this.getBoundingBox().offset(d0, (double) (-this.stepHeight), d1))) {
                if (d0 < 0.05D && d0 >= -0.05D) {
                    d0 = 0.0D;
                } else if (d0 > 0.0D) {
                    d0 -= 0.05D;
                } else {
                    d0 += 0.05D;
                }

                if (d1 < 0.05D && d1 >= -0.05D) {
                    d1 = 0.0D;
                } else if (d1 > 0.0D) {
                    d1 -= 0.05D;
                } else {
                    d1 += 0.05D;
                }
            }

            vec = new Vector3d(d0, vec.y, d1);
        }

        return vec;
    }

    private boolean func_242375_q() {
        return this.onGround || this.fallDistance < this.stepHeight && !this.world.hasNoCollisions(this, this.getBoundingBox().offset(0.0D, (double) (this.fallDistance - this.stepHeight), 0.0D));
    }

    /**
     * Attacks for the player the targeted entity with the currently equipped item.  The equipped item has hitEntity
     * called on it. Args: targetEntity
     */
    public void attackTargetEntityWithCurrentItem(Entity targetEntity) {
        if (targetEntity.canBeAttackedWithItem()) {
            if (!targetEntity.hitByEntity(this)) {
                float f = (float) this.getAttributeValue(Attributes.ATTACK_DAMAGE);
                float f1;

                if (targetEntity instanceof LivingEntity) {
                    f1 = EnchantmentHelper.getModifierForCreature(this.getHeldItemMainhand(), ((LivingEntity) targetEntity).getCreatureAttribute());
                } else {
                    f1 = EnchantmentHelper.getModifierForCreature(this.getHeldItemMainhand(), CreatureAttribute.UNDEFINED);
                }

                float f2 = this.getCooledAttackStrength(0.5F);
                f = f * (0.2F + f2 * f2 * 0.8F);
                f1 = f1 * f2;
                this.resetCooldown();

                if (f > 0.0F || f1 > 0.0F) {
                    boolean flag = f2 > 0.9F;
                    boolean flag1 = false;
                    int i = 0;
                    i = i + EnchantmentHelper.getKnockbackModifier(this);

                    if (this.isSprinting() && flag) {
                        this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_ATTACK_KNOCKBACK, this.getSoundCategory(), 1.0F, 1.0F);
                        ++i;
                        flag1 = true;
                    }

                    boolean flag2 = flag && this.fallDistance > 0.0F && !this.onGround && !this.isOnLadder() && !this.isInWater() && !this.isPotionActive(Effects.BLINDNESS) && !this.isPassenger() && targetEntity instanceof LivingEntity;
                    flag2 = flag2 && !this.isSprinting();

                    if (flag2) {
                        f *= 1.5F;
                    }

                    f = f + f1;
                    boolean flag3 = false;
                    double d0 = (double) (this.distanceWalkedModified - this.prevDistanceWalkedModified);

                    if (flag && !flag2 && !flag1 && this.onGround && d0 < (double) this.getAIMoveSpeed()) {
                        ItemStack itemstack = this.getHeldItem(Hand.MAIN_HAND);

                        if (itemstack.getItem() instanceof SwordItem) {
                            flag3 = true;
                        }
                    }

                    float f4 = 0.0F;
                    boolean flag4 = false;
                    int j = EnchantmentHelper.getFireAspectModifier(this);

                    if (targetEntity instanceof LivingEntity) {
                        f4 = ((LivingEntity) targetEntity).getHealth();

                        if (j > 0 && !targetEntity.isBurning()) {
                            flag4 = true;
                            targetEntity.setFire(1);
                        }
                    }

                    Vector3d vector3d = targetEntity.getMotion();
                    boolean flag5 = targetEntity.attackEntityFrom(DamageSource.causePlayerDamage(this), f);

                    if (flag5) {
                        if (i > 0) {
                            if (targetEntity instanceof LivingEntity) {
                                ((LivingEntity) targetEntity).applyKnockback((float) i * 0.5F, (double) MathHelper.sin(this.rotationYaw * ((float) Math.PI / 180F)), (double) (-MathHelper.cos(this.rotationYaw * ((float) Math.PI / 180F))));
                            } else {
                                targetEntity.addVelocity((double) (-MathHelper.sin(this.rotationYaw * ((float) Math.PI / 180F)) * (float) i * 0.5F), 0.1D, (double) (MathHelper.cos(this.rotationYaw * ((float) Math.PI / 180F)) * (float) i * 0.5F));
                            }
                            SprintFunction sprintFunction = Managment.FUNCTION_MANAGER.sprintFunction;

                            if (sprintFunction.state && sprintFunction.keepSprint.get() && Managment.FUNCTION_MANAGER.auraFunction != null && this instanceof ClientPlayerEntity) {
                                this.setSprinting(true);
                            } else {
                                this.setMotion(this.getMotion().mul(0.6D, 1.0D, 0.6D));
                                this.setSprinting(false);
                            }
                        }

                        if (flag3) {
                            float f3 = 1.0F + EnchantmentHelper.getSweepingDamageRatio(this) * f;

                            for (LivingEntity livingentity : this.world.getEntitiesWithinAABB(LivingEntity.class, targetEntity.getBoundingBox().grow(1.0D, 0.25D, 1.0D))) {
                                if (livingentity != this && livingentity != targetEntity && !this.isOnSameTeam(livingentity) && (!(livingentity instanceof ArmorStandEntity) || !((ArmorStandEntity) livingentity).hasMarker()) && this.getDistanceSq(livingentity) < 9.0D) {
                                    livingentity.applyKnockback(0.4F, (double) MathHelper.sin(this.rotationYaw * ((float) Math.PI / 180F)), (double) (-MathHelper.cos(this.rotationYaw * ((float) Math.PI / 180F))));
                                    livingentity.attackEntityFrom(DamageSource.causePlayerDamage(this), f3);
                                }
                            }

                            this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_ATTACK_SWEEP, this.getSoundCategory(), 1.0F, 1.0F);
                            this.spawnSweepParticles();
                        }

                        if (targetEntity instanceof ServerPlayerEntity && targetEntity.velocityChanged) {
                            ((ServerPlayerEntity) targetEntity).connection.sendPacket(new SEntityVelocityPacket(targetEntity));
                            targetEntity.velocityChanged = false;
                            targetEntity.setMotion(vector3d);
                        }

                        if (flag2) {
                            this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_ATTACK_CRIT, this.getSoundCategory(), 1.0F, 1.0F);
                            this.onCriticalHit(targetEntity);
                        }

                        if (!flag2 && !flag3) {
                            if (flag) {
                                this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_ATTACK_STRONG, this.getSoundCategory(), 1.0F, 1.0F);
                            } else {
                                this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_ATTACK_WEAK, this.getSoundCategory(), 1.0F, 1.0F);
                            }
                        }

                        if (f1 > 0.0F) {
                            this.onEnchantmentCritical(targetEntity);
                        }

                        this.setLastAttackedEntity(targetEntity);

                        if (targetEntity instanceof LivingEntity) {
                            EnchantmentHelper.applyThornEnchantments((LivingEntity) targetEntity, this);
                        }

                        EnchantmentHelper.applyArthropodEnchantments(this, targetEntity);
                        ItemStack itemstack1 = this.getHeldItemMainhand();
                        Entity entity = targetEntity;

                        if (targetEntity instanceof EnderDragonPartEntity) {
                            entity = ((EnderDragonPartEntity) targetEntity).dragon;
                        }

                        if (!this.world.isRemote && !itemstack1.isEmpty() && entity instanceof LivingEntity) {
                            itemstack1.hitEntity((LivingEntity) entity, this);

                            if (itemstack1.isEmpty()) {
                                this.setHeldItem(Hand.MAIN_HAND, ItemStack.EMPTY);
                            }
                        }

                        if (targetEntity instanceof LivingEntity) {
                            float f5 = f4 - ((LivingEntity) targetEntity).getHealth();
                            this.addStat(Stats.DAMAGE_DEALT, Math.round(f5 * 10.0F));

                            if (j > 0) {
                                targetEntity.setFire(j * 4);
                            }

                            if (this.world instanceof ServerWorld && f5 > 2.0F) {
                                int k = (int) ((double) f5 * 0.5D);
                                ((ServerWorld) this.world).spawnParticle(ParticleTypes.DAMAGE_INDICATOR, targetEntity.getPosX(), targetEntity.getPosYHeight(0.5D), targetEntity.getPosZ(), k, 0.1D, 0.0D, 0.1D, 0.2D);
                            }
                        }

                        this.addExhaustion(0.1F);
                    } else {
                        this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_ATTACK_NODAMAGE, this.getSoundCategory(), 1.0F, 1.0F);

                        if (flag4) {
                            targetEntity.extinguish();
                        }
                    }
                }
            }
        }
    }

    protected void spinAttack(LivingEntity p_204804_1_) {
        this.attackTargetEntityWithCurrentItem(p_204804_1_);
    }

    public void disableShield(boolean p_190777_1_) {
        float f = 0.25F + (float) EnchantmentHelper.getEfficiencyModifier(this) * 0.05F;

        if (p_190777_1_) {
            f += 0.75F;
        }

        if (this.rand.nextFloat() < f) {
            this.getCooldownTracker().setCooldown(Items.SHIELD, 100);
            this.resetActiveHand();
            this.world.setEntityState(this, (byte) 30);
        }
    }

    /**
     * Called when the entity is dealt a critical hit.
     */
    public void onCriticalHit(Entity entityHit) {
    }

    public void onEnchantmentCritical(Entity entityHit) {
    }

    public void spawnSweepParticles() {
        double d0 = (double) (-MathHelper.sin(this.rotationYaw * ((float) Math.PI / 180F)));
        double d1 = (double) MathHelper.cos(this.rotationYaw * ((float) Math.PI / 180F));

        if (this.world instanceof ServerWorld) {
            ((ServerWorld) this.world).spawnParticle(ParticleTypes.SWEEP_ATTACK, this.getPosX() + d0, this.getPosYHeight(0.5D), this.getPosZ() + d1, 0, d0, 0.0D, d1, 0.0D);
        }
    }

    public void respawnPlayer() {
    }

    /**
     * Queues the entity for removal from the world on the next tick.
     */
    public void remove() {
        super.remove();
        this.container.onContainerClosed(this);

        if (this.openContainer != null) {
            this.openContainer.onContainerClosed(this);
        }
    }

    /**
     * returns true if this is an EntityPlayerSP, or the logged in player.
     */
    public boolean isUser() {
        return false;
    }

    /**
     * Returns the GameProfile for this player
     */
    public GameProfile getGameProfile() {
        return this.gameProfile;
    }

    public Either<SleepResult, Unit> trySleep(BlockPos at) {
        this.startSleeping(at);
        this.sleepTimer = 0;
        return Either.right(Unit.INSTANCE);
    }

    public void stopSleepInBed(boolean p_225652_1_, boolean p_225652_2_) {
        super.wakeUp();

        if (this.world instanceof ServerWorld && p_225652_2_) {
            ((ServerWorld) this.world).updateAllPlayersSleepingFlag();
        }

        this.sleepTimer = p_225652_1_ ? 0 : 100;
    }

    public void wakeUp() {
        this.stopSleepInBed(true, true);
    }

    public static Optional<Vector3d> func_242374_a(ServerWorld p_242374_0_, BlockPos p_242374_1_, float p_242374_2_, boolean p_242374_3_, boolean p_242374_4_) {
        BlockState blockstate = p_242374_0_.getBlockState(p_242374_1_);
        Block block = blockstate.getBlock();

        if (block instanceof RespawnAnchorBlock && blockstate.get(RespawnAnchorBlock.CHARGES) > 0 && RespawnAnchorBlock.doesRespawnAnchorWork(p_242374_0_)) {
            Optional<Vector3d> optional = RespawnAnchorBlock.findRespawnPoint(EntityType.PLAYER, p_242374_0_, p_242374_1_);

            if (!p_242374_4_ && optional.isPresent()) {
                p_242374_0_.setBlockState(p_242374_1_, blockstate.with(RespawnAnchorBlock.CHARGES, Integer.valueOf(blockstate.get(RespawnAnchorBlock.CHARGES) - 1)), 3);
            }

            return optional;
        } else if (block instanceof BedBlock && BedBlock.doesBedWork(p_242374_0_)) {
            return BedBlock.func_242652_a(EntityType.PLAYER, p_242374_0_, p_242374_1_, p_242374_2_);
        } else if (!p_242374_3_) {
            return Optional.empty();
        } else {
            boolean flag = block.canSpawnInBlock();
            boolean flag1 = p_242374_0_.getBlockState(p_242374_1_.up()).getBlock().canSpawnInBlock();
            return flag && flag1 ? Optional.of(new Vector3d((double) p_242374_1_.getX() + 0.5D, (double) p_242374_1_.getY() + 0.1D, (double) p_242374_1_.getZ() + 0.5D)) : Optional.empty();
        }
    }

    /**
     * Returns whether or not the player is asleep and the screen has fully faded.
     */
    public boolean isPlayerFullyAsleep() {
        return this.isSleeping() && this.sleepTimer >= 100;
    }

    public int getSleepTimer() {
        return this.sleepTimer;
    }

    public void sendStatusMessage(ITextComponent chatComponent, boolean actionBar) {
    }

    public void addStat(ResourceLocation stat) {
        this.addStat(Stats.CUSTOM.get(stat));
    }

    public void addStat(ResourceLocation p_195067_1_, int p_195067_2_) {
        this.addStat(Stats.CUSTOM.get(p_195067_1_), p_195067_2_);
    }

    /**
     * Add a stat once
     */
    public void addStat(Stat<?> stat) {
        this.addStat(stat, 1);
    }

    /**
     * Adds a value to a statistic field.
     */
    public void addStat(Stat<?> stat, int amount) {
    }

    public void takeStat(Stat<?> stat) {
    }

    public int unlockRecipes(Collection<IRecipe<?>> p_195065_1_) {
        return 0;
    }

    public void unlockRecipes(ResourceLocation[] p_193102_1_) {
    }

    public int resetRecipes(Collection<IRecipe<?>> p_195069_1_) {
        return 0;
    }

    /**
     * Causes this entity to do an upwards motion (jumping).
     */
    public void jump() {
        super.jump();
        this.addStat(Stats.JUMP);

        if (this.isSprinting()) {
            this.addExhaustion(0.2F);
        } else {
            this.addExhaustion(0.05F);
        }
    }

    public void travel(Vector3d travelVector) {
        double d0 = this.getPosX();
        double d1 = this.getPosY();
        double d2 = this.getPosZ();

        if (this.isSwimming() && !this.isPassenger()) {
            double d3 = this.getLookVec().y;
            double d4 = d3 < -0.2D ? 0.085D : 0.06D;

            if (d3 <= 0.0D || this.isJumping || !this.world.getBlockState(new BlockPos(this.getPosX(), this.getPosY() + 1.0D - 0.1D, this.getPosZ())).getFluidState().isEmpty()) {
                Vector3d vector3d1 = this.getMotion();
                this.setMotion(vector3d1.add(0.0D, (d3 - vector3d1.y) * d4, 0.0D));
            }
        }

        if (this.abilities.isFlying && !this.isPassenger()) {
            double d5 = this.getMotion().y;
            float f = this.jumpMovementFactor;
            this.jumpMovementFactor = this.abilities.getFlySpeed() * (float) (this.isSprinting() ? 2 : 1);
            super.travel(travelVector);
            Vector3d vector3d = this.getMotion();
            this.setMotion(vector3d.x, d5 * 0.6D, vector3d.z);
            this.jumpMovementFactor = f;
            this.fallDistance = 0.0F;
            this.setFlag(7, false);
        } else {
            super.travel(travelVector);
        }

        this.addMovementStat(this.getPosX() - d0, this.getPosY() - d1, this.getPosZ() - d2);
    }

    public void updateSwimming() {
        if (this.abilities.isFlying) {
            this.setSwimming(false);
        } else {
            super.updateSwimming();
        }
    }

    protected boolean isNormalCube(BlockPos pos) {
        return !this.world.getBlockState(pos).isSuffocating(this.world, pos);
    }

    /**
     * the movespeed used for the new AI system
     */
    public float getAIMoveSpeed() {
        return (float) this.getAttributeValue(Attributes.MOVEMENT_SPEED);
    }

    /**
     * Adds a value to a movement statistic field - like run, walk, swin or climb.
     */
    public void addMovementStat(double p_71000_1_, double p_71000_3_, double p_71000_5_) {
        if (!this.isPassenger()) {
            if (this.isSwimming()) {
                int i = Math.round(MathHelper.sqrt(p_71000_1_ * p_71000_1_ + p_71000_3_ * p_71000_3_ + p_71000_5_ * p_71000_5_) * 100.0F);

                if (i > 0) {
                    this.addStat(Stats.SWIM_ONE_CM, i);
                    this.addExhaustion(0.01F * (float) i * 0.01F);
                }
            } else if (this.areEyesInFluid(FluidTags.WATER)) {
                int j = Math.round(MathHelper.sqrt(p_71000_1_ * p_71000_1_ + p_71000_3_ * p_71000_3_ + p_71000_5_ * p_71000_5_) * 100.0F);

                if (j > 0) {
                    this.addStat(Stats.WALK_UNDER_WATER_ONE_CM, j);
                    this.addExhaustion(0.01F * (float) j * 0.01F);
                }
            } else if (this.isInWater()) {
                int k = Math.round(MathHelper.sqrt(p_71000_1_ * p_71000_1_ + p_71000_5_ * p_71000_5_) * 100.0F);

                if (k > 0) {
                    this.addStat(Stats.WALK_ON_WATER_ONE_CM, k);
                    this.addExhaustion(0.01F * (float) k * 0.01F);
                }
            } else if (this.isOnLadder()) {
                if (p_71000_3_ > 0.0D) {
                    this.addStat(Stats.CLIMB_ONE_CM, (int) Math.round(p_71000_3_ * 100.0D));
                }
            } else if (this.onGround) {
                int l = Math.round(MathHelper.sqrt(p_71000_1_ * p_71000_1_ + p_71000_5_ * p_71000_5_) * 100.0F);

                if (l > 0) {
                    if (this.isSprinting()) {
                        this.addStat(Stats.SPRINT_ONE_CM, l);
                        this.addExhaustion(0.1F * (float) l * 0.01F);
                    } else if (this.isCrouching()) {
                        this.addStat(Stats.CROUCH_ONE_CM, l);
                        this.addExhaustion(0.0F * (float) l * 0.01F);
                    } else {
                        this.addStat(Stats.WALK_ONE_CM, l);
                        this.addExhaustion(0.0F * (float) l * 0.01F);
                    }
                }
            } else if (this.isElytraFlying()) {
                int i1 = Math.round(MathHelper.sqrt(p_71000_1_ * p_71000_1_ + p_71000_3_ * p_71000_3_ + p_71000_5_ * p_71000_5_) * 100.0F);
                this.addStat(Stats.AVIATE_ONE_CM, i1);
            } else {
                int j1 = Math.round(MathHelper.sqrt(p_71000_1_ * p_71000_1_ + p_71000_5_ * p_71000_5_) * 100.0F);

                if (j1 > 25) {
                    this.addStat(Stats.FLY_ONE_CM, j1);
                }
            }
        }
    }

    /**
     * Adds a value to a mounted movement statistic field - by minecart, boat, or pig.
     */
    private void addMountedMovementStat(double p_71015_1_, double p_71015_3_, double p_71015_5_) {
        if (this.isPassenger()) {
            int i = Math.round(MathHelper.sqrt(p_71015_1_ * p_71015_1_ + p_71015_3_ * p_71015_3_ + p_71015_5_ * p_71015_5_) * 100.0F);

            if (i > 0) {
                Entity entity = this.getRidingEntity();

                if (entity instanceof AbstractMinecartEntity) {
                    this.addStat(Stats.MINECART_ONE_CM, i);
                } else if (entity instanceof BoatEntity) {
                    this.addStat(Stats.BOAT_ONE_CM, i);
                } else if (entity instanceof PigEntity) {
                    this.addStat(Stats.PIG_ONE_CM, i);
                } else if (entity instanceof AbstractHorseEntity) {
                    this.addStat(Stats.HORSE_ONE_CM, i);
                } else if (entity instanceof StriderEntity) {
                    this.addStat(Stats.field_232862_C_, i);
                }
            }
        }
    }

    public boolean onLivingFall(float distance, float damageMultiplier) {
        if (this.abilities.allowFlying) {
            return false;
        } else {
            if (distance >= 2.0F) {
                this.addStat(Stats.FALL_ONE_CM, (int) Math.round((double) distance * 100.0D));
            }

            return super.onLivingFall(distance, damageMultiplier);
        }
    }

    public boolean tryToStartFallFlying() {
        if (!this.onGround && !this.isElytraFlying() && !this.isInWater() && !this.isPotionActive(Effects.LEVITATION)) {
            ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.CHEST);

            if (itemstack.getItem() == Items.ELYTRA && ElytraItem.isUsable(itemstack)) {
                this.startFallFlying();
                return true;
            }
        }

        return false;
    }

    public void startFallFlying() {
        this.setFlag(7, true);
    }

    public void stopFallFlying() {
        this.setFlag(7, true);
        this.setFlag(7, false);
    }

    /**
     * Plays the {@link #getSplashSound() splash sound}, and the {@link ParticleType#WATER_BUBBLE} and {@link
     * ParticleType#WATER_SPLASH} particles.
     */
    protected void doWaterSplashEffect() {
        if (!this.isSpectator()) {
            super.doWaterSplashEffect();
        }
    }

    protected SoundEvent getFallSound(int heightIn) {
        return heightIn > 4 ? SoundEvents.ENTITY_PLAYER_BIG_FALL : SoundEvents.ENTITY_PLAYER_SMALL_FALL;
    }

    public void func_241847_a(ServerWorld p_241847_1_, LivingEntity p_241847_2_) {
        this.addStat(Stats.ENTITY_KILLED.get(p_241847_2_.getType()));
    }

    public void setMotionMultiplier(BlockState state, Vector3d motionMultiplierIn) {
        if (!this.abilities.isFlying) {
            super.setMotionMultiplier(state, motionMultiplierIn);
        }
    }

    public void giveExperiencePoints(int p_195068_1_) {
        this.addScore(p_195068_1_);
        this.experience += (float) p_195068_1_ / (float) this.xpBarCap();
        this.experienceTotal = MathHelper.clamp(this.experienceTotal + p_195068_1_, 0, Integer.MAX_VALUE);

        while (this.experience < 0.0F) {
            float f = this.experience * (float) this.xpBarCap();

            if (this.experienceLevel > 0) {
                this.addExperienceLevel(-1);
                this.experience = 1.0F + f / (float) this.xpBarCap();
            } else {
                this.addExperienceLevel(-1);
                this.experience = 0.0F;
            }
        }

        while (this.experience >= 1.0F) {
            this.experience = (this.experience - 1.0F) * (float) this.xpBarCap();
            this.addExperienceLevel(1);
            this.experience /= (float) this.xpBarCap();
        }
    }

    public int getXPSeed() {
        return this.xpSeed;
    }

    public void onEnchant(ItemStack enchantedItem, int cost) {
        this.experienceLevel -= cost;

        if (this.experienceLevel < 0) {
            this.experienceLevel = 0;
            this.experience = 0.0F;
            this.experienceTotal = 0;
        }

        this.xpSeed = this.rand.nextInt();
    }

    /**
     * Add experience levels to this player.
     */
    public void addExperienceLevel(int levels) {
        this.experienceLevel += levels;

        if (this.experienceLevel < 0) {
            this.experienceLevel = 0;
            this.experience = 0.0F;
            this.experienceTotal = 0;
        }

        if (levels > 0 && this.experienceLevel % 5 == 0 && (float) this.lastXPSound < (float) this.ticksExisted - 100.0F) {
            float f = this.experienceLevel > 30 ? 1.0F : (float) this.experienceLevel / 30.0F;
            this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_LEVELUP, this.getSoundCategory(), f * 0.75F, 1.0F);
            this.lastXPSound = this.ticksExisted;
        }
    }

    /**
     * This method returns the cap amount of experience that the experience bar can hold. With each level, the
     * experience cap on the player's experience bar is raised by 10.
     */
    public int xpBarCap() {
        if (this.experienceLevel >= 30) {
            return 112 + (this.experienceLevel - 30) * 9;
        } else {
            return this.experienceLevel >= 15 ? 37 + (this.experienceLevel - 15) * 5 : 7 + this.experienceLevel * 2;
        }
    }

    /**
     * increases exhaustion level by supplied amount
     */
    public void addExhaustion(float exhaustion) {
        if (!this.abilities.disableDamage) {
            if (!this.world.isRemote) {
                this.foodStats.addExhaustion(exhaustion);
            }
        }
    }

    /**
     * Returns the player's FoodStats object.
     */
    public FoodStats getFoodStats() {
        return this.foodStats;
    }

    public boolean canEat(boolean ignoreHunger) {
        return this.abilities.disableDamage || ignoreHunger || this.foodStats.needFood();
    }

    /**
     * Checks if the player's health is not full and not zero.
     */
    public boolean shouldHeal() {
        return this.getHealth() > 0.0F && this.getHealth() < this.getMaxHealth();
    }

    public boolean isAllowEdit() {
        return this.abilities.allowEdit;
    }

    /**
     * Returns whether this player can modify the block at a certain location with the given stack.
     * <p>
     * The position being queried is {@code pos.offset(facing.getOpposite()))}.
     *
     * @return Whether this player may modify the queried location in the current world
     * @see ItemStack#canPlaceOn(Block)
     * @see ItemStack#canEditBlocks()
     * @see PlayerCapabilities#allowEdit
     */
    public boolean canPlayerEdit(BlockPos pos, Direction facing, ItemStack stack) {
        if (this.abilities.allowEdit) {
            return true;
        } else {
            BlockPos blockpos = pos.offset(facing.getOpposite());
            CachedBlockInfo cachedblockinfo = new CachedBlockInfo(this.world, blockpos, false);
            return stack.canPlaceOn(this.world.getTags(), cachedblockinfo);
        }
    }

    /**
     * Get the experience points the entity currently has.
     */
    protected int getExperiencePoints(PlayerEntity player) {
        if (!this.world.getGameRules().getBoolean(GameRules.KEEP_INVENTORY) && !this.isSpectator()) {
            int i = this.experienceLevel * 7;
            return i > 100 ? 100 : i;
        } else {
            return 0;
        }
    }

    /**
     * Only use is to identify if class is an instance of player for experience dropping
     */
    protected boolean isPlayer() {
        return true;
    }

    public boolean getAlwaysRenderNameTagForRender() {
        return true;
    }

    protected boolean canTriggerWalking() {
        return !this.abilities.isFlying && (!this.onGround || !this.isDiscrete());
    }

    /**
     * Sends the player's abilities to the server (if there is one).
     */
    public void sendPlayerAbilities() {
    }

    /**
     * Sets the player's game mode and sends it to them.
     */
    public void setGameType(GameType gameType) {
    }

    public ITextComponent getName() {
        return new StringTextComponent(this.gameProfile.getName());
    }

    /**
     * Returns the InventoryEnderChest of this player.
     */
    public EnderChestInventory getInventoryEnderChest() {
        return this.enterChestInventory;
    }

    public ItemStack getItemStackFromSlot(EquipmentSlotType slotIn) {
        if (slotIn == EquipmentSlotType.MAINHAND) {
            return this.inventory.getCurrentItem();
        } else if (slotIn == EquipmentSlotType.OFFHAND) {
            return this.inventory.offHandInventory.get(0);
        } else {
            return slotIn.getSlotType() == EquipmentSlotType.Group.ARMOR ? this.inventory.armorInventory.get(slotIn.getIndex()) : ItemStack.EMPTY;
        }
    }

    public void setItemStackToSlot(EquipmentSlotType slotIn, ItemStack stack) {
        if (slotIn == EquipmentSlotType.MAINHAND) {
            this.playEquipSound(stack);
            this.inventory.mainInventory.set(this.inventory.currentItem, stack);
        } else if (slotIn == EquipmentSlotType.OFFHAND) {
            this.playEquipSound(stack);
            this.inventory.offHandInventory.set(0, stack);
        } else if (slotIn.getSlotType() == EquipmentSlotType.Group.ARMOR) {
            this.playEquipSound(stack);
            this.inventory.armorInventory.set(slotIn.getIndex(), stack);
        }
    }

    public boolean addItemStackToInventory(ItemStack p_191521_1_) {
        this.playEquipSound(p_191521_1_);
        return this.inventory.addItemStackToInventory(p_191521_1_);
    }

    public Iterable<ItemStack> getHeldEquipment() {
        return Lists.newArrayList(this.getHeldItemMainhand(), this.getHeldItemOffhand());
    }

    public Iterable<ItemStack> getArmorInventoryList() {
        return this.inventory.armorInventory;
    }

    public boolean addShoulderEntity(CompoundNBT p_192027_1_) {
        if (!this.isPassenger() && this.onGround && !this.isInWater()) {
            if (this.getLeftShoulderEntity().isEmpty()) {
                this.setLeftShoulderEntity(p_192027_1_);
                this.timeEntitySatOnShoulder = this.world.getGameTime();
                return true;
            } else if (this.getRightShoulderEntity().isEmpty()) {
                this.setRightShoulderEntity(p_192027_1_);
                this.timeEntitySatOnShoulder = this.world.getGameTime();
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    protected void spawnShoulderEntities() {
        if (this.timeEntitySatOnShoulder + 20L < this.world.getGameTime()) {
            this.spawnShoulderEntity(this.getLeftShoulderEntity());
            this.setLeftShoulderEntity(new CompoundNBT());
            this.spawnShoulderEntity(this.getRightShoulderEntity());
            this.setRightShoulderEntity(new CompoundNBT());
        }
    }

    private void spawnShoulderEntity(CompoundNBT p_192026_1_) {
        if (!this.world.isRemote && !p_192026_1_.isEmpty()) {
            EntityType.loadEntityUnchecked(p_192026_1_, this.world).ifPresent((p_226562_1_) ->
            {
                if (p_226562_1_ instanceof TameableEntity) {
                    ((TameableEntity) p_226562_1_).setOwnerId(this.entityUniqueID);
                }

                p_226562_1_.setPosition(this.getPosX(), this.getPosY() + (double) 0.7F, this.getPosZ());
                ((ServerWorld) this.world).summonEntity(p_226562_1_);
            });
        }
    }

    /**
     * Returns true if the player is in spectator mode.
     */
    public abstract boolean isSpectator();

    public boolean isSwimming() {
        return !this.abilities.isFlying && !this.isSpectator() && super.isSwimming();
    }

    public abstract boolean isCreative();

    public boolean isPushedByWater() {
        if (Managment.FUNCTION_MANAGER.noPushFunction.state && Managment.FUNCTION_MANAGER.noPushFunction.modes.get(2))
            return false;

        return !this.abilities.isFlying;
    }

    public Scoreboard getWorldScoreboard() {
        return this.world.getScoreboard();
    }

    public ITextComponent getDisplayName() {
        IFormattableTextComponent iformattabletextcomponent = ScorePlayerTeam.func_237500_a_(this.getTeam(), this.getName());
        return this.addTellEvent(iformattabletextcomponent);
    }

    private IFormattableTextComponent addTellEvent(IFormattableTextComponent p_208016_1_) {
        String s = this.getGameProfile().getName();
        return p_208016_1_.modifyStyle((p_234565_2_) ->
        {
            return p_234565_2_.setClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/tell " + s + " ")).setHoverEvent(this.getHoverEvent()).setInsertion(s);
        });
    }

    /**
     * Returns a String to use as this entity's name in the scoreboard/entity selector systems
     */
    public String getScoreboardName() {
        return this.getGameProfile().getName();
    }

    public float getStandingEyeHeight(Pose poseIn, EntitySize sizeIn) {
        switch (poseIn) {
            case SWIMMING:
            case FALL_FLYING:
            case SPIN_ATTACK:
                return 0.4F;

            case CROUCHING:
                return 1.27F;

            default:
                return 1.62F;
        }
    }

    public void setAbsorptionAmount(float amount) {
        if (amount < 0.0F) {
            amount = 0.0F;
        }

        this.getDataManager().set(ABSORPTION, amount);
    }

    /**
     * Returns the amount of health added by the Absorption effect.
     */
    public float getAbsorptionAmount() {
        return this.getDataManager().get(ABSORPTION);
    }

    /**
     * Gets a players UUID given their GameProfie
     */
    public static UUID getUUID(GameProfile profile) {
        UUID uuid = profile.getId();

        if (uuid == null) {
            uuid = getOfflineUUID(profile.getName());
        }

        return uuid;
    }

    public static UUID getOfflineUUID(String username) {
        return UUID.nameUUIDFromBytes(("OfflinePlayer:" + username).getBytes(StandardCharsets.UTF_8));
    }

    public boolean isWearing(PlayerModelPart part) {
        return (this.getDataManager().get(PLAYER_MODEL_FLAG) & part.getPartMask()) == part.getPartMask();
    }

    public boolean replaceItemInInventory(int inventorySlot, ItemStack itemStackIn) {
        if (inventorySlot >= 0 && inventorySlot < this.inventory.mainInventory.size()) {
            this.inventory.setInventorySlotContents(inventorySlot, itemStackIn);
            return true;
        } else {
            EquipmentSlotType equipmentslottype;

            if (inventorySlot == 100 + EquipmentSlotType.HEAD.getIndex()) {
                equipmentslottype = EquipmentSlotType.HEAD;
            } else if (inventorySlot == 100 + EquipmentSlotType.CHEST.getIndex()) {
                equipmentslottype = EquipmentSlotType.CHEST;
            } else if (inventorySlot == 100 + EquipmentSlotType.LEGS.getIndex()) {
                equipmentslottype = EquipmentSlotType.LEGS;
            } else if (inventorySlot == 100 + EquipmentSlotType.FEET.getIndex()) {
                equipmentslottype = EquipmentSlotType.FEET;
            } else {
                equipmentslottype = null;
            }

            if (inventorySlot == 98) {
                this.setItemStackToSlot(EquipmentSlotType.MAINHAND, itemStackIn);
                return true;
            } else if (inventorySlot == 99) {
                this.setItemStackToSlot(EquipmentSlotType.OFFHAND, itemStackIn);
                return true;
            } else if (equipmentslottype == null) {
                int i = inventorySlot - 200;

                if (i >= 0 && i < this.enterChestInventory.getSizeInventory()) {
                    this.enterChestInventory.setInventorySlotContents(i, itemStackIn);
                    return true;
                } else {
                    return false;
                }
            } else {
                if (!itemStackIn.isEmpty()) {
                    if (!(itemStackIn.getItem() instanceof ArmorItem) && !(itemStackIn.getItem() instanceof ElytraItem)) {
                        if (equipmentslottype != EquipmentSlotType.HEAD) {
                            return false;
                        }
                    } else if (MobEntity.getSlotForItemStack(itemStackIn) != equipmentslottype) {
                        return false;
                    }
                }

                this.inventory.setInventorySlotContents(equipmentslottype.getIndex() + this.inventory.mainInventory.size(), itemStackIn);
                return true;
            }
        }
    }

    /**
     * Whether the "reducedDebugInfo" option is active for this player.
     */
    public boolean hasReducedDebug() {
        return this.hasReducedDebug;
    }

    public void setReducedDebug(boolean reducedDebug) {
        this.hasReducedDebug = reducedDebug;
    }

    public void forceFireTicks(int ticks) {
        super.forceFireTicks(this.abilities.disableDamage ? Math.min(ticks, 1) : ticks);
    }

    public HandSide getPrimaryHand() {
        return this.dataManager.get(MAIN_HAND) == 0 ? HandSide.LEFT : HandSide.RIGHT;
    }

    public void setPrimaryHand(HandSide hand) {
        this.dataManager.set(MAIN_HAND, (byte) (hand == HandSide.LEFT ? 0 : 1));
    }

    public CompoundNBT getLeftShoulderEntity() {
        return this.dataManager.get(LEFT_SHOULDER_ENTITY);
    }

    protected void setLeftShoulderEntity(CompoundNBT tag) {
        this.dataManager.set(LEFT_SHOULDER_ENTITY, tag);
    }

    public CompoundNBT getRightShoulderEntity() {
        return this.dataManager.get(RIGHT_SHOULDER_ENTITY);
    }

    protected void setRightShoulderEntity(CompoundNBT tag) {
        this.dataManager.set(RIGHT_SHOULDER_ENTITY, tag);
    }

    public float getCooldownPeriod() {
        return (float) (1.0D / this.getAttributeValue(Attributes.ATTACK_SPEED) * 20.0D);
    }

    /**
     * Returns the percentage of attack power available based on the cooldown (zero to one).
     */
    public float getCooledAttackStrength(float adjustTicks) {
        return MathHelper.clamp(((float) this.ticksSinceLastSwing + adjustTicks) / this.getCooldownPeriod(), 0.0F, 1.0F);
    }

    public void resetCooldown() {
        this.ticksSinceLastSwing = 0;
    }

    public CooldownTracker getCooldownTracker() {
        return this.cooldownTracker;
    }

    protected float getSpeedFactor() {
        return !this.abilities.isFlying && !this.isElytraFlying() ? super.getSpeedFactor() : 1.0F;
    }

    public float getLuck() {
        return (float) this.getAttributeValue(Attributes.LUCK);
    }

    public boolean canUseCommandBlock() {
        return this.abilities.isCreativeMode && this.getPermissionLevel() >= 2;
    }

    public boolean canPickUpItem(ItemStack itemstackIn) {
        EquipmentSlotType equipmentslottype = MobEntity.getSlotForItemStack(itemstackIn);
        return this.getItemStackFromSlot(equipmentslottype).isEmpty();
    }

    public EntitySize getSize(Pose poseIn) {
        return SIZE_BY_POSE.getOrDefault(poseIn, STANDING_SIZE);
    }

    public ImmutableList<Pose> getAvailablePoses() {
        return ImmutableList.of(Pose.STANDING, Pose.CROUCHING, Pose.SWIMMING);
    }

    public ItemStack findAmmo(ItemStack shootable) {
        if (!(shootable.getItem() instanceof ShootableItem)) {
            return ItemStack.EMPTY;
        } else {
            Predicate<ItemStack> predicate = ((ShootableItem) shootable.getItem()).getAmmoPredicate();
            ItemStack itemstack = ShootableItem.getHeldAmmo(this, predicate);

            if (!itemstack.isEmpty()) {
                return itemstack;
            } else {
                predicate = ((ShootableItem) shootable.getItem()).getInventoryAmmoPredicate();

                for (int i = 0; i < this.inventory.getSizeInventory(); ++i) {
                    ItemStack itemstack1 = this.inventory.getStackInSlot(i);

                    if (predicate.test(itemstack1)) {
                        return itemstack1;
                    }
                }

                return this.abilities.isCreativeMode ? new ItemStack(Items.ARROW) : ItemStack.EMPTY;
            }
        }
    }

    public ItemStack onFoodEaten(World p_213357_1_, ItemStack p_213357_2_) {
        this.getFoodStats().consume(p_213357_2_.getItem(), p_213357_2_);
        this.addStat(Stats.ITEM_USED.get(p_213357_2_.getItem()));
        p_213357_1_.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_PLAYER_BURP, SoundCategory.PLAYERS, 0.5F, p_213357_1_.rand.nextFloat() * 0.1F + 0.9F);

        if (this instanceof ServerPlayerEntity) {
            CriteriaTriggers.CONSUME_ITEM.trigger((ServerPlayerEntity) this, p_213357_2_);
        }

        return super.onFoodEaten(p_213357_1_, p_213357_2_);
    }

    protected boolean func_230295_b_(BlockState p_230295_1_) {
        return this.abilities.isFlying || super.func_230295_b_(p_230295_1_);
    }

    public Vector3d getLeashPosition(float partialTicks) {
        double d0 = 0.22D * (this.getPrimaryHand() == HandSide.RIGHT ? -1.0D : 1.0D);
        float f = MathHelper.lerp(partialTicks * 0.5F, this.rotationPitch, this.prevRotationPitch) * ((float) Math.PI / 180F);
        float f1 = MathHelper.lerp(partialTicks, this.prevRenderYawOffset, this.renderYawOffset) * ((float) Math.PI / 180F);

        if (!this.isElytraFlying() && !this.isSpinAttacking()) {
            if (this.isActualySwimming()) {
                return this.func_242282_l(partialTicks).add((new Vector3d(d0, 0.2D, -0.15D)).rotatePitch(-f).rotateYaw(-f1));
            } else {
                double d5 = this.getBoundingBox().getYSize() - 1.0D;
                double d6 = this.isCrouching() ? -0.2D : 0.07D;
                return this.func_242282_l(partialTicks).add((new Vector3d(d0, d5, d6)).rotateYaw(-f1));
            }
        } else {
            Vector3d vector3d = this.getLook(partialTicks);
            Vector3d vector3d1 = this.getMotion();
            double d1 = Entity.horizontalMag(vector3d1);
            double d2 = Entity.horizontalMag(vector3d);
            float f2;

            if (d1 > 0.0D && d2 > 0.0D) {
                double d3 = (vector3d1.x * vector3d.x + vector3d1.z * vector3d.z) / Math.sqrt(d1 * d2);
                double d4 = vector3d1.x * vector3d.z - vector3d1.z * vector3d.x;
                f2 = (float) (Math.signum(d4) * Math.acos(d3));
            } else {
                f2 = 0.0F;
            }

            return this.func_242282_l(partialTicks).add((new Vector3d(d0, -0.11D, 0.85D)).rotateRoll(-f2).rotatePitch(-f).rotateYaw(-f1));
        }
    }

    public static enum SleepResult {
        NOT_POSSIBLE_HERE,
        NOT_POSSIBLE_NOW(new TranslationTextComponent("block.minecraft.bed.no_sleep")),
        TOO_FAR_AWAY(new TranslationTextComponent("block.minecraft.bed.too_far_away")),
        OBSTRUCTED(new TranslationTextComponent("block.minecraft.bed.obstructed")),
        OTHER_PROBLEM,
        NOT_SAFE(new TranslationTextComponent("block.minecraft.bed.not_safe"));

        @Nullable
        private final ITextComponent message;

        private SleepResult() {
            this.message = null;
        }

        private SleepResult(ITextComponent msg) {
            this.message = msg;
        }

        @Nullable
        public ITextComponent getMessage() {
            return this.message;
        }
    }
}

PlayerInventory:
package net.minecraft.entity.player;

import com.google.common.collect.ImmutableList;

import java.util.List;
import java.util.function.Predicate;

import net.minecraft.block.BlockState;
import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.crash.ReportedException;
import net.minecraft.inventory.EquipmentSlotType;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.ItemStackHelper;
import net.minecraft.item.ArmorItem;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.RecipeItemHelper;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.network.play.server.SSetSlotPacket;
import net.minecraft.tags.ITag;
import net.minecraft.util.DamageSource;
import net.minecraft.util.INameable;
import net.minecraft.util.NonNullList;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TranslationTextComponent;
import net.minecraft.world.World;

public class PlayerInventory implements IInventory, INameable {
    public final NonNullList<ItemStack> mainInventory = NonNullList.withSize(36, ItemStack.EMPTY);
    public final NonNullList<ItemStack> armorInventory = NonNullList.withSize(4, ItemStack.EMPTY);
    public final NonNullList<ItemStack> offHandInventory = NonNullList.withSize(1, ItemStack.EMPTY);
    private final List<NonNullList<ItemStack>> allInventories = ImmutableList.of(this.mainInventory, this.armorInventory, this.offHandInventory);
    public int currentItem;
    public final PlayerEntity player;
    private ItemStack itemStack = ItemStack.EMPTY;
    private int timesChanged;

    public PlayerInventory(PlayerEntity playerIn) {
        this.player = playerIn;
    }

    /**
     * Returns the item stack currently held by the player.
     */
    public ItemStack getCurrentItem() {
        return isHotbar(this.currentItem) ? this.mainInventory.get(this.currentItem) : ItemStack.EMPTY;
    }

    /**
     * Get the size of the player hotbar inventory
     */
    public static int getHotbarSize() {
        return 9;
    }

    private boolean canMergeStacks(ItemStack stack1, ItemStack stack2) {
        return !stack1.isEmpty() && this.stackEqualExact(stack1, stack2) && stack1.isStackable() && stack1.getCount() < stack1.getMaxStackSize() && stack1.getCount() < this.getInventoryStackLimit();
    }

    /**
     * Checks item, NBT, and meta if the item is not damageable
     */
    private boolean stackEqualExact(ItemStack stack1, ItemStack stack2) {
        return stack1.getItem() == stack2.getItem() && ItemStack.areItemStackTagsEqual(stack1, stack2);
    }

    /**
     * Returns the first item stack that is empty.
     */
    public int getFirstEmptyStack() {
        for (int i = 0; i < this.mainInventory.size(); ++i) {
            if (this.mainInventory.get(i).isEmpty()) {
                return i;
            }
        }

        return -1;
    }

    public void setPickedItemStack(ItemStack stack) {
        int i = this.getSlotFor(stack);

        if (isHotbar(i)) {
            this.currentItem = i;
        } else {
            if (i == -1) {
                this.currentItem = this.getBestHotbarSlot();

                if (!this.mainInventory.get(this.currentItem).isEmpty()) {
                    int j = this.getFirstEmptyStack();

                    if (j != -1) {
                        this.mainInventory.set(j, this.mainInventory.get(this.currentItem));
                    }
                }

                this.mainInventory.set(this.currentItem, stack);
            } else {
                this.pickItem(i);
            }
        }
    }

    public void pickItem(int index) {
        this.currentItem = this.getBestHotbarSlot();
        ItemStack itemstack = this.mainInventory.get(this.currentItem);
        this.mainInventory.set(this.currentItem, this.mainInventory.get(index));
        this.mainInventory.set(index, itemstack);
    }

    public static boolean isHotbar(int index) {
        return index >= 0 && index < 9;
    }

    /**
     * Finds the stack or an equivalent one in the main inventory
     */
    public int getSlotFor(ItemStack stack) {
        for (int i = 0; i < this.mainInventory.size(); ++i) {
            if (!this.mainInventory.get(i).isEmpty() && this.stackEqualExact(stack, this.mainInventory.get(i))) {
                return i;
            }
        }

        return -1;
    }

    public int findSlotMatchingUnusedItem(ItemStack p_194014_1_) {
        for (int i = 0; i < this.mainInventory.size(); ++i) {
            ItemStack itemstack = this.mainInventory.get(i);

            if (!this.mainInventory.get(i).isEmpty() && this.stackEqualExact(p_194014_1_, this.mainInventory.get(i)) && !this.mainInventory.get(i).isDamaged() && !itemstack.isEnchanted() && !itemstack.hasDisplayName()) {
                return i;
            }
        }

        return -1;
    }

    public int getBestHotbarSlot() {
        for (int i = 0; i < 9; ++i) {
            int j = (this.currentItem + i) % 9;

            if (this.mainInventory.get(j).isEmpty()) {
                return j;
            }
        }

        for (int k = 0; k < 9; ++k) {
            int l = (this.currentItem + k) % 9;

            if (!this.mainInventory.get(l).isEnchanted()) {
                return l;
            }
        }

        return this.currentItem;
    }

    public void changeCurrentItem(double direction) {
        if (direction > 0.0D) {
            direction = 1.0D;
        }

        if (direction < 0.0D) {
            direction = -1.0D;
        }

        for (this.currentItem = (int) ((double) this.currentItem - direction); this.currentItem < 0; this.currentItem += 9) {
        }

        while (this.currentItem >= 9) {
            this.currentItem -= 9;
        }
    }

    public int func_234564_a_(Predicate<ItemStack> p_234564_1_, int p_234564_2_, IInventory p_234564_3_) {
        int i = 0;
        boolean flag = p_234564_2_ == 0;
        i = i + ItemStackHelper.func_233534_a_(this, p_234564_1_, p_234564_2_ - i, flag);
        i = i + ItemStackHelper.func_233534_a_(p_234564_3_, p_234564_1_, p_234564_2_ - i, flag);
        i = i + ItemStackHelper.func_233535_a_(this.itemStack, p_234564_1_, p_234564_2_ - i, flag);

        if (this.itemStack.isEmpty()) {
            this.itemStack = ItemStack.EMPTY;
        }

        return i;
    }

    /**
     * This function stores as many items of an ItemStack as possible in a matching slot and returns the quantity of
     * left over items.
     */
    private int storePartialItemStack(ItemStack itemStackIn) {
        int i = this.storeItemStack(itemStackIn);

        if (i == -1) {
            i = this.getFirstEmptyStack();
        }

        return i == -1 ? itemStackIn.getCount() : this.addResource(i, itemStackIn);
    }

    private int addResource(int p_191973_1_, ItemStack p_191973_2_) {
        Item item = p_191973_2_.getItem();
        int i = p_191973_2_.getCount();
        ItemStack itemstack = this.getStackInSlot(p_191973_1_);

        if (itemstack.isEmpty()) {
            itemstack = new ItemStack(item, 0);

            if (p_191973_2_.hasTag()) {
                itemstack.setTag(p_191973_2_.getTag().copy());
            }

            this.setInventorySlotContents(p_191973_1_, itemstack);
        }

        int j = i;

        if (i > itemstack.getMaxStackSize() - itemstack.getCount()) {
            j = itemstack.getMaxStackSize() - itemstack.getCount();
        }

        if (j > this.getInventoryStackLimit() - itemstack.getCount()) {
            j = this.getInventoryStackLimit() - itemstack.getCount();
        }

        if (j == 0) {
            return i;
        } else {
            i = i - j;
            itemstack.grow(j);
            itemstack.setAnimationsToGo(5);
            return i;
        }
    }

    /**
     * Stores a stack in the player's inventory. It first tries to place it in the selected slot in the player's hotbar,
     * then the offhand slot, then any available/empty slot in the player's inventory.
     */
    public int storeItemStack(ItemStack itemStackIn) {
        if (this.canMergeStacks(this.getStackInSlot(this.currentItem), itemStackIn)) {
            return this.currentItem;
        } else if (this.canMergeStacks(this.getStackInSlot(40), itemStackIn)) {
            return 40;
        } else {
            for (int i = 0; i < this.mainInventory.size(); ++i) {
                if (this.canMergeStacks(this.mainInventory.get(i), itemStackIn)) {
                    return i;
                }
            }

            return -1;
        }
    }

    /**
     * Decrement the number of animations remaining. Only called on client side. This is used to handle the animation of
     * receiving a block.
     */
    public void tick() {
        for (NonNullList<ItemStack> nonnulllist : this.allInventories) {
            for (int i = 0; i < nonnulllist.size(); ++i) {
                if (!nonnulllist.get(i).isEmpty()) {
                    nonnulllist.get(i).inventoryTick(this.player.world, this.player, i, this.currentItem == i);
                }
            }
        }
    }

    /**
     * Adds the stack to the first empty slot in the player's inventory. Returns {@code false} if it's not possible to
     * place the entire stack in the inventory.
     */
    public boolean addItemStackToInventory(ItemStack itemStackIn) {
        return this.add(-1, itemStackIn);
    }

    /**
     * Adds the stack to the specified slot in the player's inventory. Returns {@code false} if it's not possible to
     * place the entire stack in the inventory.
     */
    public boolean add(int slotIn, ItemStack stack) {
        if (stack.isEmpty()) {
            return false;
        } else {
            try {
                if (stack.isDamaged()) {
                    if (slotIn == -1) {
                        slotIn = this.getFirstEmptyStack();
                    }

                    if (slotIn >= 0) {
                        this.mainInventory.set(slotIn, stack.copy());
                        this.mainInventory.get(slotIn).setAnimationsToGo(5);
                        stack.setCount(0);
                        return true;
                    } else if (this.player.abilities.isCreativeMode) {
                        stack.setCount(0);
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    int i;

                    do {
                        i = stack.getCount();

                        if (slotIn == -1) {
                            stack.setCount(this.storePartialItemStack(stack));
                        } else {
                            stack.setCount(this.addResource(slotIn, stack));
                        }
                    }
                    while (!stack.isEmpty() && stack.getCount() < i);

                    if (stack.getCount() == i && this.player.abilities.isCreativeMode) {
                        stack.setCount(0);
                        return true;
                    } else {
                        return stack.getCount() < i;
                    }
                }
            } catch (Throwable throwable) {
                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Adding item to inventory");
                CrashReportCategory crashreportcategory = crashreport.makeCategory("Item being added");
                crashreportcategory.addDetail("Item ID", Item.getIdFromItem(stack.getItem()));
                crashreportcategory.addDetail("Item data", stack.getDamage());
                crashreportcategory.addDetail("Item name", () ->
                {
                    return stack.getDisplayName().getString();
                });
                throw new ReportedException(crashreport);
            }
        }
    }

    public void placeItemBackInInventory(World worldIn, ItemStack stack) {
        if (!worldIn.isRemote) {
            while (!stack.isEmpty()) {
                int i = this.storeItemStack(stack);

                if (i == -1) {
                    i = this.getFirstEmptyStack();
                }

                if (i == -1) {
                    this.player.dropItem(stack, false);
                    break;
                }

                int j = stack.getMaxStackSize() - this.getStackInSlot(i).getCount();

                if (this.add(i, stack.split(j))) {
                    ((ServerPlayerEntity) this.player).connection.sendPacket(new SSetSlotPacket(-2, i, this.getStackInSlot(i)));
                }
            }
        }
    }

    /**
     * Removes up to a specified number of items from an inventory slot and returns them in a new stack.
     */
    public ItemStack decrStackSize(int index, int count) {
        List<ItemStack> list = null;

        for (NonNullList<ItemStack> nonnulllist : this.allInventories) {
            if (index < nonnulllist.size()) {
                list = nonnulllist;
                break;
            }

            index -= nonnulllist.size();
        }

        return list != null && !list.get(index).isEmpty() ? ItemStackHelper.getAndSplit(list, index, count) : ItemStack.EMPTY;
    }

    public void deleteStack(ItemStack stack) {
        for (NonNullList<ItemStack> nonnulllist : this.allInventories) {
            for (int i = 0; i < nonnulllist.size(); ++i) {
                if (nonnulllist.get(i) == stack) {
                    nonnulllist.set(i, ItemStack.EMPTY);
                    break;
                }
            }
        }
    }

    /**
     * Removes a stack from the given slot and returns it.
     */
    public ItemStack removeStackFromSlot(int index) {
        NonNullList<ItemStack> nonnulllist = null;

        for (NonNullList<ItemStack> nonnulllist1 : this.allInventories) {
            if (index < nonnulllist1.size()) {
                nonnulllist = nonnulllist1;
                break;
            }

            index -= nonnulllist1.size();
        }

        if (nonnulllist != null && !nonnulllist.get(index).isEmpty()) {
            ItemStack itemstack = nonnulllist.get(index);
            nonnulllist.set(index, ItemStack.EMPTY);
            return itemstack;
        } else {
            return ItemStack.EMPTY;
        }
    }

    /**
     * Sets the given item stack to the specified slot in the inventory (can be crafting or armor sections).
     */
    public void setInventorySlotContents(int index, ItemStack stack) {
        NonNullList<ItemStack> nonnulllist = null;

        for (NonNullList<ItemStack> nonnulllist1 : this.allInventories) {
            if (index < nonnulllist1.size()) {
                nonnulllist = nonnulllist1;
                break;
            }

            index -= nonnulllist1.size();
        }

        if (nonnulllist != null) {
            nonnulllist.set(index, stack);
        }
    }

    public float getDestroySpeed(BlockState state) {
        return this.mainInventory.get(this.currentItem).getDestroySpeed(state);
    }

    /**
     * Writes the inventory out as a list of compound tags. This is where the slot indices are used (+100 for armor, +80
     * for crafting).
     */
    public ListNBT write(ListNBT nbtTagListIn) {
        for (int i = 0; i < this.mainInventory.size(); ++i) {
            if (!this.mainInventory.get(i).isEmpty()) {
                CompoundNBT compoundnbt = new CompoundNBT();
                compoundnbt.putByte("Slot", (byte) i);
                this.mainInventory.get(i).write(compoundnbt);
                nbtTagListIn.add(compoundnbt);
            }
        }

        for (int j = 0; j < this.armorInventory.size(); ++j) {
            if (!this.armorInventory.get(j).isEmpty()) {
                CompoundNBT compoundnbt1 = new CompoundNBT();
                compoundnbt1.putByte("Slot", (byte) (j + 100));
                this.armorInventory.get(j).write(compoundnbt1);
                nbtTagListIn.add(compoundnbt1);
            }
        }

        for (int k = 0; k < this.offHandInventory.size(); ++k) {
            if (!this.offHandInventory.get(k).isEmpty()) {
                CompoundNBT compoundnbt2 = new CompoundNBT();
                compoundnbt2.putByte("Slot", (byte) (k + 150));
                this.offHandInventory.get(k).write(compoundnbt2);
                nbtTagListIn.add(compoundnbt2);
            }
        }

        return nbtTagListIn;
    }

    /**
     * Reads from the given tag list and fills the slots in the inventory with the correct items.
     */
    public void read(ListNBT nbtTagListIn) {
        this.mainInventory.clear();
        this.armorInventory.clear();
        this.offHandInventory.clear();

        for (int i = 0; i < nbtTagListIn.size(); ++i) {
            CompoundNBT compoundnbt = nbtTagListIn.getCompound(i);
            int j = compoundnbt.getByte("Slot") & 255;
            ItemStack itemstack = ItemStack.read(compoundnbt);

            if (!itemstack.isEmpty()) {
                if (j >= 0 && j < this.mainInventory.size()) {
                    this.mainInventory.set(j, itemstack);
                } else if (j >= 100 && j < this.armorInventory.size() + 100) {
                    this.armorInventory.set(j - 100, itemstack);
                } else if (j >= 150 && j < this.offHandInventory.size() + 150) {
                    this.offHandInventory.set(j - 150, itemstack);
                }
            }
        }
    }

    /**
     * Returns the number of slots in the inventory.
     */
    public int getSizeInventory() {
        return this.mainInventory.size() + this.armorInventory.size() + this.offHandInventory.size();
    }

    public boolean isEmpty() {
        for (ItemStack itemstack : this.mainInventory) {
            if (!itemstack.isEmpty()) {
                return false;
            }
        }

        for (ItemStack itemstack1 : this.armorInventory) {
            if (!itemstack1.isEmpty()) {
                return false;
            }
        }

        for (ItemStack itemstack2 : this.offHandInventory) {
            if (!itemstack2.isEmpty()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns the stack in the given slot.
     */
    public ItemStack getStackInSlot(int index) {
        List<ItemStack> list = null;

        for (NonNullList<ItemStack> nonnulllist : this.allInventories) {
            if (index < nonnulllist.size()) {
                list = nonnulllist;
                break;
            }

            index -= nonnulllist.size();
        }

        return list == null ? ItemStack.EMPTY : list.get(index);
    }

    public ITextComponent getName() {
        return new TranslationTextComponent("container.inventory");
    }

    /**
     * returns a player armor item (as itemstack) contained in specified armor slot.
     */
    public ItemStack armorItemInSlot(int slotIn) {
        return this.armorInventory.get(slotIn);
    }

    public void func_234563_a_(DamageSource p_234563_1_, float p_234563_2_) {
        if (!(p_234563_2_ <= 0.0F)) {
            p_234563_2_ = p_234563_2_ / 4.0F;

            if (p_234563_2_ < 1.0F) {
                p_234563_2_ = 1.0F;
            }

            for (int i = 0; i < this.armorInventory.size(); ++i) {
                ItemStack itemstack = this.armorInventory.get(i);

                if ((!p_234563_1_.isFireDamage() || !itemstack.getItem().isImmuneToFire()) && itemstack.getItem() instanceof ArmorItem) {
                    int j = i;
                    itemstack.damageItem((int) p_234563_2_, this.player, (p_214023_1_) ->
                    {
                        p_214023_1_.sendBreakAnimation(EquipmentSlotType.fromSlotTypeAndIndex(EquipmentSlotType.Group.ARMOR, j));
                    });
                }
            }
        }
    }

    /**
     * Drop all armor and main inventory items.
     */
    public void dropAllItems() {
        for (List<ItemStack> list : this.allInventories) {
            for (int i = 0; i < list.size(); ++i) {
                ItemStack itemstack = list.get(i);

                if (!itemstack.isEmpty()) {
                    this.player.dropItem(itemstack, true, false);
                    list.set(i, ItemStack.EMPTY);
                }
            }
        }
    }

    /**
     * For tile entities, ensures the chunk containing the tile entity is saved to disk later - the game won't think it
     * hasn't changed and skip it.
     */
    public void markDirty() {
        ++this.timesChanged;
    }

    public int getTimesChanged() {
        return this.timesChanged;
    }

    /**
     * Set the stack helds by mouse, used in GUI/Container
     */
    public void setItemStack(ItemStack itemStackIn) {
        this.itemStack = itemStackIn;
    }

    /**
     * Stack helds by mouse, used in GUI and Containers
     */
    public ItemStack getItemStack() {
        return this.itemStack;
    }

    /**
     * Don't rename this method to canInteractWith due to conflicts with Container
     */
    public boolean isUsableByPlayer(PlayerEntity player) {
        if (this.player.removed) {
            return false;
        } else {
            return !(player.getDistanceSq(this.player) > 64.0D);
        }
    }

    /**
     * Returns true if the specified ItemStack exists in the inventory.
     */
    public boolean hasItemStack(ItemStack itemStackIn) {
        for (List<ItemStack> list : this.allInventories) {
            for (ItemStack itemstack : list) {
                if (!itemstack.isEmpty() && itemstack.isItemEqual(itemStackIn)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean hasTag(ITag<Item> itemTag) {
        for (List<ItemStack> list : this.allInventories) {
            for (ItemStack itemstack : list) {
                if (!itemstack.isEmpty() && itemTag.contains(itemstack.getItem())) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Copy the ItemStack contents from another InventoryPlayer instance
     */
    public void copyInventory(PlayerInventory playerInventory) {
        for (int i = 0; i < this.getSizeInventory(); ++i) {
            this.setInventorySlotContents(i, playerInventory.getStackInSlot(i));
        }

        this.currentItem = playerInventory.currentItem;
    }

    public void clear() {
        for (List<ItemStack> list : this.allInventories) {
            list.clear();
        }
    }

    public void accountStacks(RecipeItemHelper p_201571_1_) {
        for (ItemStack itemstack : this.mainInventory) {
            p_201571_1_.accountPlainStack(itemstack);
        }
    }
}

ServerPlayerEntity:
package net.minecraft.entity.player;

import com.google.common.collect.Lists;
import com.mojang.authlib.GameProfile;
import com.mojang.datafixers.util.Either;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.Random;
import java.util.UUID;
import javax.annotation.Nullable;
import net.minecraft.advancements.CriteriaTriggers;
import net.minecraft.advancements.PlayerAdvancements;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.HorizontalBlock;
import net.minecraft.block.NetherPortalBlock;
import net.minecraft.block.PortalInfo;
import net.minecraft.command.arguments.EntityAnchorArgument;
import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.crash.ReportedException;
import net.minecraft.entity.Entity;
import net.minecraft.entity.IAngerable;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.MobEntity;
import net.minecraft.entity.item.ItemEntity;
import net.minecraft.entity.monster.MonsterEntity;
import net.minecraft.entity.passive.horse.AbstractHorseEntity;
import net.minecraft.entity.projectile.AbstractArrowEntity;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.container.Container;
import net.minecraft.inventory.container.CraftingResultSlot;
import net.minecraft.inventory.container.HorseInventoryContainer;
import net.minecraft.inventory.container.IContainerListener;
import net.minecraft.inventory.container.INamedContainerProvider;
import net.minecraft.item.AbstractMapItem;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.item.MerchantOffers;
import net.minecraft.item.WrittenBookItem;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.item.crafting.ServerRecipeBook;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.NBTDynamicOps;
import net.minecraft.network.IPacket;
import net.minecraft.network.play.ServerPlayNetHandler;
import net.minecraft.network.play.client.CClientSettingsPacket;
import net.minecraft.network.play.server.SAnimateHandPacket;
import net.minecraft.network.play.server.SCameraPacket;
import net.minecraft.network.play.server.SChangeGameStatePacket;
import net.minecraft.network.play.server.SChatPacket;
import net.minecraft.network.play.server.SCloseWindowPacket;
import net.minecraft.network.play.server.SCombatPacket;
import net.minecraft.network.play.server.SDestroyEntitiesPacket;
import net.minecraft.network.play.server.SEntityStatusPacket;
import net.minecraft.network.play.server.SMerchantOffersPacket;
import net.minecraft.network.play.server.SOpenBookWindowPacket;
import net.minecraft.network.play.server.SOpenHorseWindowPacket;
import net.minecraft.network.play.server.SOpenSignMenuPacket;
import net.minecraft.network.play.server.SOpenWindowPacket;
import net.minecraft.network.play.server.SPlayEntityEffectPacket;
import net.minecraft.network.play.server.SPlaySoundEffectPacket;
import net.minecraft.network.play.server.SPlaySoundEventPacket;
import net.minecraft.network.play.server.SPlayerAbilitiesPacket;
import net.minecraft.network.play.server.SPlayerLookPacket;
import net.minecraft.network.play.server.SRemoveEntityEffectPacket;
import net.minecraft.network.play.server.SRespawnPacket;
import net.minecraft.network.play.server.SSendResourcePackPacket;
import net.minecraft.network.play.server.SServerDifficultyPacket;
import net.minecraft.network.play.server.SSetExperiencePacket;
import net.minecraft.network.play.server.SSetSlotPacket;
import net.minecraft.network.play.server.SSpawnPlayerPacket;
import net.minecraft.network.play.server.SUnloadChunkPacket;
import net.minecraft.network.play.server.SUpdateHealthPacket;
import net.minecraft.network.play.server.SUpdateTileEntityPacket;
import net.minecraft.network.play.server.SWindowItemsPacket;
import net.minecraft.network.play.server.SWindowPropertyPacket;
import net.minecraft.potion.EffectInstance;
import net.minecraft.potion.Effects;
import net.minecraft.scoreboard.Score;
import net.minecraft.scoreboard.ScoreCriteria;
import net.minecraft.scoreboard.ScorePlayerTeam;
import net.minecraft.scoreboard.Team;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.management.PlayerInteractionManager;
import net.minecraft.server.management.PlayerList;
import net.minecraft.stats.ServerStatisticsManager;
import net.minecraft.stats.Stat;
import net.minecraft.stats.Stats;
import net.minecraft.tileentity.CommandBlockTileEntity;
import net.minecraft.tileentity.SignTileEntity;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.CooldownTracker;
import net.minecraft.util.DamageSource;
import net.minecraft.util.Direction;
import net.minecraft.util.EntityDamageSource;
import net.minecraft.util.Hand;
import net.minecraft.util.HandSide;
import net.minecraft.util.NonNullList;
import net.minecraft.util.RegistryKey;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.ServerCooldownTracker;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.TeleportationRepositioner;
import net.minecraft.util.Unit;
import net.minecraft.util.Util;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.SectionPos;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.util.text.ChatType;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.StringTextComponent;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.util.text.TranslationTextComponent;
import net.minecraft.util.text.event.HoverEvent;
import net.minecraft.util.text.filter.IChatFilter;
import net.minecraft.world.GameRules;
import net.minecraft.world.GameType;
import net.minecraft.world.World;
import net.minecraft.world.biome.BiomeManager;
import net.minecraft.world.server.ServerWorld;
import net.minecraft.world.storage.IWorldInfo;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class ServerPlayerEntity extends PlayerEntity implements IContainerListener
{
    private static final Logger LOGGER = LogManager.getLogger();
    public ServerPlayNetHandler connection;
    public final MinecraftServer server;
    public final PlayerInteractionManager interactionManager;
    private final List<Integer> entityRemoveQueue = Lists.newLinkedList();
    private final PlayerAdvancements advancements;
    private final ServerStatisticsManager stats;

    /**
     * the total health of the player, includes actual health and absorption health. Updated every tick.
     */
    private float lastHealthScore = Float.MIN_VALUE;
    private int lastFoodScore = Integer.MIN_VALUE;
    private int lastAirScore = Integer.MIN_VALUE;
    private int lastArmorScore = Integer.MIN_VALUE;
    private int lastLevelScore = Integer.MIN_VALUE;
    private int lastExperienceScore = Integer.MIN_VALUE;
    private float lastHealth = -1.0E8F;
    private int lastFoodLevel = -99999999;
    private boolean wasHungry = true;
    private int lastExperience = -99999999;
    private int respawnInvulnerabilityTicks = 60;
    private ChatVisibility chatVisibility;
    private boolean chatColours = true;
    private long playerLastActiveTime = Util.milliTime();

    /** The entity the player is currently spectating through. */
    private Entity spectatingEntity;
    private boolean invulnerableDimensionChange;
    private boolean seenCredits;
    private final ServerRecipeBook recipeBook = new ServerRecipeBook();
    private Vector3d levitationStartPos;
    private int levitatingSince;
    private boolean disconnected;
    @Nullable
    private Vector3d enteredNetherPosition;

    /**
     * Player section position as last updated by TicketManager, used by ChunkManager
     */
    private SectionPos managedSectionPos = SectionPos.of(0, 0, 0);
    private RegistryKey<World> field_241137_cq_ = World.OVERWORLD;
    @Nullable
    private BlockPos field_241138_cr_;
    private boolean field_241139_cs_;
    private float field_242108_cn;
    @Nullable
    private final IChatFilter field_244528_co;
    private int currentWindowId;
    public boolean isChangingQuantityOnly;
    public int ping;
    public boolean queuedEndExit;

    public ServerPlayerEntity(MinecraftServer server, ServerWorld worldIn, GameProfile profile, PlayerInteractionManager interactionManagerIn)
    {
        super(worldIn, worldIn.getSpawnPoint(), worldIn.func_242107_v(), profile);
        interactionManagerIn.player = this;
        this.interactionManager = interactionManagerIn;
        this.server = server;
        this.stats = server.getPlayerList().getPlayerStats(this);
        this.advancements = server.getPlayerList().getPlayerAdvancements(this);
        this.stepHeight = 1.0F;
        this.func_205734_a(worldIn);
        this.field_244528_co = server.func_244435_a(this);
    }

    private void func_205734_a(ServerWorld worldIn)
    {
        BlockPos blockpos = worldIn.getSpawnPoint();

        if (worldIn.getDimensionType().hasSkyLight() && worldIn.getServer().func_240793_aU_().getGameType() != GameType.ADVENTURE)
        {
            int i = Math.max(0, this.server.getSpawnRadius(worldIn));
            int j = MathHelper.floor(worldIn.getWorldBorder().getClosestDistance((double)blockpos.getX(), (double)blockpos.getZ()));

            if (j < i)
            {
                i = j;
            }

            if (j <= 1)
            {
                i = 1;
            }

            long k = (long)(i * 2 + 1);
            long l = k * k;
            int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int)l;
            int j1 = this.func_205735_q(i1);
            int k1 = (new Random()).nextInt(i1);

            for (int l1 = 0; l1 < i1; ++l1)
            {
                int i2 = (k1 + j1 * l1) % i1;
                int j2 = i2 % (i * 2 + 1);
                int k2 = i2 / (i * 2 + 1);
                BlockPos blockpos1 = SpawnLocationHelper.func_241092_a_(worldIn, blockpos.getX() + j2 - i, blockpos.getZ() + k2 - i, false);

                if (blockpos1 != null)
                {
                    this.moveToBlockPosAndAngles(blockpos1, 0.0F, 0.0F);

                    if (worldIn.hasNoCollisions(this))
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            this.moveToBlockPosAndAngles(blockpos, 0.0F, 0.0F);

            while (!worldIn.hasNoCollisions(this) && this.getPosY() < 255.0D)
            {
                this.setPosition(this.getPosX(), this.getPosY() + 1.0D, this.getPosZ());
            }
        }
    }

    private int func_205735_q(int p_205735_1_)
    {
        return p_205735_1_ <= 16 ? p_205735_1_ - 1 : 17;
    }

    /**
     * (abstract) Protected helper method to read subclass entity data from NBT.
     */
    public void readAdditional(CompoundNBT compound)
    {
        super.readAdditional(compound);

        if (compound.contains("playerGameType", 99))
        {
            if (this.getServer().getForceGamemode())
            {
                this.interactionManager.func_241820_a(this.getServer().getGameType(), GameType.NOT_SET);
            }
            else
            {
                this.interactionManager.func_241820_a(GameType.getByID(compound.getInt("playerGameType")), compound.contains("previousPlayerGameType", 3) ? GameType.getByID(compound.getInt("previousPlayerGameType")) : GameType.NOT_SET);
            }
        }

        if (compound.contains("enteredNetherPosition", 10))
        {
            CompoundNBT compoundnbt = compound.getCompound("enteredNetherPosition");
            this.enteredNetherPosition = new Vector3d(compoundnbt.getDouble("x"), compoundnbt.getDouble("y"), compoundnbt.getDouble("z"));
        }

        this.seenCredits = compound.getBoolean("seenCredits");

        if (compound.contains("recipeBook", 10))
        {
            this.recipeBook.read(compound.getCompound("recipeBook"), this.server.getRecipeManager());
        }

        if (this.isSleeping())
        {
            this.wakeUp();
        }

        if (compound.contains("SpawnX", 99) && compound.contains("SpawnY", 99) && compound.contains("SpawnZ", 99))
        {
            this.field_241138_cr_ = new BlockPos(compound.getInt("SpawnX"), compound.getInt("SpawnY"), compound.getInt("SpawnZ"));
            this.field_241139_cs_ = compound.getBoolean("SpawnForced");
            this.field_242108_cn = compound.getFloat("SpawnAngle");

            if (compound.contains("SpawnDimension"))
            {
                this.field_241137_cq_ = World.CODEC.parse(NBTDynamicOps.INSTANCE, compound.get("SpawnDimension")).resultOrPartial(LOGGER::error).orElse(World.OVERWORLD);
            }
        }
    }

    public void writeAdditional(CompoundNBT compound)
    {
        super.writeAdditional(compound);
        compound.putInt("playerGameType", this.interactionManager.getGameType().getID());
        compound.putInt("previousPlayerGameType", this.interactionManager.func_241815_c_().getID());
        compound.putBoolean("seenCredits", this.seenCredits);

        if (this.enteredNetherPosition != null)
        {
            CompoundNBT compoundnbt = new CompoundNBT();
            compoundnbt.putDouble("x", this.enteredNetherPosition.x);
            compoundnbt.putDouble("y", this.enteredNetherPosition.y);
            compoundnbt.putDouble("z", this.enteredNetherPosition.z);
            compound.put("enteredNetherPosition", compoundnbt);
        }

        Entity entity1 = this.getLowestRidingEntity();
        Entity entity = this.getRidingEntity();

        if (entity != null && entity1 != this && entity1.isOnePlayerRiding())
        {
            CompoundNBT compoundnbt1 = new CompoundNBT();
            CompoundNBT compoundnbt2 = new CompoundNBT();
            entity1.writeUnlessPassenger(compoundnbt2);
            compoundnbt1.putUniqueId("Attach", entity.getUniqueID());
            compoundnbt1.put("Entity", compoundnbt2);
            compound.put("RootVehicle", compoundnbt1);
        }

        compound.put("recipeBook", this.recipeBook.write());
        compound.putString("Dimension", this.world.getDimensionKey().getLocation().toString());

        if (this.field_241138_cr_ != null)
        {
            compound.putInt("SpawnX", this.field_241138_cr_.getX());
            compound.putInt("SpawnY", this.field_241138_cr_.getY());
            compound.putInt("SpawnZ", this.field_241138_cr_.getZ());
            compound.putBoolean("SpawnForced", this.field_241139_cs_);
            compound.putFloat("SpawnAngle", this.field_242108_cn);
            ResourceLocation.CODEC.encodeStart(NBTDynamicOps.INSTANCE, this.field_241137_cq_.getLocation()).resultOrPartial(LOGGER::error).ifPresent((p_241148_1_) ->
            {
                compound.put("SpawnDimension", p_241148_1_);
            });
        }
    }

    public void func_195394_a(int p_195394_1_)
    {
        float f = (float)this.xpBarCap();
        float f1 = (f - 1.0F) / f;
        this.experience = MathHelper.clamp((float)p_195394_1_ / f, 0.0F, f1);
        this.lastExperience = -1;
    }

    public void setExperienceLevel(int level)
    {
        this.experienceLevel = level;
        this.lastExperience = -1;
    }

    /**
     * Add experience levels to this player.
     */
    public void addExperienceLevel(int levels)
    {
        super.addExperienceLevel(levels);
        this.lastExperience = -1;
    }

    public void onEnchant(ItemStack enchantedItem, int cost)
    {
        super.onEnchant(enchantedItem, cost);
        this.lastExperience = -1;
    }

    public void addSelfToInternalCraftingInventory()
    {
        this.openContainer.addListener(this);
    }

    /**
     * Sends an ENTER_COMBAT packet to the client
     */
    public void sendEnterCombat()
    {
        super.sendEnterCombat();
        this.connection.sendPacket(new SCombatPacket(this.getCombatTracker(), SCombatPacket.Event.ENTER_COMBAT));
    }

    /**
     * Sends an END_COMBAT packet to the client
     */
    public void sendEndCombat()
    {
        super.sendEndCombat();
        this.connection.sendPacket(new SCombatPacket(this.getCombatTracker(), SCombatPacket.Event.END_COMBAT));
    }

    protected void onInsideBlock(BlockState state)
    {
        CriteriaTriggers.ENTER_BLOCK.trigger(this, state);
    }

    protected CooldownTracker createCooldownTracker()
    {
        return new ServerCooldownTracker(this);
    }

    /**
     * Called to update the entity's position/logic.
     */
    public void tick()
    {
        this.interactionManager.tick();
        --this.respawnInvulnerabilityTicks;

        if (this.hurtResistantTime > 0)
        {
            --this.hurtResistantTime;
        }

        this.openContainer.detectAndSendChanges();

        if (!this.world.isRemote && !this.openContainer.canInteractWith(this))
        {
            this.closeScreen();
            this.openContainer = this.container;
        }

        while (!this.entityRemoveQueue.isEmpty())
        {
            int i = Math.min(this.entityRemoveQueue.size(), Integer.MAX_VALUE);
            int[] aint = new int[i];
            Iterator<Integer> iterator = this.entityRemoveQueue.iterator();
            int j = 0;

            while (iterator.hasNext() && j < i)
            {
                aint[j++] = iterator.next();
                iterator.remove();
            }

            this.connection.sendPacket(new SDestroyEntitiesPacket(aint));
        }

        Entity entity = this.getSpectatingEntity();

        if (entity != this)
        {
            if (entity.isAlive())
            {
                this.setPositionAndRotation(entity.getPosX(), entity.getPosY(), entity.getPosZ(), entity.rotationYaw, entity.rotationPitch);
                this.getServerWorld().getChunkProvider().updatePlayerPosition(this);

                if (this.wantsToStopRiding())
                {
                    this.setSpectatingEntity(this);
                }
            }
            else
            {
                this.setSpectatingEntity(this);
            }
        }

        CriteriaTriggers.TICK.trigger(this);

        if (this.levitationStartPos != null)
        {
            CriteriaTriggers.LEVITATION.trigger(this, this.levitationStartPos, this.ticksExisted - this.levitatingSince);
        }

        this.advancements.flushDirty(this);
    }

    public void playerTick()
    {
        try
        {
            if (!this.isSpectator() || this.world.isBlockLoaded(this.getPosition()))
            {
                super.tick();
            }

            for (int i = 0; i < this.inventory.getSizeInventory(); ++i)
            {
                ItemStack itemstack = this.inventory.getStackInSlot(i);

                if (itemstack.getItem().isComplex())
                {
                    IPacket<?> ipacket = ((AbstractMapItem)itemstack.getItem()).getUpdatePacket(itemstack, this.world, this);

                    if (ipacket != null)
                    {
                        this.connection.sendPacket(ipacket);
                    }
                }
            }

            if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry)
            {
                this.connection.sendPacket(new SUpdateHealthPacket(this.getHealth(), this.foodStats.getFoodLevel(), this.foodStats.getSaturationLevel()));
                this.lastHealth = this.getHealth();
                this.lastFoodLevel = this.foodStats.getFoodLevel();
                this.wasHungry = this.foodStats.getSaturationLevel() == 0.0F;
            }

            if (this.getHealth() + this.getAbsorptionAmount() != this.lastHealthScore)
            {
                this.lastHealthScore = this.getHealth() + this.getAbsorptionAmount();
                this.updateScorePoints(ScoreCriteria.HEALTH, MathHelper.ceil(this.lastHealthScore));
            }

            if (this.foodStats.getFoodLevel() != this.lastFoodScore)
            {
                this.lastFoodScore = this.foodStats.getFoodLevel();
                this.updateScorePoints(ScoreCriteria.FOOD, MathHelper.ceil((float)this.lastFoodScore));
            }

            if (this.getAir() != this.lastAirScore)
            {
                this.lastAirScore = this.getAir();
                this.updateScorePoints(ScoreCriteria.AIR, MathHelper.ceil((float)this.lastAirScore));
            }

            if (this.getTotalArmorValue() != this.lastArmorScore)
            {
                this.lastArmorScore = this.getTotalArmorValue();
                this.updateScorePoints(ScoreCriteria.ARMOR, MathHelper.ceil((float)this.lastArmorScore));
            }

            if (this.experienceTotal != this.lastExperienceScore)
            {
                this.lastExperienceScore = this.experienceTotal;
                this.updateScorePoints(ScoreCriteria.XP, MathHelper.ceil((float)this.lastExperienceScore));
            }

            if (this.experienceLevel != this.lastLevelScore)
            {
                this.lastLevelScore = this.experienceLevel;
                this.updateScorePoints(ScoreCriteria.LEVEL, MathHelper.ceil((float)this.lastLevelScore));
            }

            if (this.experienceTotal != this.lastExperience)
            {
                this.lastExperience = this.experienceTotal;
                this.connection.sendPacket(new SSetExperiencePacket(this.experience, this.experienceTotal, this.experienceLevel));
            }

            if (this.ticksExisted % 20 == 0)
            {
                CriteriaTriggers.LOCATION.trigger(this);
            }
        }
        catch (Throwable throwable)
        {
            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Ticking player");
            CrashReportCategory crashreportcategory = crashreport.makeCategory("Player being ticked");
            this.fillCrashReport(crashreportcategory);
            throw new ReportedException(crashreport);
        }
    }

    private void updateScorePoints(ScoreCriteria criteria, int points)
    {
        this.getWorldScoreboard().forAllObjectives(criteria, this.getScoreboardName(), (p_195397_1_) ->
        {
            p_195397_1_.setScorePoints(points);
        });
    }

    /**
     * Called when the mob's health reaches 0.
     */
    public void onDeath(DamageSource cause)
    {
        boolean flag = this.world.getGameRules().getBoolean(GameRules.SHOW_DEATH_MESSAGES);

        if (flag)
        {
            ITextComponent itextcomponent = this.getCombatTracker().getDeathMessage();
            this.connection.sendPacket(new SCombatPacket(this.getCombatTracker(), SCombatPacket.Event.ENTITY_DIED, itextcomponent), (p_212356_2_) ->
            {
                if (!p_212356_2_.isSuccess())
                {
                    int i = 256;
                    String s = itextcomponent.getStringTruncated(256);
                    ITextComponent itextcomponent1 = new TranslationTextComponent("death.attack.message_too_long", (new StringTextComponent(s)).mergeStyle(TextFormatting.YELLOW));
                    ITextComponent itextcomponent2 = (new TranslationTextComponent("death.attack.even_more_magic", this.getDisplayName())).modifyStyle((p_212357_1_) ->
                    {
                        return p_212357_1_.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, itextcomponent1));
                    });
                    this.connection.sendPacket(new SCombatPacket(this.getCombatTracker(), SCombatPacket.Event.ENTITY_DIED, itextcomponent2));
                }
            });
            Team team = this.getTeam();

            if (team != null && team.getDeathMessageVisibility() != Team.Visible.ALWAYS)
            {
                if (team.getDeathMessageVisibility() == Team.Visible.HIDE_FOR_OTHER_TEAMS)
                {
                    this.server.getPlayerList().sendMessageToAllTeamMembers(this, itextcomponent);
                }
                else if (team.getDeathMessageVisibility() == Team.Visible.HIDE_FOR_OWN_TEAM)
                {
                    this.server.getPlayerList().sendMessageToTeamOrAllPlayers(this, itextcomponent);
                }
            }
            else
            {
                this.server.getPlayerList().func_232641_a_(itextcomponent, ChatType.SYSTEM, Util.DUMMY_UUID);
            }
        }
        else
        {
            this.connection.sendPacket(new SCombatPacket(this.getCombatTracker(), SCombatPacket.Event.ENTITY_DIED));
        }

        this.spawnShoulderEntities();

        if (this.world.getGameRules().getBoolean(GameRules.FORGIVE_DEAD_PLAYERS))
        {
            this.func_241157_eT_();
        }

        if (!this.isSpectator())
        {
            this.spawnDrops(cause);
        }

        this.getWorldScoreboard().forAllObjectives(ScoreCriteria.DEATH_COUNT, this.getScoreboardName(), Score::incrementScore);
        LivingEntity livingentity = this.getAttackingEntity();

        if (livingentity != null)
        {
            this.addStat(Stats.ENTITY_KILLED_BY.get(livingentity.getType()));
            livingentity.awardKillScore(this, this.scoreValue, cause);
            this.createWitherRose(livingentity);
        }

        this.world.setEntityState(this, (byte)3);
        this.addStat(Stats.DEATHS);
        this.takeStat(Stats.CUSTOM.get(Stats.TIME_SINCE_DEATH));
        this.takeStat(Stats.CUSTOM.get(Stats.TIME_SINCE_REST));
        this.extinguish();
        this.setFlag(0, false);
        this.getCombatTracker().reset();
    }

    private void func_241157_eT_()
    {
        AxisAlignedBB axisalignedbb = (new AxisAlignedBB(this.getPosition())).grow(32.0D, 10.0D, 32.0D);
        this.world.getLoadedEntitiesWithinAABB(MobEntity.class, axisalignedbb).stream().filter((p_241155_0_) ->
        {
            return p_241155_0_ instanceof IAngerable;
        }).forEach((p_241145_1_) ->
        {
            ((IAngerable)p_241145_1_).func_233681_b_(this);
        });
    }

    public void awardKillScore(Entity killed, int scoreValue, DamageSource damageSource)
    {
        if (killed != this)
        {
            super.awardKillScore(killed, scoreValue, damageSource);
            this.addScore(scoreValue);
            String s = this.getScoreboardName();
            String s1 = killed.getScoreboardName();
            this.getWorldScoreboard().forAllObjectives(ScoreCriteria.TOTAL_KILL_COUNT, s, Score::incrementScore);

            if (killed instanceof PlayerEntity)
            {
                this.addStat(Stats.PLAYER_KILLS);
                this.getWorldScoreboard().forAllObjectives(ScoreCriteria.PLAYER_KILL_COUNT, s, Score::incrementScore);
            }
            else
            {
                this.addStat(Stats.MOB_KILLS);
            }

            this.handleTeamKill(s, s1, ScoreCriteria.TEAM_KILL);
            this.handleTeamKill(s1, s, ScoreCriteria.KILLED_BY_TEAM);
            CriteriaTriggers.PLAYER_KILLED_ENTITY.trigger(this, killed, damageSource);
        }
    }

    private void handleTeamKill(String p_195398_1_, String p_195398_2_, ScoreCriteria[] p_195398_3_)
    {
        ScorePlayerTeam scoreplayerteam = this.getWorldScoreboard().getPlayersTeam(p_195398_2_);

        if (scoreplayerteam != null)
        {
            int i = scoreplayerteam.getColor().getColorIndex();

            if (i >= 0 && i < p_195398_3_.length)
            {
                this.getWorldScoreboard().forAllObjectives(p_195398_3_[i], p_195398_1_, Score::incrementScore);
            }
        }
    }

    /**
     * Called when the entity is attacked.
     */
    public boolean attackEntityFrom(DamageSource source, float amount)
    {
        if (this.isInvulnerableTo(source))
        {
            return false;
        }
        else
        {
            boolean flag = this.server.isDedicatedServer() && this.canPlayersAttack() && "fall".equals(source.damageType);

            if (!flag && this.respawnInvulnerabilityTicks > 0 && source != DamageSource.OUT_OF_WORLD)
            {
                return false;
            }
            else
            {
                if (source instanceof EntityDamageSource)
                {
                    Entity entity = source.getTrueSource();

                    if (entity instanceof PlayerEntity && !this.canAttackPlayer((PlayerEntity)entity))
                    {
                        return false;
                    }

                    if (entity instanceof AbstractArrowEntity)
                    {
                        AbstractArrowEntity abstractarrowentity = (AbstractArrowEntity)entity;
                        Entity entity1 = abstractarrowentity.func_234616_v_();

                        if (entity1 instanceof PlayerEntity && !this.canAttackPlayer((PlayerEntity)entity1))
                        {
                            return false;
                        }
                    }
                }

                return super.attackEntityFrom(source, amount);
            }
        }
    }

    public boolean canAttackPlayer(PlayerEntity other)
    {
        return !this.canPlayersAttack() ? false : super.canAttackPlayer(other);
    }

    /**
     * Returns if other players can attack this player
     */
    private boolean canPlayersAttack()
    {
        return this.server.isPVPEnabled();
    }

    @Nullable
    protected PortalInfo func_241829_a(ServerWorld p_241829_1_)
    {
        PortalInfo portalinfo = super.func_241829_a(p_241829_1_);

        if (portalinfo != null && this.world.getDimensionKey() == World.OVERWORLD && p_241829_1_.getDimensionKey() == World.THE_END)
        {
            Vector3d vector3d = portalinfo.pos.add(0.0D, -1.0D, 0.0D);
            return new PortalInfo(vector3d, Vector3d.ZERO, 90.0F, 0.0F);
        }
        else
        {
            return portalinfo;
        }
    }

    @Nullable
    public Entity changeDimension(ServerWorld server)
    {
        this.invulnerableDimensionChange = true;
        ServerWorld serverworld = this.getServerWorld();
        RegistryKey<World> registrykey = serverworld.getDimensionKey();

        if (registrykey == World.THE_END && server.getDimensionKey() == World.OVERWORLD)
        {
            this.detach();
            this.getServerWorld().removePlayer(this);

            if (!this.queuedEndExit)
            {
                this.queuedEndExit = true;
                this.connection.sendPacket(new SChangeGameStatePacket(SChangeGameStatePacket.field_241768_e_, this.seenCredits ? 0.0F : 1.0F));
                this.seenCredits = true;
            }

            return this;
        }
        else
        {
            IWorldInfo iworldinfo = server.getWorldInfo();
            this.connection.sendPacket(new SRespawnPacket(server.getDimensionType(), server.getDimensionKey(), BiomeManager.getHashedSeed(server.getSeed()), this.interactionManager.getGameType(), this.interactionManager.func_241815_c_(), server.isDebug(), server.func_241109_A_(), true));
            this.connection.sendPacket(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));
            PlayerList playerlist = this.server.getPlayerList();
            playerlist.updatePermissionLevel(this);
            serverworld.removePlayer(this);
            this.removed = false;
            PortalInfo portalinfo = this.func_241829_a(server);

            if (portalinfo != null)
            {
                serverworld.getProfiler().startSection("moving");

                if (registrykey == World.OVERWORLD && server.getDimensionKey() == World.THE_NETHER)
                {
                    this.enteredNetherPosition = this.getPositionVec();
                }
                else if (server.getDimensionKey() == World.THE_END)
                {
                    this.func_242110_a(server, new BlockPos(portalinfo.pos));
                }

                serverworld.getProfiler().endSection();
                serverworld.getProfiler().startSection("placing");
                this.setWorld(server);
                server.addDuringPortalTeleport(this);
                this.setRotation(portalinfo.rotationYaw, portalinfo.rotationPitch);
                this.moveForced(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);
                serverworld.getProfiler().endSection();
                this.func_213846_b(serverworld);
                this.interactionManager.setWorld(server);
                this.connection.sendPacket(new SPlayerAbilitiesPacket(this.abilities));
                playerlist.sendWorldInfo(this, server);
                playerlist.sendInventory(this);

                for (EffectInstance effectinstance : this.getActivePotionEffects())
                {
                    this.connection.sendPacket(new SPlayEntityEffectPacket(this.getEntityId(), effectinstance));
                }

                this.connection.sendPacket(new SPlaySoundEventPacket(1032, BlockPos.ZERO, 0, false));
                this.lastExperience = -1;
                this.lastHealth = -1.0F;
                this.lastFoodLevel = -1;
            }

            return this;
        }
    }

    private void func_242110_a(ServerWorld p_242110_1_, BlockPos p_242110_2_)
    {
        BlockPos.Mutable blockpos$mutable = p_242110_2_.toMutable();

        for (int i = -2; i <= 2; ++i)
        {
            for (int j = -2; j <= 2; ++j)
            {
                for (int k = -1; k < 3; ++k)
                {
                    BlockState blockstate = k == -1 ? Blocks.OBSIDIAN.getDefaultState() : Blocks.AIR.getDefaultState();
                    p_242110_1_.setBlockState(blockpos$mutable.setPos(p_242110_2_).move(j, k, i), blockstate);
                }
            }
        }
    }

    protected Optional<TeleportationRepositioner.Result> func_241830_a(ServerWorld p_241830_1_, BlockPos p_241830_2_, boolean p_241830_3_)
    {
        Optional<TeleportationRepositioner.Result> optional = super.func_241830_a(p_241830_1_, p_241830_2_, p_241830_3_);

        if (optional.isPresent())
        {
            return optional;
        }
        else
        {
            Direction.Axis direction$axis = this.world.getBlockState(this.field_242271_ac).func_235903_d_(NetherPortalBlock.AXIS).orElse(Direction.Axis.X);
            Optional<TeleportationRepositioner.Result> optional1 = p_241830_1_.getDefaultTeleporter().makePortal(p_241830_2_, direction$axis);

            if (!optional1.isPresent())
            {
                LOGGER.error("Unable to create a portal, likely target out of worldborder");
            }

            return optional1;
        }
    }

    private void func_213846_b(ServerWorld p_213846_1_)
    {
        RegistryKey<World> registrykey = p_213846_1_.getDimensionKey();
        RegistryKey<World> registrykey1 = this.world.getDimensionKey();
        CriteriaTriggers.CHANGED_DIMENSION.testForAll(this, registrykey, registrykey1);

        if (registrykey == World.THE_NETHER && registrykey1 == World.OVERWORLD && this.enteredNetherPosition != null)
        {
            CriteriaTriggers.NETHER_TRAVEL.trigger(this, this.enteredNetherPosition);
        }

        if (registrykey1 != World.THE_NETHER)
        {
            this.enteredNetherPosition = null;
        }
    }

    public boolean isSpectatedByPlayer(ServerPlayerEntity player)
    {
        if (player.isSpectator())
        {
            return this.getSpectatingEntity() == this;
        }
        else
        {
            return this.isSpectator() ? false : super.isSpectatedByPlayer(player);
        }
    }

    private void sendTileEntityUpdate(TileEntity p_147097_1_)
    {
        if (p_147097_1_ != null)
        {
            SUpdateTileEntityPacket supdatetileentitypacket = p_147097_1_.getUpdatePacket();

            if (supdatetileentitypacket != null)
            {
                this.connection.sendPacket(supdatetileentitypacket);
            }
        }
    }

    /**
     * Called when the entity picks up an item.
     */
    public void onItemPickup(Entity entityIn, int quantity)
    {
        super.onItemPickup(entityIn, quantity);
        this.openContainer.detectAndSendChanges();
    }

    public Either<SleepResult, Unit> trySleep(BlockPos at)
    {
        Direction direction = this.world.getBlockState(at).get(HorizontalBlock.HORIZONTAL_FACING);

        if (!this.isSleeping() && this.isAlive())
        {
            if (!this.world.getDimensionType().isNatural())
            {
                return Either.left(SleepResult.NOT_POSSIBLE_HERE);
            }
            else if (!this.func_241147_a_(at, direction))
            {
                return Either.left(SleepResult.TOO_FAR_AWAY);
            }
            else if (this.func_241156_b_(at, direction))
            {
                return Either.left(SleepResult.OBSTRUCTED);
            }
            else
            {
                this.func_242111_a(this.world.getDimensionKey(), at, this.rotationYaw, false, true);

                if (this.world.isDaytime())
                {
                    return Either.left(SleepResult.NOT_POSSIBLE_NOW);
                }
                else
                {
                    if (!this.isCreative())
                    {
                        double d0 = 8.0D;
                        double d1 = 5.0D;
                        Vector3d vector3d = Vector3d.copyCenteredHorizontally(at);
                        List<MonsterEntity> list = this.world.getEntitiesWithinAABB(MonsterEntity.class, new AxisAlignedBB(vector3d.getX() - 8.0D, vector3d.getY() - 5.0D, vector3d.getZ() - 8.0D, vector3d.getX() + 8.0D, vector3d.getY() + 5.0D, vector3d.getZ() + 8.0D), (p_241146_1_) ->
                        {
                            return p_241146_1_.func_230292_f_(this);
                        });

                        if (!list.isEmpty())
                        {
                            return Either.left(SleepResult.NOT_SAFE);
                        }
                    }

                    Either<SleepResult, Unit> either = super.trySleep(at).ifRight((p_241144_1_) ->
                    {
                        this.addStat(Stats.SLEEP_IN_BED);
                        CriteriaTriggers.SLEPT_IN_BED.trigger(this);
                    });
                    ((ServerWorld)this.world).updateAllPlayersSleepingFlag();
                    return either;
                }
            }
        }
        else
        {
            return Either.left(SleepResult.OTHER_PROBLEM);
        }
    }

    public void startSleeping(BlockPos pos)
    {
        this.takeStat(Stats.CUSTOM.get(Stats.TIME_SINCE_REST));
        super.startSleeping(pos);
    }

    private boolean func_241147_a_(BlockPos p_241147_1_, Direction p_241147_2_)
    {
        return this.func_241158_g_(p_241147_1_) || this.func_241158_g_(p_241147_1_.offset(p_241147_2_.getOpposite()));
    }

    private boolean func_241158_g_(BlockPos p_241158_1_)
    {
        Vector3d vector3d = Vector3d.copyCenteredHorizontally(p_241158_1_);
        return Math.abs(this.getPosX() - vector3d.getX()) <= 3.0D && Math.abs(this.getPosY() - vector3d.getY()) <= 2.0D && Math.abs(this.getPosZ() - vector3d.getZ()) <= 3.0D;
    }

    private boolean func_241156_b_(BlockPos p_241156_1_, Direction p_241156_2_)
    {
        BlockPos blockpos = p_241156_1_.up();
        return !this.isNormalCube(blockpos) || !this.isNormalCube(blockpos.offset(p_241156_2_.getOpposite()));
    }

    public void stopSleepInBed(boolean p_225652_1_, boolean p_225652_2_)
    {
        if (this.isSleeping())
        {
            this.getServerWorld().getChunkProvider().sendToTrackingAndSelf(this, new SAnimateHandPacket(this, 2));
        }

        super.stopSleepInBed(p_225652_1_, p_225652_2_);

        if (this.connection != null)
        {
            this.connection.setPlayerLocation(this.getPosX(), this.getPosY(), this.getPosZ(), this.rotationYaw, this.rotationPitch);
        }
    }

    public boolean startRiding(Entity entityIn, boolean force)
    {
        Entity entity = this.getRidingEntity();

        if (!super.startRiding(entityIn, force))
        {
            return false;
        }
        else
        {
            Entity entity1 = this.getRidingEntity();

            if (entity1 != entity && this.connection != null)
            {
                this.connection.setPlayerLocation(this.getPosX(), this.getPosY(), this.getPosZ(), this.rotationYaw, this.rotationPitch);
            }

            return true;
        }
    }

    /**
     * Dismounts this entity from the entity it is riding.
     */
    public void stopRiding()
    {
        Entity entity = this.getRidingEntity();
        super.stopRiding();
        Entity entity1 = this.getRidingEntity();

        if (entity1 != entity && this.connection != null)
        {
            this.connection.setPlayerLocation(this.getPosX(), this.getPosY(), this.getPosZ(), this.rotationYaw, this.rotationPitch);
        }
    }

    /**
     * Returns whether this Entity is invulnerable to the given DamageSource.
     */
    public boolean isInvulnerableTo(DamageSource source)
    {
        return super.isInvulnerableTo(source) || this.isInvulnerableDimensionChange() || this.abilities.disableDamage && source == DamageSource.WITHER;
    }

    protected void updateFallState(double y, boolean onGroundIn, BlockState state, BlockPos pos)
    {
    }

    protected void frostWalk(BlockPos pos)
    {
        if (!this.isSpectator())
        {
            super.frostWalk(pos);
        }
    }

    /**
     * process player falling based on movement packet
     */
    public void handleFalling(double y, boolean onGroundIn)
    {
        BlockPos blockpos = this.getOnPosition();

        if (this.world.isBlockLoaded(blockpos))
        {
            super.updateFallState(y, onGroundIn, this.world.getBlockState(blockpos), blockpos);
        }
    }

    public void openSignEditor(SignTileEntity signTile)
    {
        signTile.setPlayer(this);
        this.connection.sendPacket(new SOpenSignMenuPacket(signTile.getPos()));
    }

    /**
     * get the next window id to use
     */
    private void getNextWindowId()
    {
        this.currentWindowId = this.currentWindowId % 100 + 1;
    }

    public OptionalInt openContainer(@Nullable INamedContainerProvider p_213829_1_)
    {
        if (p_213829_1_ == null)
        {
            return OptionalInt.empty();
        }
        else
        {
            if (this.openContainer != this.container)
            {
                this.closeScreen();
            }

            this.getNextWindowId();
            Container container = p_213829_1_.createMenu(this.currentWindowId, this.inventory, this);

            if (container == null)
            {
                if (this.isSpectator())
                {
                    this.sendStatusMessage((new TranslationTextComponent("container.spectatorCantOpen")).mergeStyle(TextFormatting.RED), true);
                }

                return OptionalInt.empty();
            }
            else
            {
                this.connection.sendPacket(new SOpenWindowPacket(container.windowId, container.getType(), p_213829_1_.getDisplayName()));
                container.addListener(this);
                this.openContainer = container;
                return OptionalInt.of(this.currentWindowId);
            }
        }
    }

    public void openMerchantContainer(int containerId, MerchantOffers offers, int level, int xp, boolean p_213818_5_, boolean p_213818_6_)
    {
        this.connection.sendPacket(new SMerchantOffersPacket(containerId, offers, level, xp, p_213818_5_, p_213818_6_));
    }

    public void openHorseInventory(AbstractHorseEntity horse, IInventory inventoryIn)
    {
        if (this.openContainer != this.container)
        {
            this.closeScreen();
        }

        this.getNextWindowId();
        this.connection.sendPacket(new SOpenHorseWindowPacket(this.currentWindowId, inventoryIn.getSizeInventory(), horse.getEntityId()));
        this.openContainer = new HorseInventoryContainer(this.currentWindowId, this.inventory, inventoryIn, horse);
        this.openContainer.addListener(this);
    }

    public void openBook(ItemStack stack, Hand hand)
    {
        Item item = stack.getItem();

        if (item == Items.WRITTEN_BOOK)
        {
            if (WrittenBookItem.resolveContents(stack, this.getCommandSource(), this))
            {
                this.openContainer.detectAndSendChanges();
            }

            this.connection.sendPacket(new SOpenBookWindowPacket(hand));
        }
    }

    public void openCommandBlock(CommandBlockTileEntity commandBlock)
    {
        commandBlock.setSendToClient(true);
        this.sendTileEntityUpdate(commandBlock);
    }

    /**
     * Sends the contents of an inventory slot to the client-side Container. This doesn't have to match the actual
     * contents of that slot.
     */
    public void sendSlotContents(Container containerToSend, int slotInd, ItemStack stack)
    {
        if (!(containerToSend.getSlot(slotInd) instanceof CraftingResultSlot))
        {
            if (containerToSend == this.container)
            {
                CriteriaTriggers.INVENTORY_CHANGED.test(this, this.inventory, stack);
            }

            if (!this.isChangingQuantityOnly)
            {
                this.connection.sendPacket(new SSetSlotPacket(containerToSend.windowId, slotInd, stack));
            }
        }
    }

    public void sendContainerToPlayer(Container containerIn)
    {
        this.sendAllContents(containerIn, containerIn.getInventory());
    }

    /**
     * update the crafting window inventory with the items in the list
     */
    public void sendAllContents(Container containerToSend, NonNullList<ItemStack> itemsList)
    {
        this.connection.sendPacket(new SWindowItemsPacket(containerToSend.windowId, itemsList));
        this.connection.sendPacket(new SSetSlotPacket(-1, -1, this.inventory.getItemStack()));
    }

    /**
     * Sends two ints to the client-side Container. Used for furnace burning time, smelting progress, brewing progress,
     * and enchanting level. Normally the first int identifies which variable to update, and the second contains the new
     * value. Both are truncated to shorts in non-local SMP.
     */
    public void sendWindowProperty(Container containerIn, int varToUpdate, int newValue)
    {
        this.connection.sendPacket(new SWindowPropertyPacket(containerIn.windowId, varToUpdate, newValue));
    }

    /**
     * set current crafting inventory back to the 2x2 square
     */
    public void closeScreen()
    {
        this.connection.sendPacket(new SCloseWindowPacket(this.openContainer.windowId));
        this.closeContainer();
    }

    /**
     * updates item held by mouse
     */
    public void updateHeldItem()
    {
        if (!this.isChangingQuantityOnly)
        {
            this.connection.sendPacket(new SSetSlotPacket(-1, -1, this.inventory.getItemStack()));
        }
    }

    /**
     * Closes the container the player currently has open.
     */
    public void closeContainer()
    {
        this.openContainer.onContainerClosed(this);
        this.openContainer = this.container;
    }

    public void setEntityActionState(float strafe, float forward, boolean jumping, boolean sneaking)
    {
        if (this.isPassenger())
        {
            if (strafe >= -1.0F && strafe <= 1.0F)
            {
                this.moveStrafing = strafe;
            }

            if (forward >= -1.0F && forward <= 1.0F)
            {
                this.moveForward = forward;
            }

            this.isJumping = jumping;
            this.setSneaking(sneaking);
        }
    }

    /**
     * Adds a value to a statistic field.
     */
    public void addStat(Stat<?> stat, int amount)
    {
        this.stats.increment(this, stat, amount);
        this.getWorldScoreboard().forAllObjectives(stat, this.getScoreboardName(), (p_195396_1_) ->
        {
            p_195396_1_.increaseScore(amount);
        });
    }

    public void takeStat(Stat<?> stat)
    {
        this.stats.setValue(this, stat, 0);
        this.getWorldScoreboard().forAllObjectives(stat, this.getScoreboardName(), Score::reset);
    }

    public int unlockRecipes(Collection < IRecipe<? >> p_195065_1_)
    {
        return this.recipeBook.add(p_195065_1_, this);
    }

    public void unlockRecipes(ResourceLocation[] p_193102_1_)
    {
        List < IRecipe<? >> list = Lists.newArrayList();

        for (ResourceLocation resourcelocation : p_193102_1_)
        {
            this.server.getRecipeManager().getRecipe(resourcelocation).ifPresent(list::add);
        }

        this.unlockRecipes(list);
    }

    public int resetRecipes(Collection < IRecipe<? >> p_195069_1_)
    {
        return this.recipeBook.remove(p_195069_1_, this);
    }

    public void giveExperiencePoints(int p_195068_1_)
    {
        super.giveExperiencePoints(p_195068_1_);
        this.lastExperience = -1;
    }

    public void disconnect()
    {
        this.disconnected = true;
        this.removePassengers();

        if (this.isSleeping())
        {
            this.stopSleepInBed(true, false);
        }
    }

    public boolean hasDisconnected()
    {
        return this.disconnected;
    }

    /**
     * this function is called when a players inventory is sent to him, lastHealth is updated on any dimension
     * transitions, then reset.
     */
    public void setPlayerHealthUpdated()
    {
        this.lastHealth = -1.0E8F;
    }

    public void sendStatusMessage(ITextComponent chatComponent, boolean actionBar)
    {
        this.connection.sendPacket(new SChatPacket(chatComponent, actionBar ? ChatType.GAME_INFO : ChatType.CHAT, Util.DUMMY_UUID));
    }

    /**
     * Used for when item use count runs out, ie: eating completed
     */
    protected void onItemUseFinish()
    {
        if (!this.activeItemStack.isEmpty() && this.isHandActive())
        {
            this.connection.sendPacket(new SEntityStatusPacket(this, (byte)9));
            super.onItemUseFinish();
        }
    }

    public void lookAt(EntityAnchorArgument.Type anchor, Vector3d target)
    {
        super.lookAt(anchor, target);
        this.connection.sendPacket(new SPlayerLookPacket(anchor, target.x, target.y, target.z));
    }

    public void lookAt(EntityAnchorArgument.Type p_200618_1_, Entity p_200618_2_, EntityAnchorArgument.Type p_200618_3_)
    {
        Vector3d vector3d = p_200618_3_.apply(p_200618_2_);
        super.lookAt(p_200618_1_, vector3d);
        this.connection.sendPacket(new SPlayerLookPacket(p_200618_1_, p_200618_2_, p_200618_3_));
    }

    public void copyFrom(ServerPlayerEntity that, boolean keepEverything)
    {
        if (keepEverything)
        {
            this.inventory.copyInventory(that.inventory);
            this.setHealth(that.getHealth());
            this.foodStats = that.foodStats;
            this.experienceLevel = that.experienceLevel;
            this.experienceTotal = that.experienceTotal;
            this.experience = that.experience;
            this.setScore(that.getScore());
            this.field_242271_ac = that.field_242271_ac;
        }
        else if (this.world.getGameRules().getBoolean(GameRules.KEEP_INVENTORY) || that.isSpectator())
        {
            this.inventory.copyInventory(that.inventory);
            this.experienceLevel = that.experienceLevel;
            this.experienceTotal = that.experienceTotal;
            this.experience = that.experience;
            this.setScore(that.getScore());
        }

        this.xpSeed = that.xpSeed;
        this.enterChestInventory = that.enterChestInventory;
        this.getDataManager().set(PLAYER_MODEL_FLAG, that.getDataManager().get(PLAYER_MODEL_FLAG));
        this.lastExperience = -1;
        this.lastHealth = -1.0F;
        this.lastFoodLevel = -1;
        this.recipeBook.copyFrom(that.recipeBook);
        this.entityRemoveQueue.addAll(that.entityRemoveQueue);
        this.seenCredits = that.seenCredits;
        this.enteredNetherPosition = that.enteredNetherPosition;
        this.setLeftShoulderEntity(that.getLeftShoulderEntity());
        this.setRightShoulderEntity(that.getRightShoulderEntity());
    }

    protected void onNewPotionEffect(EffectInstance id)
    {
        super.onNewPotionEffect(id);
        this.connection.sendPacket(new SPlayEntityEffectPacket(this.getEntityId(), id));

        if (id.getPotion() == Effects.LEVITATION)
        {
            this.levitatingSince = this.ticksExisted;
            this.levitationStartPos = this.getPositionVec();
        }

        CriteriaTriggers.EFFECTS_CHANGED.trigger(this);
    }

    protected void onChangedPotionEffect(EffectInstance id, boolean reapply)
    {
        super.onChangedPotionEffect(id, reapply);
        this.connection.sendPacket(new SPlayEntityEffectPacket(this.getEntityId(), id));
        CriteriaTriggers.EFFECTS_CHANGED.trigger(this);
    }

    protected void onFinishedPotionEffect(EffectInstance effect)
    {
        super.onFinishedPotionEffect(effect);
        this.connection.sendPacket(new SRemoveEntityEffectPacket(this.getEntityId(), effect.getPotion()));

        if (effect.getPotion() == Effects.LEVITATION)
        {
            this.levitationStartPos = null;
        }

        CriteriaTriggers.EFFECTS_CHANGED.trigger(this);
    }

    /**
     * Sets the position of the entity and updates the 'last' variables
     */
    public void setPositionAndUpdate(double x, double y, double z)
    {
        this.connection.setPlayerLocation(x, y, z, this.rotationYaw, this.rotationPitch);
    }

    public void moveForced(double x, double y, double z)
    {
        this.setPositionAndUpdate(x, y, z);
        this.connection.captureCurrentPosition();
    }

    /**
     * Called when the entity is dealt a critical hit.
     */
    public void onCriticalHit(Entity entityHit)
    {
        this.getServerWorld().getChunkProvider().sendToTrackingAndSelf(this, new SAnimateHandPacket(entityHit, 4));
    }

    public void onEnchantmentCritical(Entity entityHit)
    {
        this.getServerWorld().getChunkProvider().sendToTrackingAndSelf(this, new SAnimateHandPacket(entityHit, 5));
    }

    /**
     * Sends the player's abilities to the server (if there is one).
     */
    public void sendPlayerAbilities()
    {
        if (this.connection != null)
        {
            this.connection.sendPacket(new SPlayerAbilitiesPacket(this.abilities));
            this.updatePotionMetadata();
        }
    }

    public ServerWorld getServerWorld()
    {
        return (ServerWorld)this.world;
    }

    /**
     * Sets the player's game mode and sends it to them.
     */
    public void setGameType(GameType gameType)
    {
        this.interactionManager.setGameType(gameType);
        this.connection.sendPacket(new SChangeGameStatePacket(SChangeGameStatePacket.field_241767_d_, (float)gameType.getID()));

        if (gameType == GameType.SPECTATOR)
        {
            this.spawnShoulderEntities();
            this.stopRiding();
        }
        else
        {
            this.setSpectatingEntity(this);
        }

        this.sendPlayerAbilities();
        this.markPotionsDirty();
    }

    /**
     * Returns true if the player is in spectator mode.
     */
    public boolean isSpectator()
    {
        return this.interactionManager.getGameType() == GameType.SPECTATOR;
    }

    public boolean isCreative()
    {
        return this.interactionManager.getGameType() == GameType.CREATIVE;
    }

    /**
     * Send a chat message to the CommandSender
     */
    public void sendMessage(ITextComponent component, UUID senderUUID)
    {
        this.func_241151_a_(component, ChatType.SYSTEM, senderUUID);
    }

    public void func_241151_a_(ITextComponent p_241151_1_, ChatType p_241151_2_, UUID p_241151_3_)
    {
        this.connection.sendPacket(new SChatPacket(p_241151_1_, p_241151_2_, p_241151_3_), (p_241149_4_) ->
        {
            if (!p_241149_4_.isSuccess() && (p_241151_2_ == ChatType.GAME_INFO || p_241151_2_ == ChatType.SYSTEM))
            {
                int i = 256;
                String s = p_241151_1_.getStringTruncated(256);
                ITextComponent itextcomponent = (new StringTextComponent(s)).mergeStyle(TextFormatting.YELLOW);
                this.connection.sendPacket(new SChatPacket((new TranslationTextComponent("multiplayer.message_not_delivered", itextcomponent)).mergeStyle(TextFormatting.RED), ChatType.SYSTEM, p_241151_3_));
            }
        });
    }

    /**
     * Gets the player's IP address. Used in /banip.
     */
    public String getPlayerIP()
    {
        String s = this.connection.netManager.getRemoteAddress().toString();
        s = s.substring(s.indexOf("/") + 1);
        return s.substring(0, s.indexOf(":"));
    }

    public void handleClientSettings(CClientSettingsPacket packetIn)
    {
        this.chatVisibility = packetIn.getChatVisibility();
        this.chatColours = packetIn.isColorsEnabled();
        this.getDataManager().set(PLAYER_MODEL_FLAG, (byte)packetIn.getModelPartFlags());
        this.getDataManager().set(MAIN_HAND, (byte)(packetIn.getMainHand() == HandSide.LEFT ? 0 : 1));
    }

    public ChatVisibility getChatVisibility()
    {
        return this.chatVisibility;
    }

    public void loadResourcePack(String url, String hash)
    {
        this.connection.sendPacket(new SSendResourcePackPacket(url, hash));
    }

    protected int getPermissionLevel()
    {
        return this.server.getPermissionLevel(this.getGameProfile());
    }

    public void markPlayerActive()
    {
        this.playerLastActiveTime = Util.milliTime();
    }

    public ServerStatisticsManager getStats()
    {
        return this.stats;
    }

    public ServerRecipeBook getRecipeBook()
    {
        return this.recipeBook;
    }

    /**
     * Sends a packet to the player to remove an entity.
     */
    public void removeEntity(Entity entityIn)
    {
        if (entityIn instanceof PlayerEntity)
        {
            this.connection.sendPacket(new SDestroyEntitiesPacket(entityIn.getEntityId()));
        }
        else
        {
            this.entityRemoveQueue.add(entityIn.getEntityId());
        }
    }

    public void addEntity(Entity entityIn)
    {
        this.entityRemoveQueue.remove(Integer.valueOf(entityIn.getEntityId()));
    }

    /**
     * Clears potion metadata values if the entity has no potion effects. Otherwise, updates potion effect color,
     * ambience, and invisibility metadata values
     */
    protected void updatePotionMetadata()
    {
        if (this.isSpectator())
        {
            this.resetPotionEffectMetadata();
            this.setInvisible(true);
        }
        else
        {
            super.updatePotionMetadata();
        }
    }

    public Entity getSpectatingEntity()
    {
        return (Entity)(this.spectatingEntity == null ? this : this.spectatingEntity);
    }

    public void setSpectatingEntity(Entity entityToSpectate)
    {
        Entity entity = this.getSpectatingEntity();
        this.spectatingEntity = (Entity)(entityToSpectate == null ? this : entityToSpectate);

        if (entity != this.spectatingEntity)
        {
            this.connection.sendPacket(new SCameraPacket(this.spectatingEntity));
            this.setPositionAndUpdate(this.spectatingEntity.getPosX(), this.spectatingEntity.getPosY(), this.spectatingEntity.getPosZ());
        }
    }

    /**
     * Decrements the counter for the remaining time until the entity may use a portal again.
     */
    protected void decrementTimeUntilPortal()
    {
        if (!this.invulnerableDimensionChange)
        {
            super.decrementTimeUntilPortal();
        }
    }

    /**
     * Attacks for the player the targeted entity with the currently equipped item.  The equipped item has hitEntity
     * called on it. Args: targetEntity
     */
    public void attackTargetEntityWithCurrentItem(Entity targetEntity)
    {
        if (this.interactionManager.getGameType() == GameType.SPECTATOR)
        {
            this.setSpectatingEntity(targetEntity);
        }
        else
        {
            super.attackTargetEntityWithCurrentItem(targetEntity);
        }
    }

    public long getLastActiveTime()
    {
        return this.playerLastActiveTime;
    }

    @Nullable

    /**
     * Returns null which indicates the tab list should just display the player's name, return a different value to
     * display the specified text instead of the player's name
     */
    public ITextComponent getTabListDisplayName()
    {
        return null;
    }

    public void swingArm(Hand hand)
    {
        super.swingArm(hand);
        this.resetCooldown();
    }

    public boolean isInvulnerableDimensionChange()
    {
        return this.invulnerableDimensionChange;
    }

    public void clearInvulnerableDimensionChange()
    {
        this.invulnerableDimensionChange = false;
    }

    public PlayerAdvancements getAdvancements()
    {
        return this.advancements;
    }

    public void teleport(ServerWorld newWorld, double x, double y, double z, float yaw, float pitch)
    {
        this.setSpectatingEntity(this);
        this.stopRiding();

        if (newWorld == this.world)
        {
            this.connection.setPlayerLocation(x, y, z, yaw, pitch);
        }
        else
        {
            ServerWorld serverworld = this.getServerWorld();
            IWorldInfo iworldinfo = newWorld.getWorldInfo();
            this.connection.sendPacket(new SRespawnPacket(newWorld.getDimensionType(), newWorld.getDimensionKey(), BiomeManager.getHashedSeed(newWorld.getSeed()), this.interactionManager.getGameType(), this.interactionManager.func_241815_c_(), newWorld.isDebug(), newWorld.func_241109_A_(), true));
            this.connection.sendPacket(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));
            this.server.getPlayerList().updatePermissionLevel(this);
            serverworld.removePlayer(this);
            this.removed = false;
            this.setLocationAndAngles(x, y, z, yaw, pitch);
            this.setWorld(newWorld);
            newWorld.addDuringCommandTeleport(this);
            this.func_213846_b(serverworld);
            this.connection.setPlayerLocation(x, y, z, yaw, pitch);
            this.interactionManager.setWorld(newWorld);
            this.server.getPlayerList().sendWorldInfo(this, newWorld);
            this.server.getPlayerList().sendInventory(this);
        }
    }

    @Nullable
    public BlockPos func_241140_K_()
    {
        return this.field_241138_cr_;
    }

    public float func_242109_L()
    {
        return this.field_242108_cn;
    }

    public RegistryKey<World> func_241141_L_()
    {
        return this.field_241137_cq_;
    }

    public boolean func_241142_M_()
    {
        return this.field_241139_cs_;
    }

    public void func_242111_a(RegistryKey<World> p_242111_1_, @Nullable BlockPos p_242111_2_, float p_242111_3_, boolean p_242111_4_, boolean p_242111_5_)
    {
        if (p_242111_2_ != null)
        {
            boolean flag = p_242111_2_.equals(this.field_241138_cr_) && p_242111_1_.equals(this.field_241137_cq_);

            if (p_242111_5_ && !flag)
            {
                this.sendMessage(new TranslationTextComponent("block.minecraft.set_spawn"), Util.DUMMY_UUID);
            }

            this.field_241138_cr_ = p_242111_2_;
            this.field_241137_cq_ = p_242111_1_;
            this.field_242108_cn = p_242111_3_;
            this.field_241139_cs_ = p_242111_4_;
        }
        else
        {
            this.field_241138_cr_ = null;
            this.field_241137_cq_ = World.OVERWORLD;
            this.field_242108_cn = 0.0F;
            this.field_241139_cs_ = false;
        }
    }

    public void sendChunkLoad(ChunkPos p_213844_1_, IPacket<?> p_213844_2_, IPacket<?> p_213844_3_)
    {
        this.connection.sendPacket(p_213844_3_);
        this.connection.sendPacket(p_213844_2_);
    }

    public void sendChunkUnload(ChunkPos p_213845_1_)
    {
        if (this.isAlive())
        {
            this.connection.sendPacket(new SUnloadChunkPacket(p_213845_1_.x, p_213845_1_.z));
        }
    }

    public SectionPos getManagedSectionPos()
    {
        return this.managedSectionPos;
    }

    public void setManagedSectionPos(SectionPos sectionPosIn)
    {
        this.managedSectionPos = sectionPosIn;
    }

    public void playSound(SoundEvent p_213823_1_, SoundCategory p_213823_2_, float p_213823_3_, float p_213823_4_)
    {
        this.connection.sendPacket(new SPlaySoundEffectPacket(p_213823_1_, p_213823_2_, this.getPosX(), this.getPosY(), this.getPosZ(), p_213823_3_, p_213823_4_));
    }

    public IPacket<?> createSpawnPacket()
    {
        return new SSpawnPlayerPacket(this);
    }

    /**
     * Creates and drops the provided item. Depending on the dropAround, it will drop teh item around the player,
     * instead of dropping the item from where the player is pointing at. Likewise, if traceItem is true, the dropped
     * item entity will have the thrower set as the player.
     */
    public ItemEntity dropItem(ItemStack droppedItem, boolean dropAround, boolean traceItem)
    {
        ItemEntity itementity = super.dropItem(droppedItem, dropAround, traceItem);

        if (itementity == null)
        {
            return null;
        }
        else
        {
            this.world.addEntity(itementity);
            ItemStack itemstack = itementity.getItem();

            if (traceItem)
            {
                if (!itemstack.isEmpty())
                {
                    this.addStat(Stats.ITEM_DROPPED.get(itemstack.getItem()), droppedItem.getCount());
                }

                this.addStat(Stats.DROP);
            }

            return itementity;
        }
    }

    @Nullable
    public IChatFilter func_244529_Q()
    {
        return this.field_244528_co;
    }
}

Entity:
package net.minecraft.entity;

import baritone.api.BaritoneAPI;
import baritone.api.event.events.RotationMoveEvent;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
import it.unimi.dsi.fastutil.objects.Object2DoubleMap;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;
import javax.annotation.Nullable;

import net.minecraft.advancements.CriteriaTriggers;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.block.FenceGateBlock;
import net.minecraft.block.HoneyBlock;
import net.minecraft.block.PortalInfo;
import net.minecraft.block.PortalSize;
import net.minecraft.block.SoundType;
import net.minecraft.block.material.PushReaction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.player.ClientPlayerEntity;
import net.minecraft.command.CommandSource;
import net.minecraft.command.ICommandSource;
import net.minecraft.command.arguments.EntityAnchorArgument;
import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.crash.ReportedException;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.enchantment.ProtectionEnchantment;
import net.minecraft.entity.effect.LightningBoltEntity;
import net.minecraft.entity.item.BoatEntity;
import net.minecraft.entity.item.ItemEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.ServerPlayerEntity;
import net.minecraft.fluid.Fluid;
import net.minecraft.fluid.FluidState;
import net.minecraft.inventory.EquipmentSlotType;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.DoubleNBT;
import net.minecraft.nbt.FloatNBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.nbt.StringNBT;
import net.minecraft.network.IPacket;
import net.minecraft.network.datasync.DataParameter;
import net.minecraft.network.datasync.DataSerializers;
import net.minecraft.network.datasync.EntityDataManager;
import net.minecraft.particles.BlockParticleData;
import net.minecraft.particles.ParticleTypes;
import net.minecraft.scoreboard.ScorePlayerTeam;
import net.minecraft.scoreboard.Team;
import net.minecraft.server.MinecraftServer;
import net.minecraft.state.properties.BlockStateProperties;
import net.minecraft.tags.BlockTags;
import net.minecraft.tags.FluidTags;
import net.minecraft.tags.ITag;
import net.minecraft.util.ActionResultType;
import net.minecraft.util.DamageSource;
import net.minecraft.util.Direction;
import net.minecraft.util.Hand;
import net.minecraft.util.IItemProvider;
import net.minecraft.util.INameable;
import net.minecraft.util.Mirror;
import net.minecraft.util.RegistryKey;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.ReuseableStream;
import net.minecraft.util.Rotation;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.SoundEvents;
import net.minecraft.util.TeleportationRepositioner;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RayTraceContext;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.shapes.IBooleanFunction;
import net.minecraft.util.math.shapes.ISelectionContext;
import net.minecraft.util.math.shapes.VoxelShape;
import net.minecraft.util.math.shapes.VoxelShapes;
import net.minecraft.util.math.vector.Vector2f;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.util.text.IFormattableTextComponent;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.event.ClickEvent;
import net.minecraft.util.text.event.HoverEvent;
import net.minecraft.world.DimensionType;
import net.minecraft.world.Explosion;
import net.minecraft.world.GameRules;
import net.minecraft.world.IBlockReader;
import net.minecraft.world.IWorldReader;
import net.minecraft.world.World;
import net.minecraft.world.border.WorldBorder;
import net.minecraft.world.gen.Heightmap;
import net.minecraft.world.server.ServerWorld;
import net.minecraft.world.server.TicketType;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import wtf.expensive.events.EventManager;
import wtf.expensive.events.impl.player.EventMove;
import wtf.expensive.events.impl.player.EventPostMove;
import wtf.expensive.events.impl.player.EventStep;
import wtf.expensive.events.impl.player.EventStrafe;
import wtf.expensive.managment.Managment;
import wtf.expensive.modules.impl.combat.HitBoxFunction;
import wtf.expensive.modules.impl.player.FreeCam;
import wtf.expensive.util.FreeCamera;

public abstract class Entity implements INameable, ICommandSource {
    protected static final Logger LOGGER = LogManager.getLogger();
    private static final AtomicInteger NEXT_ENTITY_ID = new AtomicInteger();
    private static final List<ItemStack> EMPTY_EQUIPMENT = Collections.emptyList();
    private static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
    private static double renderDistanceWeight = 1.0D;
    private final EntityType<?> type;
    private int entityId = NEXT_ENTITY_ID.incrementAndGet();
    public boolean preventEntitySpawning;
    private final List<Entity> passengers = Lists.newArrayList();
    protected int rideCooldown;
    public boolean botEntity;
    @Nullable
    private Entity ridingEntity;
    public boolean forceSpawn;
    public World world;
    public double prevPosX;
    public double prevPosY;
    public double prevPosZ;
    private Vector3d positionVec;
    private BlockPos position;
    public Vector3d motion = Vector3d.ZERO;
    public float rotationYaw;
    public float rotationPitch;
    public float prevRotationYaw;
    public float prevRotationPitch;
    private AxisAlignedBB boundingBox = ZERO_AABB;
    protected boolean onGround;
    public boolean collidedHorizontally;
    public boolean collidedVertically;
    public boolean velocityChanged;
    protected Vector3d motionMultiplier = Vector3d.ZERO;
    public boolean removed;
    public float prevDistanceWalkedModified;
    public float distanceWalkedModified;
    public float distanceWalkedOnStepModified;
    public float fallDistance;
    private float nextStepDistance = 1.0F;
    private float nextFlap = 1.0F;
    public double lastTickPosX;
    public double lastTickPosY;
    public double lastTickPosZ;
    public float stepHeight;
    public boolean noClip;
    public float entityCollisionReduction;
    protected final Random rand = new Random();
    public int ticksExisted;
    private int fire = -this.getFireImmuneTicks();
    protected boolean inWater;
    protected Object2DoubleMap<ITag<Fluid>> eyesFluidLevel = new Object2DoubleArrayMap<>(2);
    protected boolean eyesInWater;
    @Nullable
    protected ITag<Fluid> field_241335_O_;
    public int hurtResistantTime;
    protected boolean firstUpdate = true;
    protected final EntityDataManager dataManager;
    protected static final DataParameter<Byte> FLAGS = EntityDataManager.createKey(Entity.class, DataSerializers.BYTE);
    private static final DataParameter<Integer> AIR = EntityDataManager.createKey(Entity.class, DataSerializers.VARINT);
    private static final DataParameter<Optional<ITextComponent>> CUSTOM_NAME = EntityDataManager.createKey(Entity.class, DataSerializers.OPTIONAL_TEXT_COMPONENT);
    private static final DataParameter<Boolean> CUSTOM_NAME_VISIBLE = EntityDataManager.createKey(Entity.class, DataSerializers.BOOLEAN);
    private static final DataParameter<Boolean> SILENT = EntityDataManager.createKey(Entity.class, DataSerializers.BOOLEAN);
    private static final DataParameter<Boolean> NO_GRAVITY = EntityDataManager.createKey(Entity.class, DataSerializers.BOOLEAN);
    protected static final DataParameter<Pose> POSE = EntityDataManager.createKey(Entity.class, DataSerializers.POSE);
    public boolean addedToChunk;
    public int chunkCoordX;
    public int chunkCoordY;
    public int chunkCoordZ;
    private boolean isLoaded;
    private Vector3d field_242272_av;
    public boolean ignoreFrustumCheck;
    public boolean isAirBorne;
    private int field_242273_aw;
    protected boolean inPortal;
    protected int portalCounter;
    protected BlockPos field_242271_ac;
    private boolean invulnerable;
    protected UUID entityUniqueID = MathHelper.getRandomUUID(this.rand);
    protected String cachedUniqueIdString = this.entityUniqueID.toString();
    protected boolean glowing;
    private final Set<String> tags = Sets.newHashSet();
    private boolean isPositionDirty;
    private final double[] pistonDeltas = new double[]{0.0D, 0.0D, 0.0D};
    private long pistonDeltasGameTime;
    public EntitySize size;
    private float eyeHeight;

    public Entity(EntityType<?> entityTypeIn, World worldIn) {
        this.type = entityTypeIn;
        this.world = worldIn;
        this.size = entityTypeIn.getSize();
        this.positionVec = Vector3d.ZERO;
        this.position = BlockPos.ZERO;
        this.field_242272_av = Vector3d.ZERO;
        this.setPosition(0.0D, 0.0D, 0.0D);
        this.dataManager = new EntityDataManager(this);
        this.dataManager.register(FLAGS, (byte) 0);
        this.dataManager.register(AIR, this.getMaxAir());
        this.dataManager.register(CUSTOM_NAME_VISIBLE, false);
        this.dataManager.register(CUSTOM_NAME, Optional.empty());
        this.dataManager.register(SILENT, false);
        this.dataManager.register(NO_GRAVITY, false);
        this.dataManager.register(POSE, Pose.STANDING);
        this.registerData();
        this.eyeHeight = this.getEyeHeight(Pose.STANDING, this.size);
    }

    public boolean func_242278_a(BlockPos p_242278_1_, BlockState p_242278_2_) {
        VoxelShape voxelshape = p_242278_2_.getCollisionShape(this.world, p_242278_1_, ISelectionContext.forEntity(this));
        VoxelShape voxelshape1 = voxelshape.withOffset((double) p_242278_1_.getX(), (double) p_242278_1_.getY(), (double) p_242278_1_.getZ());
        return VoxelShapes.compare(voxelshape1, VoxelShapes.create(this.getBoundingBox()), IBooleanFunction.AND);
    }

    public int getTeamColor() {
        Team team = this.getTeam();
        return team != null && team.getColor().getColor() != null ? team.getColor().getColor() : 16777215;
    }

    /**
     * Returns true if the player is in spectator mode.
     */
    public boolean isSpectator() {
        return false;
    }

    public final void detach() {
        if (this.isBeingRidden()) {
            this.removePassengers();
        }

        if (this.isPassenger()) {
            this.stopRiding();
        }
    }

    public void setPacketCoordinates(double x, double y, double z) {
        this.func_242277_a(new Vector3d(x, y, z));
    }

    public void func_242277_a(Vector3d p_242277_1_) {
        this.field_242272_av = p_242277_1_;
    }

    public Vector3d func_242274_V() {
        return this.field_242272_av;
    }

    public EntityType<?> getType() {
        return this.type;
    }

    public int getEntityId() {
        return this.entityId;
    }

    public void setEntityId(int id) {
        this.entityId = id;
    }

    public Set<String> getTags() {
        return this.tags;
    }

    public boolean addTag(String tag) {
        return this.tags.size() >= 1024 ? false : this.tags.add(tag);
    }

    public boolean removeTag(String tag) {
        return this.tags.remove(tag);
    }

    /**
     * Called by the /kill command.
     */
    public void onKillCommand() {
        this.remove();
    }

    protected abstract void registerData();

    public EntityDataManager getDataManager() {
        return this.dataManager;
    }

    public boolean equals(Object p_equals_1_) {
        if (p_equals_1_ instanceof Entity) {
            return ((Entity) p_equals_1_).entityId == this.entityId;
        } else {
            return false;
        }
    }

    public int hashCode() {
        return this.entityId;
    }

    /**
     * Keeps moving the entity up so it isn't colliding with blocks and other requirements for this entity to be spawned
     * (only actually used on players though its also on Entity)
     */
    protected void preparePlayerToSpawn() {
        if (this.world != null) {
            for (double d0 = this.getPosY(); d0 > 0.0D && d0 < 256.0D; ++d0) {
                this.setPosition(this.getPosX(), d0, this.getPosZ());

                if (this.world.hasNoCollisions(this)) {
                    break;
                }
            }

            this.setMotion(Vector3d.ZERO);
            this.rotationPitch = 0.0F;
        }
    }

    /**
     * Queues the entity for removal from the world on the next tick.
     */
    public void remove() {
        this.removed = true;
    }

    public void setPose(Pose poseIn) {
        this.dataManager.set(POSE, poseIn);
    }

    public Pose getPose() {
        return this.dataManager.get(POSE);
    }

    public boolean isEntityInRange(Entity entity, double distance) {
        double d0 = entity.positionVec.x - this.positionVec.x;
        double d1 = entity.positionVec.y - this.positionVec.y;
        double d2 = entity.positionVec.z - this.positionVec.z;
        return d0 * d0 + d1 * d1 + d2 * d2 < distance * distance;
    }

    /**
     * Sets the rotation of the entity.
     */
    protected void setRotation(float yaw, float pitch) {
        this.rotationYaw = yaw % 360.0F;
        this.rotationPitch = pitch % 360.0F;
    }

    /**
     * Sets the x,y,z of the entity from the given parameters. Also seems to set up a bounding box.
     */
    public void setPosition(double x, double y, double z) {
        this.setRawPosition(x, y, z);
        this.setBoundingBox(this.size.func_242285_a(x, y, z));
    }

    /**
     * Recomputes this entity's bounding box so that it is positioned at this entity's X/Y/Z.
     */
    protected void recenterBoundingBox() {
        this.setPosition(this.positionVec.x, this.positionVec.y, this.positionVec.z);
    }

    public void rotateTowards(double yaw, double pitch) {

        double d0 = pitch * 0.15D;
        double d1 = yaw * 0.15D;
        this.rotationPitch = (float) ((double) this.rotationPitch + d0);
        this.rotationYaw = (float) ((double) this.rotationYaw + d1);
        this.rotationPitch = MathHelper.clamp(this.rotationPitch, -90.0F, 90.0F);
        this.prevRotationPitch = (float) ((double) this.prevRotationPitch + d0);
        this.prevRotationYaw = (float) ((double) this.prevRotationYaw + d1);
        this.prevRotationPitch = MathHelper.clamp(this.prevRotationPitch, -90.0F, 90.0F);

        if (this.ridingEntity != null) {
            this.ridingEntity.applyOrientationToEntity(this);
        }
    }

    /**
     * Called to update the entity's position/logic.
     */
    public void tick() {
        if (!this.world.isRemote) {
            this.setFlag(6, this.isGlowing());
        }

        this.baseTick();
    }

    /**
     * Gets called every tick from main Entity class
     */
    public void baseTick() {
        this.world.getProfiler().startSection("entityBaseTick");

        if (this.isPassenger() && this.getRidingEntity().removed) {
            this.stopRiding();
        }

        if (this.rideCooldown > 0) {
            --this.rideCooldown;
        }

        this.prevDistanceWalkedModified = this.distanceWalkedModified;
        this.prevRotationPitch = this.rotationPitch;
        this.prevRotationYaw = this.rotationYaw;
        this.updatePortal();

        if (this.func_230269_aK_()) {
            this.func_233569_aL_();
        }

        this.func_233566_aG_();
        this.updateEyesInWater();
        this.updateSwimming();

        if (this.world.isRemote) {
            this.extinguish();
        } else if (this.fire > 0) {
            if (this.isImmuneToFire()) {
                this.forceFireTicks(this.fire - 4);

                if (this.fire < 0) {
                    this.extinguish();
                }
            } else {
                if (this.fire % 20 == 0 && !this.isInLava()) {
                    this.attackEntityFrom(DamageSource.ON_FIRE, 1.0F);
                }

                this.forceFireTicks(this.fire - 1);
            }
        }

        if (this.isInLava()) {
            this.setOnFireFromLava();
            this.fallDistance *= 0.5F;
        }

        if (this.getPosY() < -64.0D) {
            this.outOfWorld();
        }

        if (!this.world.isRemote) {
            this.setFlag(0, this.fire > 0);
        }

        this.firstUpdate = false;
        this.world.getProfiler().endSection();
    }

    public void func_242279_ag() {
        this.field_242273_aw = this.getPortalCooldown();
    }

    public boolean func_242280_ah() {
        return this.field_242273_aw > 0;
    }

    /**
     * Decrements the counter for the remaining time until the entity may use a portal again.
     */
    protected void decrementTimeUntilPortal() {
        if (this.func_242280_ah()) {
            --this.field_242273_aw;
        }
    }

    /**
     * Return the amount of time this entity should stay in a portal before being transported.
     */
    public int getMaxInPortalTime() {
        return 0;
    }

    /**
     * Called whenever the entity is walking inside of lava.
     */
    protected void setOnFireFromLava() {
        if (!this.isImmuneToFire()) {
            this.setFire(15);
            this.attackEntityFrom(DamageSource.LAVA, 4.0F);
        }
    }

    /**
     * Sets entity to burn for x amount of seconds, cannot lower amount of existing fire.
     */
    public void setFire(int seconds) {
        int i = seconds * 20;

        if (this instanceof LivingEntity) {
            i = ProtectionEnchantment.getFireTimeForEntity((LivingEntity) this, i);
        }

        if (this.fire < i) {
            this.forceFireTicks(i);
        }
    }

    public void forceFireTicks(int ticks) {
        this.fire = ticks;
    }

    public int getFireTimer() {
        return this.fire;
    }

    /**
     * Removes fire from entity.
     */
    public void extinguish() {
        this.forceFireTicks(0);
    }

    /**
     * sets the dead flag. Used when you fall off the bottom of the world.
     */
    protected void outOfWorld() {
        this.remove();
    }

    /**
     * Checks if the offset position from the entity's current position is inside of a liquid.
     */
    public boolean isOffsetPositionInLiquid(double x, double y, double z) {
        return this.isLiquidPresentInAABB(this.getBoundingBox().offset(x, y, z));
    }

    /**
     * Determines if a liquid is present within the specified AxisAlignedBB.
     */
    private boolean isLiquidPresentInAABB(AxisAlignedBB bb) {
        return this.world.hasNoCollisions(this, bb) && !this.world.containsAnyLiquid(bb);
    }

    public void setOnGround(boolean grounded) {
        this.onGround = grounded;
    }

    public boolean isOnGround() {
        return this.onGround;
    }

    public void move(MoverType typeIn, Vector3d pos) {


        double preX = getPosX(), preZ = getPosZ();

        if (this.noClip) {
            this.setBoundingBox(this.getBoundingBox().offset(pos));
            this.resetPositionToBB();
        } else {
            if (typeIn == MoverType.PISTON) {
                pos = this.handlePistonMovement(pos);

                if (pos.equals(Vector3d.ZERO)) {
                    return;
                }
            }

            this.world.getProfiler().startSection("move");
            if (this.motionMultiplier.lengthSquared() > 1.0E-7D) {
                pos = pos.mul(this.motionMultiplier);
                this.motionMultiplier = Vector3d.ZERO;
                this.setMotion(Vector3d.ZERO);
            }

            boolean ignoreVertical = false;
            boolean ignoreHorizontal = false;

            pos = this.maybeBackOffFromEdge(pos, typeIn);

            Vector3d predictPos = this.maybeBackOffFromEdge(pos, typeIn);

            Vector3d predictPos3d = this.getAllowedMovement(predictPos, false, false);
            if (this instanceof ClientPlayerEntity) {
                Vector3d predictedPosition = getPositionVec().add(predictPos3d);
                Vector3d fromPosition = getPositionVec();
                boolean collidedVertically = predictPos.y != predictPos3d.y;
                boolean collidedHorizontally = !MathHelper.epsilonEquals(predictPos.x, predictPos3d.x) || !MathHelper.epsilonEquals(predictPos.z, predictPos3d.z);
                boolean onGround = collidedVertically && predictPos.y < 0.0D;
                AxisAlignedBB bb = this.getBoundingBox();

                EventMove move = new EventMove(fromPosition, predictedPosition, pos, onGround, collidedHorizontally, collidedVertically, bb);
                EventManager.call(move);

                pos = move.motion();
                ignoreHorizontal = move.isIgnoreHorizontal();
                ignoreVertical = move.isIgnoreVertical();
            }

            Vector3d vector3d = this.getAllowedMovement(pos, ignoreHorizontal, ignoreVertical);
            if (vector3d.lengthSquared() > 1.0E-7D) {
                this.setBoundingBox(this.getBoundingBox().offset(vector3d));
                this.resetPositionToBB();
            }

            this.world.getProfiler().endSection();
            this.world.getProfiler().startSection("rest");
            this.collidedHorizontally = !MathHelper.epsilonEquals(pos.x, vector3d.x) || !MathHelper.epsilonEquals(pos.z, vector3d.z);
            this.collidedVertically = pos.y != vector3d.y;
            this.onGround = this.collidedVertically && pos.y < 0.0D;

            if (this instanceof ClientPlayerEntity) {
                double deltaX = getPosX() - preX, deltaZ = getPosZ() - preZ;
                EventPostMove post = new EventPostMove(Math.sqrt(deltaX * deltaX + deltaZ * deltaZ));
                EventManager.call(post);
            }

            BlockPos blockpos = this.getOnPosition();
            BlockState blockstate = this.world.getBlockState(blockpos);
            this.updateFallState(vector3d.y, this.onGround, blockstate, blockpos);
            Vector3d vector3d1 = this.getMotion();

            if (pos.x != vector3d.x) {
                this.setMotion(0.0D, vector3d1.y, vector3d1.z);
            }

            if (pos.z != vector3d.z) {
                this.setMotion(vector3d1.x, vector3d1.y, 0.0D);
            }

            Block block = blockstate.getBlock();

            if (pos.y != vector3d.y) {
                block.onLanded(this.world, this);
            }

            if (this.onGround && !this.isSteppingCarefully()) {
                block.onEntityWalk(this.world, blockpos, this);
            }

            if (this.canTriggerWalking() && !this.isPassenger()) {
                double d0 = vector3d.x;
                double d1 = vector3d.y;
                double d2 = vector3d.z;

                if (!block.isIn(BlockTags.CLIMBABLE)) {
                    d1 = 0.0D;
                }

                this.distanceWalkedModified = (float) ((double) this.distanceWalkedModified + (double) MathHelper.sqrt(horizontalMag(vector3d)) * 0.6D);
                this.distanceWalkedOnStepModified = (float) ((double) this.distanceWalkedOnStepModified + (double) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 0.6D);

                if (this.distanceWalkedOnStepModified > this.nextStepDistance && !blockstate.isAir()) {
                    this.nextStepDistance = this.determineNextStepDistance();

                    if (this.isInWater()) {
                        Entity entity = this.isBeingRidden() && this.getControllingPassenger() != null ? this.getControllingPassenger() : this;
                        float f = entity == this ? 0.35F : 0.4F;
                        Vector3d vector3d2 = entity.getMotion();
                        float f1 = MathHelper.sqrt(vector3d2.x * vector3d2.x * (double) 0.2F + vector3d2.y * vector3d2.y + vector3d2.z * vector3d2.z * (double) 0.2F) * f;

                        if (f1 > 1.0F) {
                            f1 = 1.0F;
                        }

                        this.playSwimSound(f1);
                    } else {
                        this.playStepSound(blockpos, blockstate);
                    }
                } else if (this.distanceWalkedOnStepModified > this.nextFlap && this.makeFlySound() && blockstate.isAir()) {
                    this.nextFlap = this.playFlySound(this.distanceWalkedOnStepModified);
                }
            }

            try {
                this.doBlockCollisions();
            } catch (Throwable throwable) {
                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Checking entity block collision");
                CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being checked for collision");
                this.fillCrashReport(crashreportcategory);
                throw new ReportedException(crashreport);
            }

            float f2 = this.getSpeedFactor();
            this.setMotion(this.getMotion().mul((double) f2, 1.0D, (double) f2));

            if (this.world.getStatesInArea(this.getBoundingBox().shrink(0.001D)).noneMatch((p_233572_0_) ->
            {
                return p_233572_0_.isIn(BlockTags.FIRE) || p_233572_0_.isIn(Blocks.LAVA);
            }) && this.fire <= 0) {
                this.forceFireTicks(-this.getFireImmuneTicks());
            }

            if (this.isInWaterRainOrBubbleColumn() && this.isBurning()) {
                this.playSound(SoundEvents.ENTITY_GENERIC_EXTINGUISH_FIRE, 0.7F, 1.6F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
                this.forceFireTicks(-this.getFireImmuneTicks());
            }

            this.world.getProfiler().endSection();
        }
    }

    protected BlockPos getOnPosition() {
        int i = MathHelper.floor(this.positionVec.x);
        int j = MathHelper.floor(this.positionVec.y - (double) 0.2F);
        int k = MathHelper.floor(this.positionVec.z);
        BlockPos blockpos = new BlockPos(i, j, k);

        if (this.world.getBlockState(blockpos).isAir()) {
            BlockPos blockpos1 = blockpos.down();
            BlockState blockstate = this.world.getBlockState(blockpos1);
            Block block = blockstate.getBlock();

            if (block.isIn(BlockTags.FENCES) || block.isIn(BlockTags.WALLS) || block instanceof FenceGateBlock) {
                return blockpos1;
            }
        }

        return blockpos;
    }

    protected float getJumpFactor() {
        float f = this.world.getBlockState(this.getPosition()).getBlock().getJumpFactor();
        float f1 = this.world.getBlockState(this.getPositionUnderneath()).getBlock().getJumpFactor();
        return (double) f == 1.0D ? f1 : f;
    }

    protected float getSpeedFactor() {
        Block block = this.world.getBlockState(this.getPosition()).getBlock();
        float f = block.getSpeedFactor();

        if (block != Blocks.WATER && block != Blocks.BUBBLE_COLUMN) {
            return (double) f == 1.0D ? this.world.getBlockState(this.getPositionUnderneath()).getBlock().getSpeedFactor() : f;
        } else {
            return f;
        }
    }

    protected BlockPos getPositionUnderneath() {
        return new BlockPos(this.positionVec.x, this.getBoundingBox().minY - 0.5000001D, this.positionVec.z);
    }

    protected Vector3d maybeBackOffFromEdge(Vector3d vec, MoverType mover) {
        return vec;
    }

    protected Vector3d handlePistonMovement(Vector3d pos) {
        if (pos.lengthSquared() <= 1.0E-7D) {
            return pos;
        } else {
            long i = this.world.getGameTime();

            if (i != this.pistonDeltasGameTime) {
                Arrays.fill(this.pistonDeltas, 0.0D);
                this.pistonDeltasGameTime = i;
            }

            if (pos.x != 0.0D) {
                double d2 = this.calculatePistonDeltas(Direction.Axis.X, pos.x);
                return Math.abs(d2) <= (double) 1.0E-5F ? Vector3d.ZERO : new Vector3d(d2, 0.0D, 0.0D);
            } else if (pos.y != 0.0D) {
                double d1 = this.calculatePistonDeltas(Direction.Axis.Y, pos.y);
                return Math.abs(d1) <= (double) 1.0E-5F ? Vector3d.ZERO : new Vector3d(0.0D, d1, 0.0D);
            } else if (pos.z != 0.0D) {
                double d0 = this.calculatePistonDeltas(Direction.Axis.Z, pos.z);
                return Math.abs(d0) <= (double) 1.0E-5F ? Vector3d.ZERO : new Vector3d(0.0D, 0.0D, d0);
            } else {
                return Vector3d.ZERO;
            }
        }
    }

    private double calculatePistonDeltas(Direction.Axis axis, double distance) {
        int i = axis.ordinal();
        double d0 = MathHelper.clamp(distance + this.pistonDeltas[i], -0.51D, 0.51D);
        distance = d0 - this.pistonDeltas[i];
        this.pistonDeltas[i] = d0;
        return distance;
    }

    /**
     * Given a motion vector, return an updated vector that takes into account restrictions such as collisions (from all
     * directions) and step-up from stepHeight
     */
    private Vector3d getAllowedMovement(Vector3d vec, boolean hor, boolean ver) {
        AxisAlignedBB axisalignedbb = this.getBoundingBox();
        ISelectionContext iselectioncontext = ISelectionContext.forEntity(this);
        VoxelShape voxelshape = this.world.getWorldBorder().getShape();
        Stream<VoxelShape> stream = VoxelShapes.compare(voxelshape, VoxelShapes.create(axisalignedbb.shrink(1.0E-7D)), IBooleanFunction.AND) ? Stream.empty() : Stream.of(voxelshape);
        Stream<VoxelShape> stream1 = this.world.func_230318_c_(this, axisalignedbb.expand(vec), (p_233561_0_) ->
        {
            return true;
        });
        ReuseableStream<VoxelShape> reuseablestream = new ReuseableStream<>(Stream.concat(stream1, stream));
        Vector3d vector3d = vec.lengthSquared() == 0.0D ? vec : collideBoundingBoxHeuristically(this, vec, axisalignedbb, this.world, iselectioncontext, reuseablestream, hor, ver);
        boolean flag = vec.x != vector3d.x;
        boolean flag1 = vec.y != vector3d.y;
        boolean flag2 = vec.z != vector3d.z;
        boolean flag3 = this.onGround || flag1 && vec.y < 0.0D;
        if (flag3 && (flag || flag2)) {
            float stepHeight = this.stepHeight;
            EventStep step = new EventStep(this.stepHeight);
            if (this instanceof ClientPlayerEntity e) {
                EventManager.call(step);
                stepHeight = step.stepHeight;
            }

            if (stepHeight > 0.0F) {
                Vector3d vector3d1 = collideBoundingBoxHeuristically(this, new Vector3d(vec.x, (double) stepHeight, vec.z), axisalignedbb, this.world, iselectioncontext, reuseablestream, hor, ver);
                Vector3d vector3d2 = collideBoundingBoxHeuristically(this, new Vector3d(0.0D, (double) stepHeight, 0.0D), axisalignedbb.expand(vec.x, 0.0D, vec.z), this.world, iselectioncontext, reuseablestream, hor, ver);

                if (vector3d2.y < (double) stepHeight) {
                    Vector3d vector3d3 = collideBoundingBoxHeuristically(this, new Vector3d(vec.x, 0.0D, vec.z), axisalignedbb.offset(vector3d2), this.world, iselectioncontext, reuseablestream, hor, ver).add(vector3d2);

                    if (horizontalMag(vector3d3) > horizontalMag(vector3d1)) {
                        vector3d1 = vector3d3;
                    }
                }

                if (horizontalMag(vector3d1) > horizontalMag(vector3d)) {
                    return vector3d1.add(collideBoundingBoxHeuristically(this, new Vector3d(0.0D, -vector3d1.y + vec.y, 0.0D), axisalignedbb.offset(vector3d1), this.world, iselectioncontext, reuseablestream, hor, ver));
                }
            }
        }

        return vector3d;
    }

    public static double horizontalMag(Vector3d vec) {
        return vec.x * vec.x + vec.z * vec.z;
    }

    public static Vector3d collideBoundingBoxHeuristically(@Nullable Entity entity, Vector3d vec, AxisAlignedBB collisionBox, World world, ISelectionContext context, ReuseableStream<VoxelShape> potentialHits, boolean hor, boolean ver) {
        boolean flag = vec.x == 0.0D;
        boolean flag1 = vec.y == 0.0D;
        boolean flag2 = vec.z == 0.0D;

        if ((!flag || !flag1) && (!flag || !flag2) && (!flag1 || !flag2)) {
            ReuseableStream<VoxelShape> reuseablestream = new ReuseableStream<>(Stream.concat(potentialHits.createStream(), world.getCollisionShapes(entity, collisionBox.expand(vec))));
            return collideBoundingBox(vec, collisionBox, reuseablestream, hor, ver);
        } else {
            return getAllowedMovement(vec, collisionBox, world, context, potentialHits);
        }
    }

    public static Vector3d collideBoundingBox(Vector3d vec, AxisAlignedBB collisionBox, ReuseableStream<VoxelShape> potentialHits, boolean hor, boolean ver) {
        double d0 = vec.x;
        double d1 = vec.y;
        double d2 = vec.z;
        if (!ver) {
            if (d1 != 0.0D) {
                d1 = VoxelShapes.getAllowedOffset(Direction.Axis.Y, collisionBox, potentialHits.createStream(), d1);

                if (d1 != 0.0D) {
                    collisionBox = collisionBox.offset(0.0D, d1, 0.0D);
                }
            }
        }
        if (!hor) {
            boolean flag = Math.abs(d0) < Math.abs(d2);

            if (flag && d2 != 0.0D) {
                d2 = VoxelShapes.getAllowedOffset(Direction.Axis.Z, collisionBox, potentialHits.createStream(), d2);

                if (d2 != 0.0D) {
                    collisionBox = collisionBox.offset(0.0D, 0.0D, d2);
                }
            }

            if (d0 != 0.0D) {
                d0 = VoxelShapes.getAllowedOffset(Direction.Axis.X, collisionBox, potentialHits.createStream(), d0);

                if (!flag && d0 != 0.0D) {
                    collisionBox = collisionBox.offset(d0, 0.0D, 0.0D);
                }
            }

            if (!flag && d2 != 0.0D) {
                d2 = VoxelShapes.getAllowedOffset(Direction.Axis.Z, collisionBox, potentialHits.createStream(), d2);
            }
        }

        return new Vector3d(d0, d1, d2);
    }

    public static Vector3d getAllowedMovement(Vector3d vec, AxisAlignedBB collisionBox, IWorldReader worldIn, ISelectionContext selectionContext, ReuseableStream<VoxelShape> potentialHits) {
        double d0 = vec.x;
        double d1 = vec.y;
        double d2 = vec.z;

        if (d1 != 0.0D) {
            d1 = VoxelShapes.getAllowedOffset(Direction.Axis.Y, collisionBox, worldIn, d1, selectionContext, potentialHits.createStream());

            if (d1 != 0.0D) {
                collisionBox = collisionBox.offset(0.0D, d1, 0.0D);
            }
        }

        boolean flag = Math.abs(d0) < Math.abs(d2);

        if (flag && d2 != 0.0D) {
            d2 = VoxelShapes.getAllowedOffset(Direction.Axis.Z, collisionBox, worldIn, d2, selectionContext, potentialHits.createStream());

            if (d2 != 0.0D) {
                collisionBox = collisionBox.offset(0.0D, 0.0D, d2);
            }
        }

        if (d0 != 0.0D) {
            d0 = VoxelShapes.getAllowedOffset(Direction.Axis.X, collisionBox, worldIn, d0, selectionContext, potentialHits.createStream());

            if (!flag && d0 != 0.0D) {
                collisionBox = collisionBox.offset(d0, 0.0D, 0.0D);
            }
        }

        if (!flag && d2 != 0.0D) {
            d2 = VoxelShapes.getAllowedOffset(Direction.Axis.Z, collisionBox, worldIn, d2, selectionContext, potentialHits.createStream());
        }

        return new Vector3d(d0, d1, d2);
    }

    protected float determineNextStepDistance() {
        return (float) ((int) this.distanceWalkedOnStepModified + 1);
    }

    /**
     * Resets the entity's position to the center (planar) and bottom (vertical) points of its bounding box.
     */
    public void resetPositionToBB() {
        AxisAlignedBB axisalignedbb = this.getBoundingBox();
        this.setRawPosition((axisalignedbb.minX + axisalignedbb.maxX) / 2.0D, axisalignedbb.minY, (axisalignedbb.minZ + axisalignedbb.maxZ) / 2.0D);
    }

    protected SoundEvent getSwimSound() {
        return SoundEvents.ENTITY_GENERIC_SWIM;
    }

    protected SoundEvent getSplashSound() {
        return SoundEvents.ENTITY_GENERIC_SPLASH;
    }

    protected SoundEvent getHighspeedSplashSound() {
        return SoundEvents.ENTITY_GENERIC_SPLASH;
    }

    protected void doBlockCollisions() {
        AxisAlignedBB axisalignedbb = this.getBoundingBox();
        BlockPos blockpos = new BlockPos(axisalignedbb.minX + 0.001D, axisalignedbb.minY + 0.001D, axisalignedbb.minZ + 0.001D);
        BlockPos blockpos1 = new BlockPos(axisalignedbb.maxX - 0.001D, axisalignedbb.maxY - 0.001D, axisalignedbb.maxZ - 0.001D);
        BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();

        if (this.world.isAreaLoaded(blockpos, blockpos1)) {
            for (int i = blockpos.getX(); i <= blockpos1.getX(); ++i) {
                for (int j = blockpos.getY(); j <= blockpos1.getY(); ++j) {
                    for (int k = blockpos.getZ(); k <= blockpos1.getZ(); ++k) {
                        blockpos$mutable.setPos(i, j, k);
                        BlockState blockstate = this.world.getBlockState(blockpos$mutable);

                        try {
                            blockstate.onEntityCollision(this.world, blockpos$mutable, this);
                            this.onInsideBlock(blockstate);
                        } catch (Throwable throwable) {
                            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Colliding entity with block");
                            CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being collided with");
                            CrashReportCategory.addBlockInfo(crashreportcategory, blockpos$mutable, blockstate);
                            throw new ReportedException(crashreport);
                        }
                    }
                }
            }
        }
    }

    protected void onInsideBlock(BlockState state) {
    }

    protected void playStepSound(BlockPos pos, BlockState blockIn) {
        if (!blockIn.getMaterial().isLiquid()) {
            BlockState blockstate = this.world.getBlockState(pos.up());
            SoundType soundtype = blockstate.isIn(Blocks.SNOW) ? blockstate.getSoundType() : blockIn.getSoundType();
            this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
        }
    }

    protected void playSwimSound(float volume) {
        this.playSound(this.getSwimSound(), volume, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
    }

    protected float playFlySound(float volume) {
        return 0.0F;
    }

    protected boolean makeFlySound() {
        return false;
    }

    public void playSound(SoundEvent soundIn, float volume, float pitch) {
        if (!this.isSilent()) {
            this.world.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), soundIn, this.getSoundCategory(), volume, pitch);
        }
    }

    /**
     * @return True if this entity will not play sounds
     */
    public boolean isSilent() {
        return this.dataManager.get(SILENT);
    }

    /**
     * When set to true the entity will not play sounds.
     */
    public void setSilent(boolean isSilent) {
        this.dataManager.set(SILENT, isSilent);
    }

    public boolean hasNoGravity() {
        return this.dataManager.get(NO_GRAVITY);
    }

    public void setNoGravity(boolean noGravity) {
        this.dataManager.set(NO_GRAVITY, noGravity);
    }

    protected boolean canTriggerWalking() {
        return true;
    }

    protected void updateFallState(double y, boolean onGroundIn, BlockState state, BlockPos pos) {
        if (onGroundIn) {
            if (this.fallDistance > 0.0F) {
                state.getBlock().onFallenUpon(this.world, pos, this, this.fallDistance);
            }

            this.fallDistance = 0.0F;
        } else if (y < 0.0D) {
            this.fallDistance = (float) ((double) this.fallDistance - y);
        }
    }

    public boolean isImmuneToFire() {
        return this.getType().isImmuneToFire();
    }

    public boolean onLivingFall(float distance, float damageMultiplier) {
        if (this.isBeingRidden()) {
            for (Entity entity : this.getPassengers()) {
                entity.onLivingFall(distance, damageMultiplier);
            }
        }

        return false;
    }

    /**
     * Checks if this entity is inside water (if inWater field is true as a result of handleWaterMovement() returning
     * true)
     */
    public boolean isInWater() {
        return this.inWater;
    }

    private boolean isInRain() {
        BlockPos blockpos = this.getPosition();
        return this.world.isRainingAt(blockpos) || this.world.isRainingAt(new BlockPos((double) blockpos.getX(), this.getBoundingBox().maxY, (double) blockpos.getZ()));
    }

    private boolean isInBubbleColumn() {
        return this.world.getBlockState(this.getPosition()).isIn(Blocks.BUBBLE_COLUMN);
    }

    /**
     * Checks if this entity is either in water or on an open air block in rain (used in wolves).
     */
    public boolean isWet() {
        return this.isInWater() || this.isInRain();
    }

    public boolean isInWaterRainOrBubbleColumn() {
        return this.isInWater() || this.isInRain() || this.isInBubbleColumn();
    }

    public boolean isInWaterOrBubbleColumn() {
        return this.isInWater() || this.isInBubbleColumn();
    }

    public boolean canSwim() {
        return this.eyesInWater && this.isInWater();
    }

    public void updateSwimming() {
        if (this.isSwimming()) {
            this.setSwimming(this.isSprinting() && this.isInWater() && !this.isPassenger());
        } else {
            this.setSwimming(this.isSprinting() && this.canSwim() && !this.isPassenger());
        }
    }

    protected boolean func_233566_aG_() {
        this.eyesFluidLevel.clear();
        this.func_233567_aH_();
        double d0 = this.world.getDimensionType().isUltrawarm() ? 0.007D : 0.0023333333333333335D;
        boolean flag = this.handleFluidAcceleration(FluidTags.LAVA, d0);
        return this.isInWater() || flag;
    }

    void func_233567_aH_() {
        if (this.getRidingEntity() instanceof BoatEntity) {
            this.inWater = false;
        } else if (this.handleFluidAcceleration(FluidTags.WATER, 0.014D)) {
            if (!this.inWater && !this.firstUpdate) {
                this.doWaterSplashEffect();
            }

            this.fallDistance = 0.0F;
            this.inWater = true;
            this.extinguish();
        } else {
            this.inWater = false;
        }
    }

    private void updateEyesInWater() {
        this.eyesInWater = this.areEyesInFluid(FluidTags.WATER);
        this.field_241335_O_ = null;
        double d0 = this.getPosYEye() - (double) 0.11111111F;
        Entity entity = this.getRidingEntity();

        if (entity instanceof BoatEntity) {
            BoatEntity boatentity = (BoatEntity) entity;

            if (!boatentity.canSwim() && boatentity.getBoundingBox().maxY >= d0 && boatentity.getBoundingBox().minY <= d0) {
                return;
            }
        }

        BlockPos blockpos = new BlockPos(this.getPosX(), d0, this.getPosZ());
        FluidState fluidstate = this.world.getFluidState(blockpos);

        for (ITag<Fluid> itag : FluidTags.getAllTags()) {
            if (fluidstate.isTagged(itag)) {
                double d1 = (double) ((float) blockpos.getY() + fluidstate.getActualHeight(this.world, blockpos));

                if (d1 > d0) {
                    this.field_241335_O_ = itag;
                }

                return;
            }
        }
    }

    /**
     * Plays the {@link #getSplashSound() splash sound}, and the {@link ParticleType#WATER_BUBBLE} and {@link
     * ParticleType#WATER_SPLASH} particles.
     */
    protected void doWaterSplashEffect() {
        Entity entity = this.isBeingRidden() && this.getControllingPassenger() != null ? this.getControllingPassenger() : this;
        float f = entity == this ? 0.2F : 0.9F;
        Vector3d vector3d = entity.getMotion();
        float f1 = MathHelper.sqrt(vector3d.x * vector3d.x * (double) 0.2F + vector3d.y * vector3d.y + vector3d.z * vector3d.z * (double) 0.2F) * f;

        if (f1 > 1.0F) {
            f1 = 1.0F;
        }

        if ((double) f1 < 0.25D) {
            this.playSound(this.getSplashSound(), f1, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
        } else {
            this.playSound(this.getHighspeedSplashSound(), f1, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
        }

        float f2 = (float) MathHelper.floor(this.getPosY());

        for (int i = 0; (float) i < 1.0F + this.size.width * 20.0F; ++i) {
            double d0 = (this.rand.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
            double d1 = (this.rand.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
            this.world.addParticle(ParticleTypes.BUBBLE, this.getPosX() + d0, (double) (f2 + 1.0F), this.getPosZ() + d1, vector3d.x, vector3d.y - this.rand.nextDouble() * (double) 0.2F, vector3d.z);
        }

        for (int j = 0; (float) j < 1.0F + this.size.width * 20.0F; ++j) {
            double d2 = (this.rand.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
            double d3 = (this.rand.nextDouble() * 2.0D - 1.0D) * (double) this.size.width;
            this.world.addParticle(ParticleTypes.SPLASH, this.getPosX() + d2, (double) (f2 + 1.0F), this.getPosZ() + d3, vector3d.x, vector3d.y, vector3d.z);
        }
    }

    protected BlockState getStateBelow() {
        return this.world.getBlockState(this.getOnPosition());
    }

    public boolean func_230269_aK_() {
        return this.isSprinting() && !this.isInWater() && !this.isSpectator() && !this.isCrouching() && !this.isInLava() && this.isAlive();
    }

    protected void func_233569_aL_() {
        int i = MathHelper.floor(this.getPosX());
        int j = MathHelper.floor(this.getPosY() - (double) 0.2F);
        int k = MathHelper.floor(this.getPosZ());
        BlockPos blockpos = new BlockPos(i, j, k);
        BlockState blockstate = this.world.getBlockState(blockpos);

        if (blockstate.getRenderType() != BlockRenderType.INVISIBLE) {
            Vector3d vector3d = this.getMotion();
            this.world.addParticle(new BlockParticleData(ParticleTypes.BLOCK, blockstate), this.getPosX() + (this.rand.nextDouble() - 0.5D) * (double) this.size.width, this.getPosY() + 0.1D, this.getPosZ() + (this.rand.nextDouble() - 0.5D) * (double) this.size.width, vector3d.x * -4.0D, 1.5D, vector3d.z * -4.0D);
        }
    }

    public boolean areEyesInFluid(ITag<Fluid> tagIn) {
        return this.field_241335_O_ == tagIn;
    }

    public boolean isInLava() {
        return !this.firstUpdate && this.eyesFluidLevel.getDouble(FluidTags.LAVA) > 0.0D;
    }

    float yawRestore;

    public void moveRelative(float p_213309_1_, Vector3d relative) {

        this.yawRestore = this.rotationYaw;
        // noinspection ConstantConditions
        if (!ClientPlayerEntity.class.isInstance(this) || BaritoneAPI.getProvider().getBaritoneForPlayer((ClientPlayerEntity) (Object) this) == null) {
            return;
        }
        RotationMoveEvent motionUpdateRotationEvent = new RotationMoveEvent(RotationMoveEvent.Type.MOTION_UPDATE, this.rotationYaw);
        BaritoneAPI.getProvider().getBaritoneForPlayer((ClientPlayerEntity) (Object) this).getGameEventHandler().onPlayerRotationMove(motionUpdateRotationEvent);
        this.rotationYaw = motionUpdateRotationEvent.getYaw();

        if (Managment.FUNCTION_MANAGER.auraFunction.state && Managment.FUNCTION_MANAGER.auraFunction.settings.get(1)) {
            Vector3d vector3d = getAbsoluteMotion(relative, p_213309_1_, Managment.FUNCTION_MANAGER.auraFunction.rotate.x);
            this.setMotion(this.getMotion().add(vector3d));
            return;
        }
/*        if (Managment.FUNCTION_MANAGER.auraFunction.state && Managment.FUNCTION_MANAGER.auraFunction.correction.get()) {
            Vector3d vector3d = getAbsoluteMotion(relative, p_213309_1_, Managment.FUNCTION_MANAGER.auraFunction.rotate.x);
            this.setMotion(this.getMotion().add(vector3d));
            return;
        }*/

        if (Managment.FUNCTION_MANAGER.autoExplosionFunction.check()) {
            Vector3d vector3d = getAbsoluteMotion(relative, p_213309_1_, Managment.FUNCTION_MANAGER.autoExplosionFunction.server.x);
            this.setMotion(this.getMotion().add(vector3d));
            return;
        }
//        if (Managment.FUNCTION_MANAGER.scaffold.state && Managment.FUNCTION_MANAGER.scaffold.rotation != null) {
//            Vector3d vector3d = getAbsoluteMotion(relative, p_213309_1_, Managment.FUNCTION_MANAGER.scaffold.rotation.x);
//            this.setMotion(this.getMotion().add(vector3d));
//            return;
//        }

        EventStrafe eventStrafe = new EventStrafe(this.rotationYaw);
        EventManager.call(eventStrafe);


        Vector3d vector3d = getAbsoluteMotion(relative, p_213309_1_, eventStrafe.yaw);
        this.setMotion(this.getMotion().add(vector3d));

        this.rotationYaw = this.yawRestore;
    }

    private static Vector3d getAbsoluteMotion(Vector3d relative, float p_213299_1_, float facing) {
        double d0 = relative.lengthSquared();

        if (d0 < 1.0E-7D) {
            return Vector3d.ZERO;
        } else {
            Vector3d vector3d = (d0 > 1.0D ? relative.normalize() : relative).scale((double) p_213299_1_);
            float f = MathHelper.sin(facing * ((float) Math.PI / 180F));
            float f1 = MathHelper.cos(facing * ((float) Math.PI / 180F));
            return new Vector3d(vector3d.x * (double) f1 - vector3d.z * (double) f, vector3d.y, vector3d.z * (double) f1 + vector3d.x * (double) f);
        }
    }

    /**
     * Gets how bright this entity is.
     */
    public float getBrightness() {
        BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable(this.getPosX(), 0.0D, this.getPosZ());

        if (this.world.isBlockLoaded(blockpos$mutable)) {
            blockpos$mutable.setY(MathHelper.floor(this.getPosYEye()));
            return this.world.getBrightness(blockpos$mutable);
        } else {
            return 0.0F;
        }
    }

    /**
     * Sets the reference to the World object.
     */
    public void setWorld(World worldIn) {
        this.world = worldIn;
    }

    /**
     * Sets position and rotation, clamping and wrapping params to valid values. Used by network code.
     */
    public void setPositionAndRotation(double x, double y, double z, float yaw, float pitch) {
        this.func_242281_f(x, y, z);
        this.rotationYaw = yaw % 360.0F;
        this.rotationPitch = MathHelper.clamp(pitch, -90.0F, 90.0F) % 360.0F;
        this.prevRotationYaw = this.rotationYaw;
        this.prevRotationPitch = this.rotationPitch;
    }

    public void func_242281_f(double p_242281_1_, double p_242281_3_, double p_242281_5_) {
        double d0 = MathHelper.clamp(p_242281_1_, -3.0E7D, 3.0E7D);
        double d1 = MathHelper.clamp(p_242281_5_, -3.0E7D, 3.0E7D);
        this.prevPosX = d0;
        this.prevPosY = p_242281_3_;
        this.prevPosZ = d1;
        this.setPosition(d0, p_242281_3_, d1);
    }

    public void moveForced(Vector3d vec) {
        this.moveForced(vec.x, vec.y, vec.z);
    }

    public void moveForced(double x, double y, double z) {
        this.setLocationAndAngles(x, y, z, this.rotationYaw, this.rotationPitch);
    }

    public void moveToBlockPosAndAngles(BlockPos pos, float rotationYawIn, float rotationPitchIn) {
        this.setLocationAndAngles((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D, rotationYawIn, rotationPitchIn);
    }

    /**
     * Sets the location and Yaw/Pitch of an entity in the world
     */
    public void setLocationAndAngles(double x, double y, double z, float yaw, float pitch) {
        this.forceSetPosition(x, y, z);
        this.rotationYaw = yaw;
        this.rotationPitch = pitch;
        this.recenterBoundingBox();
    }

    /**
     * Like {@link #setRawPosition}, but also sets {@link #prevPosX}/Y/Z and {@link #lastTickPosX}/Y/Z. {@link
     * #setLocationAndAngles} does the same thing, except it also updates the bounding box.
     */
    public void forceSetPosition(double x, double y, double z) {
        this.setRawPosition(x, y, z);
        this.prevPosX = x;
        this.prevPosY = y;
        this.prevPosZ = z;
        this.lastTickPosX = x;
        this.lastTickPosY = y;
        this.lastTickPosZ = z;
    }

    /**
     * Returns the distance to the entity.
     */
    public float getDistance(Entity entityIn) {
        float f = (float) (this.getPosX() - entityIn.getPosX());
        float f1 = (float) (this.getPosY() - entityIn.getPosY());
        float f2 = (float) (this.getPosZ() - entityIn.getPosZ());
        return MathHelper.sqrt(f * f + f1 * f1 + f2 * f2);
    }

    public double getDistanceToEntityEye(Entity entity) {
        final double razY = MathHelper.clamp(((this.getPosY() + this.getEyeHeight()) - entity.getPosY()), 0, entity.getHeight());
        final double poleWidth = entity.getWidth() / 2;
        final double razX = MathHelper.clamp(this.getPosX() - entity.getPosX(), -poleWidth, poleWidth);
        final double razZ = MathHelper.clamp(this.getPosZ() - entity.getPosZ(), -poleWidth, poleWidth);
        return this.getEyePosition(1F).distanceTo(entity.getPositionVec().add(razX, razY, razZ));
    }

    /**
     * Gets the squared distance to the position.
     */
    public double getDistanceSq(double x, double y, double z) {
        double d0 = this.getPosX() - x;
        double d1 = this.getPosY() - y;
        double d2 = this.getPosZ() - z;
        return d0 * d0 + d1 * d1 + d2 * d2;
    }

    /**
     * Returns the squared distance to the entity.
     */
    public double getDistanceSq(Entity entityIn) {
        return this.getDistanceSq(entityIn.getPositionVec());
    }

    public double getDistanceSq(Vector3d vec) {
        double d0 = this.getPosX() - vec.x;
        double d1 = this.getPosY() - vec.y;
        double d2 = this.getPosZ() - vec.z;
        return d0 * d0 + d1 * d1 + d2 * d2;
    }

    /**
     * Called by a player entity when they collide with an entity
     */
    public void onCollideWithPlayer(PlayerEntity entityIn) {
    }

    /**
     * Applies a velocity to the entities, to push them away from eachother.
     */
    public void applyEntityCollision(Entity entityIn) {
        if (!this.isRidingSameEntity(entityIn)) {
            if (!entityIn.noClip && !this.noClip) {
                double d0 = entityIn.getPosX() - this.getPosX();
                double d1 = entityIn.getPosZ() - this.getPosZ();
                double d2 = MathHelper.absMax(d0, d1);

                if (d2 >= (double) 0.01F) {
                    d2 = (double) MathHelper.sqrt(d2);
                    d0 = d0 / d2;
                    d1 = d1 / d2;
                    double d3 = 1.0D / d2;

                    if (d3 > 1.0D) {
                        d3 = 1.0D;
                    }

                    d0 = d0 * d3;
                    d1 = d1 * d3;
                    d0 = d0 * (double) 0.05F;
                    d1 = d1 * (double) 0.05F;
                    d0 = d0 * (double) (1.0F - this.entityCollisionReduction);
                    d1 = d1 * (double) (1.0F - this.entityCollisionReduction);

                    if (!this.isBeingRidden()) {
                        this.addVelocity(-d0, 0.0D, -d1);
                    }

                    if (!entityIn.isBeingRidden()) {
                        entityIn.addVelocity(d0, 0.0D, d1);
                    }
                }
            }
        }
    }

    /**
     * Adds to the current velocity of the entity, and sets {@link #isAirBorne} to true.
     */
    public void addVelocity(double x, double y, double z) {
        this.setMotion(this.getMotion().add(x, y, z));
        this.isAirBorne = true;
    }

    /**
     * Marks this entity's velocity as changed, so that it can be re-synced with the client later
     */
    protected void markVelocityChanged() {
        this.velocityChanged = true;
    }

    /**
     * Called when the entity is attacked.
     */
    public boolean attackEntityFrom(DamageSource source, float amount) {
        if (this.isInvulnerableTo(source)) {
            return false;
        } else {
            this.markVelocityChanged();
            return false;
        }
    }

    /**
     * interpolated look vector
     */
    public final Vector3d getLook(float partialTicks) {
        return this.getVectorForRotation(this.getPitch(partialTicks), this.getYaw(partialTicks));
    }

    /**
     * Gets the current pitch of the entity.
     */
    public float getPitch(float partialTicks) {
        return partialTicks == 1.0F ? this.rotationPitch : MathHelper.lerp(partialTicks, this.prevRotationPitch, this.rotationPitch);
    }

    /**
     * Gets the current yaw of the entity
     */
    public float getYaw(float partialTicks) {
        return partialTicks == 1.0F ? this.rotationYaw : MathHelper.lerp(partialTicks, this.prevRotationYaw, this.rotationYaw);
    }

    /**
     * Creates a Vec3 using the pitch and yaw of the entities rotation.
     */
    protected final Vector3d getVectorForRotation(float pitch, float yaw) {
        float f = pitch * ((float) Math.PI / 180F);
        float f1 = -yaw * ((float) Math.PI / 180F);
        float f2 = MathHelper.cos(f1);
        float f3 = MathHelper.sin(f1);
        float f4 = MathHelper.cos(f);
        float f5 = MathHelper.sin(f);
        return new Vector3d((double) (f3 * f4), (double) (-f5), (double) (f2 * f4));
    }

    public final Vector3d getUpVector(float partialTicks) {
        return this.calculateUpVector(this.getPitch(partialTicks), this.getYaw(partialTicks));
    }

    protected final Vector3d calculateUpVector(float pitch, float yaw) {
        return this.getVectorForRotation(pitch - 90.0F, yaw);
    }

    public final Vector3d getEyePosition(float partialTicks) {
        if (partialTicks == 1.0F) {
            return new Vector3d(this.getPosX(), this.getPosYEye(), this.getPosZ());
        } else {
            double d0 = MathHelper.lerp((double) partialTicks, this.prevPosX, this.getPosX());
            double d1 = MathHelper.lerp((double) partialTicks, this.prevPosY, this.getPosY()) + (double) this.getEyeHeight();
            double d2 = MathHelper.lerp((double) partialTicks, this.prevPosZ, this.getPosZ());
            return new Vector3d(d0, d1, d2);
        }
    }

    public Vector3d func_241842_k(float p_241842_1_) {
        return this.getEyePosition(p_241842_1_);
    }

    public final Vector3d func_242282_l(float p_242282_1_) {
        double d0 = MathHelper.lerp((double) p_242282_1_, this.prevPosX, this.getPosX());
        double d1 = MathHelper.lerp((double) p_242282_1_, this.prevPosY, this.getPosY());
        double d2 = MathHelper.lerp((double) p_242282_1_, this.prevPosZ, this.getPosZ());
        return new Vector3d(d0, d1, d2);
    }

    public RayTraceResult pick(double rayTraceDistance, float partialTicks, boolean p_213324_4_) {
        Vector3d vector3d = this.getEyePosition(partialTicks);
        Vector3d vector3d1 = this.getLook(partialTicks);
        Vector3d vector3d2 = vector3d.add(vector3d1.x * rayTraceDistance, vector3d1.y * rayTraceDistance, vector3d1.z * rayTraceDistance);
        return this.world.rayTraceBlocks(new RayTraceContext(vector3d, vector3d2, RayTraceContext.BlockMode.OUTLINE, p_213324_4_ ? RayTraceContext.FluidMode.ANY : RayTraceContext.FluidMode.NONE, this));
    }

    /**
     * Returns true if other Entities should be prevented from moving through this Entity.
     */
    public boolean canBeCollidedWith() {
        return false;
    }

    /**
     * Returns true if this entity should push and be pushed by other entities when colliding.
     */
    public boolean canBePushed() {
        return false;
    }

    public void awardKillScore(Entity killed, int scoreValue, DamageSource damageSource) {
        if (killed instanceof ServerPlayerEntity) {
            CriteriaTriggers.ENTITY_KILLED_PLAYER.trigger((ServerPlayerEntity) killed, this, damageSource);
        }
    }

    public boolean isInRangeToRender3d(double x, double y, double z) {
        double d0 = this.getPosX() - x;
        double d1 = this.getPosY() - y;
        double d2 = this.getPosZ() - z;
        double d3 = d0 * d0 + d1 * d1 + d2 * d2;
        return this.isInRangeToRenderDist(d3);
    }

    /**
     * Checks if the entity is in range to render.
     */
    public boolean isInRangeToRenderDist(double distance) {
        double d0 = this.getBoundingBox().getAverageEdgeLength();

        if (Double.isNaN(d0)) {
            d0 = 1.0D;
        }

        d0 = d0 * 64.0D * renderDistanceWeight;
        return distance < d0 * d0;
    }

    /**
     * Writes this entity to NBT, unless it has been removed. Also writes this entity's passengers, and the entity type
     * ID (so the produced NBT is sufficient to recreate the entity).
     * <p>
     * Generally, {@link #writeUnlessPassenger} or {@link #writeWithoutTypeId} should be used instead of this method.
     *
     * @return True if the entity was written (and the passed compound should be saved); false if the entity was not
     * written.
     */
    public boolean writeUnlessRemoved(CompoundNBT compound) {
        String s = this.getEntityString();

        if (!this.removed && s != null) {
            compound.putString("id", s);
            this.writeWithoutTypeId(compound);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Writes this entity to NBT, unless it has been removed or it is a passenger. Also writes this entity's passengers,
     * and the entity type ID (so the produced NBT is sufficient to recreate the entity).
     * To always write the entity, use {@link #writeWithoutTypeId}.
     *
     * @return True if the entity was written (and the passed compound should be saved); false if the entity was not
     * written.
     */
    public boolean writeUnlessPassenger(CompoundNBT compound) {
        return this.isPassenger() ? false : this.writeUnlessRemoved(compound);
    }

    /**
     * Writes this entity, including passengers, to NBT, regardless as to whether or not it is removed or a passenger.
     * Does <b>not</b> include the entity's type ID, so the NBT is insufficient to recreate the entity using {@link
     * AnvilChunkLoader#readWorldEntity}. Use {@link #writeUnlessPassenger} for that purpose.
     */
    public CompoundNBT writeWithoutTypeId(CompoundNBT compound) {
        try {
            if (this.ridingEntity != null) {
                compound.put("Pos", this.newDoubleNBTList(this.ridingEntity.getPosX(), this.getPosY(), this.ridingEntity.getPosZ()));
            } else {
                compound.put("Pos", this.newDoubleNBTList(this.getPosX(), this.getPosY(), this.getPosZ()));
            }

            Vector3d vector3d = this.getMotion();
            compound.put("Motion", this.newDoubleNBTList(vector3d.x, vector3d.y, vector3d.z));
            compound.put("Rotation", this.newFloatNBTList(this.rotationYaw, this.rotationPitch));
            compound.putFloat("FallDistance", this.fallDistance);
            compound.putShort("Fire", (short) this.fire);
            compound.putShort("Air", (short) this.getAir());
            compound.putBoolean("OnGround", this.onGround);
            compound.putBoolean("Invulnerable", this.invulnerable);
            compound.putInt("PortalCooldown", this.field_242273_aw);
            compound.putUniqueId("UUID", this.getUniqueID());
            ITextComponent itextcomponent = this.getCustomName();

            if (itextcomponent != null) {
                compound.putString("CustomName", ITextComponent.Serializer.toJson(itextcomponent));
            }

            if (this.isCustomNameVisible()) {
                compound.putBoolean("CustomNameVisible", this.isCustomNameVisible());
            }

            if (this.isSilent()) {
                compound.putBoolean("Silent", this.isSilent());
            }

            if (this.hasNoGravity()) {
                compound.putBoolean("NoGravity", this.hasNoGravity());
            }

            if (this.glowing) {
                compound.putBoolean("Glowing", this.glowing);
            }

            if (!this.tags.isEmpty()) {
                ListNBT listnbt = new ListNBT();

                for (String s : this.tags) {
                    listnbt.add(StringNBT.valueOf(s));
                }

                compound.put("Tags", listnbt);
            }

            this.writeAdditional(compound);

            if (this.isBeingRidden()) {
                ListNBT listnbt1 = new ListNBT();

                for (Entity entity : this.getPassengers()) {
                    CompoundNBT compoundnbt = new CompoundNBT();

                    if (entity.writeUnlessRemoved(compoundnbt)) {
                        listnbt1.add(compoundnbt);
                    }
                }

                if (!listnbt1.isEmpty()) {
                    compound.put("Passengers", listnbt1);
                }
            }

            return compound;
        } catch (Throwable throwable) {
            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Saving entity NBT");
            CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being saved");
            this.fillCrashReport(crashreportcategory);
            throw new ReportedException(crashreport);
        }
    }

    /**
     * Reads the entity from NBT (calls an abstract helper method to read specialized data)
     */
    public void read(CompoundNBT compound) {
        try {
            ListNBT listnbt = compound.getList("Pos", 6);
            ListNBT listnbt1 = compound.getList("Motion", 6);
            ListNBT listnbt2 = compound.getList("Rotation", 5);
            double d0 = listnbt1.getDouble(0);
            double d1 = listnbt1.getDouble(1);
            double d2 = listnbt1.getDouble(2);
            this.setMotion(Math.abs(d0) > 10.0D ? 0.0D : d0, Math.abs(d1) > 10.0D ? 0.0D : d1, Math.abs(d2) > 10.0D ? 0.0D : d2);
            this.forceSetPosition(listnbt.getDouble(0), listnbt.getDouble(1), listnbt.getDouble(2));
            this.rotationYaw = listnbt2.getFloat(0);
            this.rotationPitch = listnbt2.getFloat(1);
            this.prevRotationYaw = this.rotationYaw;
            this.prevRotationPitch = this.rotationPitch;
            this.setRotationYawHead(this.rotationYaw);
            this.setRenderYawOffset(this.rotationYaw);
            this.fallDistance = compound.getFloat("FallDistance");
            this.fire = compound.getShort("Fire");
            this.setAir(compound.getShort("Air"));
            this.onGround = compound.getBoolean("OnGround");
            this.invulnerable = compound.getBoolean("Invulnerable");
            this.field_242273_aw = compound.getInt("PortalCooldown");

            if (compound.hasUniqueId("UUID")) {
                this.entityUniqueID = compound.getUniqueId("UUID");
                this.cachedUniqueIdString = this.entityUniqueID.toString();
            }

            if (Double.isFinite(this.getPosX()) && Double.isFinite(this.getPosY()) && Double.isFinite(this.getPosZ())) {
                if (Double.isFinite((double) this.rotationYaw) && Double.isFinite((double) this.rotationPitch)) {
                    this.recenterBoundingBox();
                    this.setRotation(this.rotationYaw, this.rotationPitch);

                    if (compound.contains("CustomName", 8)) {
                        String s = compound.getString("CustomName");

                        try {
                            this.setCustomName(ITextComponent.Serializer.getComponentFromJson(s));
                        } catch (Exception exception) {
                            LOGGER.warn("Failed to parse entity custom name {}", s, exception);
                        }
                    }

                    this.setCustomNameVisible(compound.getBoolean("CustomNameVisible"));
                    this.setSilent(compound.getBoolean("Silent"));
                    this.setNoGravity(compound.getBoolean("NoGravity"));
                    this.setGlowing(compound.getBoolean("Glowing"));

                    if (compound.contains("Tags", 9)) {
                        this.tags.clear();
                        ListNBT listnbt3 = compound.getList("Tags", 8);
                        int i = Math.min(listnbt3.size(), 1024);

                        for (int j = 0; j < i; ++j) {
                            this.tags.add(listnbt3.getString(j));
                        }
                    }

                    this.readAdditional(compound);

                    if (this.shouldSetPosAfterLoading()) {
                        this.recenterBoundingBox();
                    }
                } else {
                    throw new IllegalStateException("Entity has invalid rotation");
                }
            } else {
                throw new IllegalStateException("Entity has invalid position");
            }
        } catch (Throwable throwable) {
            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Loading entity NBT");
            CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being loaded");
            this.fillCrashReport(crashreportcategory);
            throw new ReportedException(crashreport);
        }
    }

    protected boolean shouldSetPosAfterLoading() {
        return true;
    }

    @Nullable

    /**
     * Returns the string that identifies this Entity's class
     */
    protected final String getEntityString() {
        EntityType<?> entitytype = this.getType();
        ResourceLocation resourcelocation = EntityType.getKey(entitytype);
        return entitytype.isSerializable() && resourcelocation != null ? resourcelocation.toString() : null;
    }

    /**
     * (abstract) Protected helper method to read subclass entity data from NBT.
     */
    protected abstract void readAdditional(CompoundNBT compound);

    protected abstract void writeAdditional(CompoundNBT compound);

    /**
     * creates a NBT list from the array of doubles passed to this function
     */
    protected ListNBT newDoubleNBTList(double... numbers) {
        ListNBT listnbt = new ListNBT();

        for (double d0 : numbers) {
            listnbt.add(DoubleNBT.valueOf(d0));
        }

        return listnbt;
    }

    /**
     * Returns a new NBTTagList filled with the specified floats
     */
    protected ListNBT newFloatNBTList(float... numbers) {
        ListNBT listnbt = new ListNBT();

        for (float f : numbers) {
            listnbt.add(FloatNBT.valueOf(f));
        }

        return listnbt;
    }

    @Nullable
    public ItemEntity entityDropItem(IItemProvider itemIn) {
        return this.entityDropItem(itemIn, 0);
    }

    @Nullable
    public ItemEntity entityDropItem(IItemProvider itemIn, int offset) {
        return this.entityDropItem(new ItemStack(itemIn), (float) offset);
    }

    @Nullable
    public ItemEntity entityDropItem(ItemStack stack) {
        return this.entityDropItem(stack, 0.0F);
    }

    @Nullable

    /**
     * Drops an item at the position of the entity.
     */
    public ItemEntity entityDropItem(ItemStack stack, float offsetY) {
        if (stack.isEmpty()) {
            return null;
        } else if (this.world.isRemote) {
            return null;
        } else {
            ItemEntity itementity = new ItemEntity(this.world, this.getPosX(), this.getPosY() + (double) offsetY, this.getPosZ(), stack);
            itementity.setDefaultPickupDelay();
            this.world.addEntity(itementity);
            return itementity;
        }
    }

    /**
     * Returns true if the entity has not been {@link #removed}.
     */
    public boolean isAlive() {
        return !this.removed;
    }

    /**
     * Checks if this entity is inside of an opaque block
     */
    public boolean isEntityInsideOpaqueBlock() {

        if (this.noClip) {
            return false;
        } else {
            float f = 0.1F;
            float f1 = this.size.width * 0.8F;
            AxisAlignedBB axisalignedbb = AxisAlignedBB.withSizeAtOrigin((double) f1, (double) 0.1F, (double) f1).offset(this.getPosX(), this.getPosYEye(), this.getPosZ());
            return this.world.func_241457_a_(this, axisalignedbb, (p_241338_1_, p_241338_2_) ->
            {
                return p_241338_1_.isSuffocating(this.world, p_241338_2_);
            }).findAny().isPresent();
        }
    }

    public ActionResultType processInitialInteract(PlayerEntity player, Hand hand) {
        return ActionResultType.PASS;
    }

    public boolean canCollide(Entity entity) {
        return entity.func_241845_aY() && !this.isRidingSameEntity(entity);
    }

    public boolean func_241845_aY() {
        return false;
    }

    /**
     * Handles updating while riding another entity
     */
    public void updateRidden() {
        this.setMotion(Vector3d.ZERO);
        this.tick();

        if (this.isPassenger()) {
            this.getRidingEntity().updatePassenger(this);
        }
    }

    public void updatePassenger(Entity passenger) {
        this.positionRider(passenger, Entity::setPosition);
    }

    private void positionRider(Entity entity, IMoveCallback callback) {
        if (this.isPassenger(entity)) {
            double d0 = this.getPosY() + this.getMountedYOffset() + entity.getYOffset();
            callback.accept(entity, this.getPosX(), d0, this.getPosZ());
        }
    }

    /**
     * Applies this entity's orientation (pitch/yaw) to another entity. Used to update passenger orientation.
     */
    public void applyOrientationToEntity(Entity entityToUpdate) {
    }

    /**
     * Returns the Y Offset of this entity.
     */
    public double getYOffset() {
        return 0.0D;
    }

    /**
     * Returns the Y offset from the entity's position for any entity riding this one.
     */
    public double getMountedYOffset() {
        return (double) this.size.height * 0.75D;
    }

    public boolean startRiding(Entity entityIn) {
        return this.startRiding(entityIn, false);
    }

    public boolean isLiving() {
        return this instanceof LivingEntity;
    }

    public boolean startRiding(Entity entityIn, boolean force) {
        for (Entity entity = entityIn; entity.ridingEntity != null; entity = entity.ridingEntity) {
            if (entity.ridingEntity == this) {
                return false;
            }
        }

        if (force || this.canBeRidden(entityIn) && entityIn.canFitPassenger(this)) {
            if (this.isPassenger()) {
                this.stopRiding();
            }

            this.setPose(Pose.STANDING);
            this.ridingEntity = entityIn;
            this.ridingEntity.addPassenger(this);
            return true;
        } else {
            return false;
        }
    }

    protected boolean canBeRidden(Entity entityIn) {
        return !this.isSneaking() && this.rideCooldown <= 0;
    }

    protected boolean isPoseClear(Pose pose) {
        return this.world.hasNoCollisions(this, this.getBoundingBox(pose).shrink(1.0E-7D));
    }

    /**
     * Dismounts all entities riding this entity from this entity.
     */
    public void removePassengers() {
        for (int i = this.passengers.size() - 1; i >= 0; --i) {
            this.passengers.get(i).stopRiding();
        }
    }

    public void dismount() {
        if (this.ridingEntity != null) {
            Entity entity = this.ridingEntity;
            this.ridingEntity = null;
            entity.removePassenger(this);
        }
    }

    /**
     * Dismounts this entity from the entity it is riding.
     */
    public void stopRiding() {
        this.dismount();
    }

    protected void addPassenger(Entity passenger) {
        if (passenger.getRidingEntity() != this) {
            throw new IllegalStateException("Use x.startRiding(y), not y.addPassenger(x)");
        } else {
            if (!this.world.isRemote && passenger instanceof PlayerEntity && !(this.getControllingPassenger() instanceof PlayerEntity)) {
                this.passengers.add(0, passenger);
            } else {
                this.passengers.add(passenger);
            }
        }
    }

    protected void removePassenger(Entity passenger) {
        if (passenger.getRidingEntity() == this) {
            throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
        } else {
            this.passengers.remove(passenger);
            passenger.rideCooldown = 60;
        }
    }

    protected boolean canFitPassenger(Entity passenger) {
        return this.getPassengers().size() < 1;
    }

    /**
     * Sets a target for the client to interpolate towards over the next few ticks
     */
    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport) {
        this.setPosition(x, y, z);
        this.setRotation(yaw, pitch);
    }

    public void setHeadRotation(float yaw, int pitch) {
        this.setRotationYawHead(yaw);
    }

    public float getCollisionBorderSize() {
        HitBoxFunction hitBoxFunction = Managment.FUNCTION_MANAGER.hitBoxFunction;

        return hitBoxFunction.state && hitBoxFunction.invisible.get() ? hitBoxFunction.size.getValue().floatValue() : 0.0F;
    }

    /**
     * returns a (normalized) vector of where this entity is looking
     */
    public Vector3d getLookVec() {
        return this.getVectorForRotation(this.rotationPitch, this.rotationYaw);
    }

    /**
     * returns the Entity's pitch and yaw as a Vec2f
     */
    public Vector2f getPitchYaw() {
        return new Vector2f(this.rotationPitch, this.rotationYaw);
    }

    public Vector3d getForward() {
        return Vector3d.fromPitchYaw(this.getPitchYaw());
    }

    /**
     * Marks the entity as being inside a portal, activating teleportation logic in onEntityUpdate() in the following
     * tick(s).
     */
    public void setPortal(BlockPos pos) {
        if (this.func_242280_ah()) {
            this.func_242279_ag();
        } else {
            if (!this.world.isRemote && !pos.equals(this.field_242271_ac)) {
                this.field_242271_ac = pos.toImmutable();
            }

            this.inPortal = true;
        }
    }

    protected void updatePortal() {
        if (this.world instanceof ServerWorld) {
            int i = this.getMaxInPortalTime();
            ServerWorld serverworld = (ServerWorld) this.world;

            if (this.inPortal) {
                MinecraftServer minecraftserver = serverworld.getServer();
                RegistryKey<World> registrykey = this.world.getDimensionKey() == World.THE_NETHER ? World.OVERWORLD : World.THE_NETHER;
                ServerWorld serverworld1 = minecraftserver.getWorld(registrykey);

                if (serverworld1 != null && minecraftserver.getAllowNether() && !this.isPassenger() && this.portalCounter++ >= i) {
                    this.world.getProfiler().startSection("portal");
                    this.portalCounter = i;
                    this.func_242279_ag();
                    this.changeDimension(serverworld1);
                    this.world.getProfiler().endSection();
                }

                this.inPortal = false;
            } else {
                if (this.portalCounter > 0) {
                    this.portalCounter -= 4;
                }

                if (this.portalCounter < 0) {
                    this.portalCounter = 0;
                }
            }

            this.decrementTimeUntilPortal();
        }
    }

    /**
     * Return the amount of cooldown before this entity can use a portal again.
     */
    public int getPortalCooldown() {
        return 300;
    }

    /**
     * Updates the entity motion clientside, called by packets from the server
     */
    public void setVelocity(double x, double y, double z) {
        this.setMotion(x, y, z);
    }

    /**
     * Handler for {@link World#setEntityState}
     */
    public void handleStatusUpdate(byte id) {
        switch (id) {
            case 53:
                HoneyBlock.entitySlideParticles(this);

            default:
        }
    }

    /**
     * Setups the entity to do the hurt animation. Only used by packets in multiplayer.
     */
    public void performHurtAnimation() {
    }

    public Iterable<ItemStack> getHeldEquipment() {
        return EMPTY_EQUIPMENT;
    }

    public Iterable<ItemStack> getArmorInventoryList() {
        return EMPTY_EQUIPMENT;
    }

    public Iterable<ItemStack> getEquipmentAndArmor() {
        return Iterables.concat(this.getHeldEquipment(), this.getArmorInventoryList());
    }

    public void setItemStackToSlot(EquipmentSlotType slotIn, ItemStack stack) {
    }

    /**
     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.
     */
    public boolean isBurning() {
        boolean flag = this.world != null && this.world.isRemote;
        return !this.isImmuneToFire() && (this.fire > 0 || flag && this.getFlag(0));
    }

    public boolean isPassenger() {
        return this.getRidingEntity() != null;
    }

    /**
     * If at least 1 entity is riding this one
     */
    public boolean isBeingRidden() {
        return !this.getPassengers().isEmpty();
    }

    public boolean canBeRiddenInWater() {
        return true;
    }

    public void setSneaking(boolean keyDownIn) {
        this.setFlag(1, keyDownIn);
    }

    public boolean isSneaking() {
        return this.getFlag(1);
    }

    public boolean isSteppingCarefully() {
        return this.isSneaking();
    }

    public boolean isSuppressingBounce() {
        return this.isSneaking();
    }

    public boolean isDiscrete() {
        return this.isSneaking();
    }

    public boolean isDescending() {
        return this.isSneaking();
    }

    public boolean isCrouching() {
        return this.getPose() == Pose.CROUCHING;
    }

    /**
     * Get if the Entity is sprinting.
     */
    public boolean isSprinting() {
        return this.getFlag(3);
    }

    /**
     * Set sprinting switch for Entity.
     */
    public void setSprinting(boolean sprinting) {
        this.setFlag(3, sprinting);
    }

    public boolean isSwimming() {
        return this.getFlag(4);
    }

    public boolean isActualySwimming() {
        return this.getPose() == Pose.SWIMMING;
    }

    public boolean isVisuallySwimming() {
        return this.isActualySwimming() && !this.isInWater();
    }

    public void setSwimming(boolean swimming) {
        this.setFlag(4, swimming);
    }

    public boolean isGlowing() {
        return this.glowing || this.world.isRemote && this.getFlag(6);
    }

    public void setGlowing(boolean glowingIn) {
        this.glowing = glowingIn;

        if (!this.world.isRemote) {
            this.setFlag(6, this.glowing);
        }
    }

    public boolean isInvisible() {
        return this.getFlag(5);
    }

    /**
     * Only used by renderer in EntityLivingBase subclasses.
     * Determines if an entity is visible or not to a specific player, if the entity is normally invisible.
     * For EntityLivingBase subclasses, returning false when invisible will render the entity semi-transparent.
     */
    public boolean isInvisibleToPlayer(PlayerEntity player) {
        if (player.isSpectator()) {
            return false;
        } else {
            Team team = this.getTeam();
            return team != null && player != null && player.getTeam() == team && team.getSeeFriendlyInvisiblesEnabled() ? false : this.isInvisible();
        }
    }

    @Nullable
    public Team getTeam() {
        return this.world.getScoreboard().getPlayersTeam(this.getScoreboardName());
    }

    /**
     * Returns whether this Entity is on the same team as the given Entity.
     */
    public boolean isOnSameTeam(Entity entityIn) {
        return this.isOnScoreboardTeam(entityIn.getTeam());
    }

    /**
     * Returns whether this Entity is on the given scoreboard team.
     */
    public boolean isOnScoreboardTeam(Team teamIn) {
        return this.getTeam() != null ? this.getTeam().isSameTeam(teamIn) : false;
    }

    public void setInvisible(boolean invisible) {
        this.setFlag(5, invisible);
    }

    /**
     * Returns true if the flag is active for the entity. Known flags: 0: burning; 1: sneaking; 2: unused; 3: sprinting;
     * 4: swimming; 5: invisible; 6: glowing; 7: elytra flying
     */
    protected boolean getFlag(int flag) {
        return (this.dataManager.get(FLAGS) & 1 << flag) != 0;
    }

    /**
     * Enable or disable a entity flag, see getEntityFlag to read the know flags.
     */
    protected void setFlag(int flag, boolean set) {
        byte b0 = this.dataManager.get(FLAGS);
        if (set) {
            this.dataManager.set(FLAGS, (byte) (b0 | 1 << flag));
        } else {
            this.dataManager.set(FLAGS, (byte) (b0 & ~(1 << flag)));
        }
    }

    public int getMaxAir() {
        return 300;
    }

    public int getAir() {
        return this.dataManager.get(AIR);
    }

    public void setAir(int air) {
        this.dataManager.set(AIR, air);
    }

    public void func_241841_a(ServerWorld p_241841_1_, LightningBoltEntity p_241841_2_) {
        this.forceFireTicks(this.fire + 1);

        if (this.fire == 0) {
            this.setFire(8);
        }

        this.attackEntityFrom(DamageSource.LIGHTNING_BOLT, 5.0F);
    }

    public void onEnterBubbleColumnWithAirAbove(boolean downwards) {
        Vector3d vector3d = this.getMotion();
        double d0;

        if (downwards) {
            d0 = Math.max(-0.9D, vector3d.y - 0.03D);
        } else {
            d0 = Math.min(1.8D, vector3d.y + 0.1D);
        }

        this.setMotion(vector3d.x, d0, vector3d.z);
    }

    public void onEnterBubbleColumn(boolean downwards) {
        Vector3d vector3d = this.getMotion();
        double d0;

        if (downwards) {
            d0 = Math.max(-0.3D, vector3d.y - 0.03D);
        } else {
            d0 = Math.min(0.7D, vector3d.y + 0.06D);
        }

        this.setMotion(vector3d.x, d0, vector3d.z);
        this.fallDistance = 0.0F;
    }

    public void func_241847_a(ServerWorld p_241847_1_, LivingEntity p_241847_2_) {
    }

    protected void pushOutOfBlocks(double x, double y, double z) {
        BlockPos blockpos = new BlockPos(x, y, z);
        Vector3d vector3d = new Vector3d(x - (double) blockpos.getX(), y - (double) blockpos.getY(), z - (double) blockpos.getZ());
        BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();
        Direction direction = Direction.UP;
        double d0 = Double.MAX_VALUE;

        for (Direction direction1 : new Direction[]{Direction.NORTH, Direction.SOUTH, Direction.WEST, Direction.EAST, Direction.UP}) {
            blockpos$mutable.setAndMove(blockpos, direction1);

            if (!this.world.getBlockState(blockpos$mutable).hasOpaqueCollisionShape(this.world, blockpos$mutable)) {
                double d1 = vector3d.getCoordinate(direction1.getAxis());
                double d2 = direction1.getAxisDirection() == Direction.AxisDirection.POSITIVE ? 1.0D - d1 : d1;

                if (d2 < d0) {
                    d0 = d2;
                    direction = direction1;
                }
            }
        }
        float f = this.rand.nextFloat() * 0.2F + 0.1F;
        float f1 = (float) direction.getAxisDirection().getOffset();
        Vector3d vector3d1 = this.getMotion().scale(0.75D);

        if (direction.getAxis() == Direction.Axis.X) {
            this.setMotion((double) (f1 * f), vector3d1.y, vector3d1.z);
        } else if (direction.getAxis() == Direction.Axis.Y) {
            this.setMotion(vector3d1.x, (double) (f1 * f), vector3d1.z);
        } else if (direction.getAxis() == Direction.Axis.Z) {
            this.setMotion(vector3d1.x, vector3d1.y, (double) (f1 * f));
        }
    }

    public void setMotionMultiplier(BlockState state, Vector3d motionMultiplierIn) {
        this.fallDistance = 0.0F;
        this.motionMultiplier = motionMultiplierIn;
    }

    private static ITextComponent func_233573_b_(ITextComponent p_233573_0_) {
        IFormattableTextComponent iformattabletextcomponent = p_233573_0_.copyRaw().setStyle(p_233573_0_.getStyle().setClickEvent((ClickEvent) null));

        for (ITextComponent itextcomponent : p_233573_0_.getSiblings()) {
            iformattabletextcomponent.append(func_233573_b_(itextcomponent));
        }

        return iformattabletextcomponent;
    }

    public ITextComponent getName() {
        ITextComponent itextcomponent = this.getCustomName();
        return itextcomponent != null ? func_233573_b_(itextcomponent) : this.getProfessionName();
    }

    protected ITextComponent getProfessionName() {
        return this.type.getName();
    }

    /**
     * Returns true if Entity argument is equal to this Entity
     */
    public boolean isEntityEqual(Entity entityIn) {
        return this == entityIn;
    }

    public float getRotationYawHead() {
        return 0.0F;
    }

    /**
     * Sets the head's yaw rotation of the entity.
     */
    public void setRotationYawHead(float rotation) {
    }

    /**
     * Set the render yaw offset
     */
    public void setRenderYawOffset(float offset) {
    }

    /**
     * Returns true if it's possible to attack this entity with an item.
     */
    public boolean canBeAttackedWithItem() {
        return true;
    }

    /**
     * Called when a player attacks an entity. If this returns true the attack will not happen.
     */
    public boolean hitByEntity(Entity entityIn) {
        return false;
    }

    public String toString() {
        return String.format(Locale.ROOT, "%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]", this.getClass().getSimpleName(), this.getName().getString(), this.entityId, this.world == null ? "~NULL~" : this.world.toString(), this.getPosX(), this.getPosY(), this.getPosZ());
    }

    /**
     * Returns whether this Entity is invulnerable to the given DamageSource.
     */
    public boolean isInvulnerableTo(DamageSource source) {
        return this.invulnerable && source != DamageSource.OUT_OF_WORLD && !source.isCreativePlayer();
    }

    public boolean isInvulnerable() {
        return this.invulnerable;
    }

    /**
     * Sets whether this Entity is invulnerable.
     */
    public void setInvulnerable(boolean isInvulnerable) {
        this.invulnerable = isInvulnerable;
    }

    /**
     * Sets this entity's location and angles to the location and angles of the passed in entity.
     */
    public void copyLocationAndAnglesFrom(Entity entityIn) {
        this.setLocationAndAngles(entityIn.getPosX(), entityIn.getPosY(), entityIn.getPosZ(), entityIn.rotationYaw, entityIn.rotationPitch);
    }

    /**
     * Prepares this entity in new dimension by copying NBT data from entity in old dimension
     */
    public void copyDataFromOld(Entity entityIn) {
        CompoundNBT compoundnbt = entityIn.writeWithoutTypeId(new CompoundNBT());
        compoundnbt.remove("Dimension");
        this.read(compoundnbt);
        this.field_242273_aw = entityIn.field_242273_aw;
        this.field_242271_ac = entityIn.field_242271_ac;
    }

    @Nullable
    public Entity changeDimension(ServerWorld server) {
        if (this.world instanceof ServerWorld && !this.removed) {
            this.world.getProfiler().startSection("changeDimension");
            this.detach();
            this.world.getProfiler().startSection("reposition");
            PortalInfo portalinfo = this.func_241829_a(server);

            if (portalinfo == null) {
                return null;
            } else {
                this.world.getProfiler().endStartSection("reloading");
                Entity entity = this.getType().create(server);

                if (entity != null) {
                    entity.copyDataFromOld(this);
                    entity.setLocationAndAngles(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z, portalinfo.rotationYaw, entity.rotationPitch);
                    entity.setMotion(portalinfo.motion);
                    server.addFromAnotherDimension(entity);

                    if (server.getDimensionKey() == World.THE_END) {
                        ServerWorld.func_241121_a_(server);
                    }
                }

                this.setDead();
                this.world.getProfiler().endSection();
                ((ServerWorld) this.world).resetUpdateEntityTick();
                server.resetUpdateEntityTick();
                this.world.getProfiler().endSection();
                return entity;
            }
        } else {
            return null;
        }
    }

    protected void setDead() {
        this.removed = true;
    }

    @Nullable
    protected PortalInfo func_241829_a(ServerWorld p_241829_1_) {
        boolean flag = this.world.getDimensionKey() == World.THE_END && p_241829_1_.getDimensionKey() == World.OVERWORLD;
        boolean flag1 = p_241829_1_.getDimensionKey() == World.THE_END;

        if (!flag && !flag1) {
            boolean flag2 = p_241829_1_.getDimensionKey() == World.THE_NETHER;

            if (this.world.getDimensionKey() != World.THE_NETHER && !flag2) {
                return null;
            } else {
                WorldBorder worldborder = p_241829_1_.getWorldBorder();
                double d0 = Math.max(-2.9999872E7D, worldborder.minX() + 16.0D);
                double d1 = Math.max(-2.9999872E7D, worldborder.minZ() + 16.0D);
                double d2 = Math.min(2.9999872E7D, worldborder.maxX() - 16.0D);
                double d3 = Math.min(2.9999872E7D, worldborder.maxZ() - 16.0D);
                double d4 = DimensionType.getCoordinateDifference(this.world.getDimensionType(), p_241829_1_.getDimensionType());
                BlockPos blockpos1 = new BlockPos(MathHelper.clamp(this.getPosX() * d4, d0, d2), this.getPosY(), MathHelper.clamp(this.getPosZ() * d4, d1, d3));
                return this.func_241830_a(p_241829_1_, blockpos1, flag2).map((p_242275_2_) ->
                {
                    BlockState blockstate = this.world.getBlockState(this.field_242271_ac);
                    Direction.Axis direction$axis;
                    Vector3d vector3d;

                    if (blockstate.hasProperty(BlockStateProperties.HORIZONTAL_AXIS)) {
                        direction$axis = blockstate.get(BlockStateProperties.HORIZONTAL_AXIS);
                        TeleportationRepositioner.Result teleportationrepositioner$result = TeleportationRepositioner.findLargestRectangle(this.field_242271_ac, direction$axis, 21, Direction.Axis.Y, 21, (p_242276_2_) ->
                        {
                            return this.world.getBlockState(p_242276_2_) == blockstate;
                        });
                        vector3d = this.func_241839_a(direction$axis, teleportationrepositioner$result);
                    } else {
                        direction$axis = Direction.Axis.X;
                        vector3d = new Vector3d(0.5D, 0.0D, 0.0D);
                    }

                    return PortalSize.func_242963_a(p_241829_1_, p_242275_2_, direction$axis, vector3d, this.getSize(this.getPose()), this.getMotion(), this.rotationYaw, this.rotationPitch);
                }).orElse((PortalInfo) null);
            }
        } else {
            BlockPos blockpos;

            if (flag1) {
                blockpos = ServerWorld.field_241108_a_;
            } else {
                blockpos = p_241829_1_.getHeight(Heightmap.Type.MOTION_BLOCKING_NO_LEAVES, p_241829_1_.getSpawnPoint());
            }

            return new PortalInfo(new Vector3d((double) blockpos.getX() + 0.5D, (double) blockpos.getY(), (double) blockpos.getZ() + 0.5D), this.getMotion(), this.rotationYaw, this.rotationPitch);
        }
    }

    protected Vector3d func_241839_a(Direction.Axis axis, TeleportationRepositioner.Result result) {
        return PortalSize.func_242973_a(result, axis, this.getPositionVec(), this.getSize(this.getPose()));
    }

    protected Optional<TeleportationRepositioner.Result> func_241830_a(ServerWorld p_241830_1_, BlockPos p_241830_2_, boolean p_241830_3_) {
        return p_241830_1_.getDefaultTeleporter().getExistingPortal(p_241830_2_, p_241830_3_);
    }

    /**
     * Returns false if this Entity is a boss, true otherwise.
     */
    public boolean isNonBoss() {
        return true;
    }

    /**
     * Explosion resistance of a block relative to this entity
     */
    public float getExplosionResistance(Explosion explosionIn, IBlockReader worldIn, BlockPos pos, BlockState blockStateIn, FluidState fluidState, float explosionPower) {
        return explosionPower;
    }

    public boolean canExplosionDestroyBlock(Explosion explosionIn, IBlockReader worldIn, BlockPos pos, BlockState blockStateIn, float explosionPower) {
        return true;
    }

    /**
     * The maximum height from where the entity is alowed to jump (used in pathfinder)
     */
    public int getMaxFallHeight() {
        return 3;
    }

    /**
     * Return whether this entity should NOT trigger a pressure plate or a tripwire.
     */
    public boolean doesEntityNotTriggerPressurePlate() {
        return false;
    }

    public void fillCrashReport(CrashReportCategory category) {
        category.addDetail("Entity Type", () ->
        {
            return EntityType.getKey(this.getType()) + " (" + this.getClass().getCanonicalName() + ")";
        });
        category.addDetail("Entity ID", this.entityId);
        category.addDetail("Entity Name", () ->
        {
            return this.getName().getString();
        });
        category.addDetail("Entity's Exact location", String.format(Locale.ROOT, "%.2f, %.2f, %.2f", this.getPosX(), this.getPosY(), this.getPosZ()));
        category.addDetail("Entity's Block location", CrashReportCategory.getCoordinateInfo(MathHelper.floor(this.getPosX()), MathHelper.floor(this.getPosY()), MathHelper.floor(this.getPosZ())));
        Vector3d vector3d = this.getMotion();
        category.addDetail("Entity's Momentum", String.format(Locale.ROOT, "%.2f, %.2f, %.2f", vector3d.x, vector3d.y, vector3d.z));
        category.addDetail("Entity's Passengers", () ->
        {
            return this.getPassengers().toString();
        });
        category.addDetail("Entity's Vehicle", () ->
        {
            return this.getRidingEntity().toString();
        });
    }

    /**
     * Return whether this entity should be rendered as on fire.
     */
    public boolean canRenderOnFire() {
        return this.isBurning() && !this.isSpectator();
    }

    public void setUniqueId(UUID uniqueIdIn) {
        this.entityUniqueID = uniqueIdIn;
        this.cachedUniqueIdString = this.entityUniqueID.toString();
    }

    /**
     * Returns the UUID of this entity.
     */
    public UUID getUniqueID() {
        return this.entityUniqueID;
    }

    public String getCachedUniqueIdString() {
        return this.cachedUniqueIdString;
    }

    /**
     * Returns a String to use as this entity's name in the scoreboard/entity selector systems
     */
    public String getScoreboardName() {
        return this.cachedUniqueIdString;
    }

    public boolean isPushedByWater() {
        return true;
    }

    public static double getRenderDistanceWeight() {
        return renderDistanceWeight;
    }

    public static void setRenderDistanceWeight(double renderDistWeight) {
        renderDistanceWeight = renderDistWeight;
    }

    public ITextComponent getDisplayName() {
        return ScorePlayerTeam.func_237500_a_(this.getTeam(), this.getName()).modifyStyle((p_211516_1_) ->
        {
            return p_211516_1_.setHoverEvent(this.getHoverEvent()).setInsertion(this.getCachedUniqueIdString());
        });
    }

    public void setCustomName(@Nullable ITextComponent name) {
        this.dataManager.set(CUSTOM_NAME, Optional.ofNullable(name));
    }

    @Nullable
    public ITextComponent getCustomName() {
        return this.dataManager.get(CUSTOM_NAME).orElse((ITextComponent) null);
    }

    public boolean hasCustomName() {
        return this.dataManager.get(CUSTOM_NAME).isPresent();
    }

    public void setCustomNameVisible(boolean alwaysRenderNameTag) {
        this.dataManager.set(CUSTOM_NAME_VISIBLE, alwaysRenderNameTag);
    }

    public boolean isCustomNameVisible() {
        return this.dataManager.get(CUSTOM_NAME_VISIBLE);
    }

    /**
     * Teleports the entity, forcing the destination to stay loaded for a short time
     */
    public final void teleportKeepLoaded(double x, double y, double z) {
        if (this.world instanceof ServerWorld) {
            ChunkPos chunkpos = new ChunkPos(new BlockPos(x, y, z));
            ((ServerWorld) this.world).getChunkProvider().registerTicket(TicketType.POST_TELEPORT, chunkpos, 0, this.getEntityId());
            this.world.getChunk(chunkpos.x, chunkpos.z);
            this.setPositionAndUpdate(x, y, z);
        }
    }

    /**
     * Sets the position of the entity and updates the 'last' variables
     */
    public void setPositionAndUpdate(double x, double y, double z) {
        if (this.world instanceof ServerWorld) {
            ServerWorld serverworld = (ServerWorld) this.world;
            this.setLocationAndAngles(x, y, z, this.rotationYaw, this.rotationPitch);
            this.getSelfAndPassengers().forEach((p_233565_1_) ->
            {
                serverworld.chunkCheck(p_233565_1_);
                p_233565_1_.isPositionDirty = true;

                for (Entity entity : p_233565_1_.passengers) {
                    p_233565_1_.positionRider(entity, Entity::moveForced);
                }
            });
        }
    }

    public boolean getAlwaysRenderNameTagForRender() {
        return this.isCustomNameVisible();
    }

    public void notifyDataManagerChange(DataParameter<?> key) {
        if (POSE.equals(key)) {
            this.recalculateSize();
        }
    }

    public void recalculateSize() {
        EntitySize entitysize = this.size;
        Pose pose = this.getPose();
        EntitySize entitysize1 = this.getSize(pose);
        this.size = entitysize1;
        this.eyeHeight = this.getEyeHeight(pose, entitysize1);

        if (entitysize1.width < entitysize.width) {
            double d0 = (double) entitysize1.width / 2.0D;
            this.setBoundingBox(new AxisAlignedBB(this.getPosX() - d0, this.getPosY(), this.getPosZ() - d0, this.getPosX() + d0, this.getPosY() + (double) entitysize1.height, this.getPosZ() + d0));
        } else {
            AxisAlignedBB axisalignedbb = this.getBoundingBox();
            this.setBoundingBox(new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.minX + (double) entitysize1.width, axisalignedbb.minY + (double) entitysize1.height, axisalignedbb.minZ + (double) entitysize1.width));

            if (entitysize1.width > entitysize.width && !this.firstUpdate && !this.world.isRemote) {
                float f = entitysize.width - entitysize1.width;
                this.move(MoverType.SELF, new Vector3d((double) f, 0.0D, (double) f));
            }
        }
    }

    /**
     * Gets the horizontal facing direction of this Entity.
     */
    public Direction getHorizontalFacing() {
        return Direction.fromAngle((double) this.rotationYaw);
    }

    /**
     * Gets the horizontal facing direction of this Entity, adjusted to take specially-treated entity types into
     * account.
     */
    public Direction getAdjustedHorizontalFacing() {
        return this.getHorizontalFacing();
    }

    protected HoverEvent getHoverEvent() {
        return new HoverEvent(HoverEvent.Action.SHOW_ENTITY, new HoverEvent.EntityHover(this.getType(), this.getUniqueID(), this.getName()));
    }

    public boolean isSpectatedByPlayer(ServerPlayerEntity player) {
        return true;
    }

    public AxisAlignedBB getBoundingBox() {
        return this.boundingBox;
    }

    /**
     * Gets the bounding box of this Entity, adjusted to take auxiliary entities into account (e.g. the tile contained
     * by a minecart, such as a command block).
     */
    public AxisAlignedBB getRenderBoundingBox() {
        return this.getBoundingBox();
    }

    protected AxisAlignedBB getBoundingBox(Pose pose) {
        EntitySize entitysize = this.getSize(pose);
        float f = entitysize.width / 2.0F;
        Vector3d vector3d = new Vector3d(this.getPosX() - (double) f, this.getPosY(), this.getPosZ() - (double) f);
        Vector3d vector3d1 = new Vector3d(this.getPosX() + (double) f, this.getPosY() + (double) entitysize.height, this.getPosZ() + (double) f);
        return new AxisAlignedBB(vector3d, vector3d1);
    }

    public void setBoundingBox(AxisAlignedBB bb) {
        this.boundingBox = bb;
    }

    protected float getEyeHeight(Pose poseIn, EntitySize sizeIn) {
        return sizeIn.height * 0.85F;
    }

    public float getEyeHeight(Pose pose) {
        return this.getEyeHeight(pose, this.getSize(pose));
    }

    public final float getEyeHeight() {
        return this.eyeHeight;
    }

    public Vector3d func_241205_ce_() {
        return new Vector3d(0.0D, (double) this.getEyeHeight(), (double) (this.getWidth() * 0.4F));
    }

    public boolean replaceItemInInventory(int inventorySlot, ItemStack itemStackIn) {
        return false;
    }

    /**
     * Send a chat message to the CommandSender
     */
    public void sendMessage(ITextComponent component, UUID senderUUID) {
    }

    /**
     * Get the world, if available. <b>{@code null} is not allowed!</b> If you are not an entity in the world, return
     * the overworld
     */
    public World getEntityWorld() {
        return this.world;
    }

    @Nullable

    /**
     * Get the Minecraft server instance
     */
    public MinecraftServer getServer() {
        return this.world.getServer();
    }

    /**
     * Applies the given player interaction to this Entity.
     */
    public ActionResultType applyPlayerInteraction(PlayerEntity player, Vector3d vec, Hand hand) {
        return ActionResultType.PASS;
    }

    public boolean isImmuneToExplosions() {
        return false;
    }

    public void applyEnchantments(LivingEntity entityLivingBaseIn, Entity entityIn) {
        if (entityIn instanceof LivingEntity) {
            EnchantmentHelper.applyThornEnchantments((LivingEntity) entityIn, entityLivingBaseIn);
        }

        EnchantmentHelper.applyArthropodEnchantments(entityLivingBaseIn, entityIn);
    }

    /**
     * Add the given player to the list of players tracking this entity. For instance, a player may track a boss in
     * order to view its associated boss bar.
     */
    public void addTrackingPlayer(ServerPlayerEntity player) {
    }

    /**
     * Removes the given player from the list of players tracking this entity. See {@link Entity#addTrackingPlayer} for
     * more information on tracking.
     */
    public void removeTrackingPlayer(ServerPlayerEntity player) {
    }

    /**
     * Transforms the entity's current yaw with the given Rotation and returns it. This does not have a side-effect.
     */
    public float getRotatedYaw(Rotation transformRotation) {
        float f = MathHelper.wrapDegrees(this.rotationYaw);

        switch (transformRotation) {
            case CLOCKWISE_180:
                return f + 180.0F;

            case COUNTERCLOCKWISE_90:
                return f + 270.0F;

            case CLOCKWISE_90:
                return f + 90.0F;

            default:
                return f;
        }
    }

    /**
     * Transforms the entity's current yaw with the given Mirror and returns it. This does not have a side-effect.
     */
    public float getMirroredYaw(Mirror transformMirror) {
        float f = MathHelper.wrapDegrees(this.rotationYaw);

        switch (transformMirror) {
            case LEFT_RIGHT:
                return -f;

            case FRONT_BACK:
                return 180.0F - f;

            default:
                return f;
        }
    }

    /**
     * Checks if players can use this entity to access operator (permission level 2) commands either directly or
     * indirectly, such as give or setblock. A similar method exists for entities at {@link
     * net.minecraft.tileentity.TileEntity#onlyOpsCanSetNbt()}.<p>For example, {@link
     * net.minecraft.entity.item.EntityMinecartCommandBlock#ignoreItemEntityData() command block minecarts} and {@link
     * net.minecraft.entity.item.EntityMinecartMobSpawner#ignoreItemEntityData() mob spawner minecarts} (spawning
     * command block minecarts or drops) are considered accessible.</p>@return true if this entity offers ways for
     * unauthorized players to use restricted commands
     */
    public boolean ignoreItemEntityData() {
        return false;
    }

    public boolean func_233577_ch_() {
        boolean flag = this.isPositionDirty;
        this.isPositionDirty = false;
        return flag;
    }

    public boolean func_233578_ci_() {
        boolean flag = this.isLoaded;
        this.isLoaded = false;
        return flag;
    }

    @Nullable

    /**
     * For vehicles, the first passenger is generally considered the controller and "drives" the vehicle. For example,
     * Pigs, Horses, and Boats are generally "steered" by the controlling passenger.
     */
    public Entity getControllingPassenger() {
        return null;
    }

    public List<Entity> getPassengers() {
        return (List<Entity>) (this.passengers.isEmpty() ? Collections.emptyList() : Lists.newArrayList(this.passengers));
    }

    public boolean isPassenger(Entity entityIn) {
        for (Entity entity : this.getPassengers()) {
            if (entity.equals(entityIn)) {
                return true;
            }
        }

        return false;
    }

    public boolean isPassenger(Class<? extends Entity> entityClazz) {
        for (Entity entity : this.getPassengers()) {
            if (entityClazz.isAssignableFrom(entity.getClass())) {
                return true;
            }
        }

        return false;
    }

    public Collection<Entity> getRecursivePassengers() {
        Set<Entity> set = Sets.newHashSet();

        for (Entity entity : this.getPassengers()) {
            set.add(entity);
            entity.getRecursivePassengers(false, set);
        }

        return set;
    }

    public Stream<Entity> getSelfAndPassengers() {
        return Stream.concat(Stream.of(this), this.passengers.stream().flatMap(Entity::getSelfAndPassengers));
    }

    public boolean isOnePlayerRiding() {
        Set<Entity> set = Sets.newHashSet();
        this.getRecursivePassengers(true, set);
        return set.size() == 1;
    }

    private void getRecursivePassengers(boolean playersOnly, Set<Entity> p_200604_2_) {
        for (Entity entity : this.getPassengers()) {
            if (!playersOnly || ServerPlayerEntity.class.isAssignableFrom(entity.getClass())) {
                p_200604_2_.add(entity);
            }

            entity.getRecursivePassengers(playersOnly, p_200604_2_);
        }
    }

    public Entity getLowestRidingEntity() {
        Entity entity;

        for (entity = this; entity.isPassenger(); entity = entity.getRidingEntity()) {
        }

        return entity;
    }

    public boolean isRidingSameEntity(Entity entityIn) {
        return this.getLowestRidingEntity() == entityIn.getLowestRidingEntity();
    }

    public boolean isRidingOrBeingRiddenBy(Entity entityIn) {
        for (Entity entity : this.getPassengers()) {
            if (entity.equals(entityIn)) {
                return true;
            }

            if (entity.isRidingOrBeingRiddenBy(entityIn)) {
                return true;
            }
        }

        return false;
    }

    public boolean canPassengerSteer() {
        Entity entity = this.getControllingPassenger();

        if (entity instanceof PlayerEntity) {
            return ((PlayerEntity) entity).isUser();
        } else {
            return !this.world.isRemote;
        }
    }

    protected static Vector3d func_233559_a_(double p_233559_0_, double p_233559_2_, float p_233559_4_) {
        double d0 = (p_233559_0_ + p_233559_2_ + (double) 1.0E-5F) / 2.0D;
        float f = -MathHelper.sin(p_233559_4_ * ((float) Math.PI / 180F));
        float f1 = MathHelper.cos(p_233559_4_ * ((float) Math.PI / 180F));
        float f2 = Math.max(Math.abs(f), Math.abs(f1));
        return new Vector3d((double) f * d0 / (double) f2, 0.0D, (double) f1 * d0 / (double) f2);
    }

    public Vector3d func_230268_c_(LivingEntity livingEntity) {
        return new Vector3d(this.getPosX(), this.getBoundingBox().maxY, this.getPosZ());
    }

    @Nullable

    /**
     * Get entity this is riding
     */
    public Entity getRidingEntity() {
        return this.ridingEntity;
    }

    public PushReaction getPushReaction() {
        return PushReaction.NORMAL;
    }

    public SoundCategory getSoundCategory() {
        return SoundCategory.NEUTRAL;
    }

    protected int getFireImmuneTicks() {
        return 1;
    }

    public CommandSource getCommandSource() {
        return new CommandSource(this, this.getPositionVec(), this.getPitchYaw(), this.world instanceof ServerWorld ? (ServerWorld) this.world : null, this.getPermissionLevel(), this.getName().getString(), this.getDisplayName(), this.world.getServer(), this);
    }

    protected int getPermissionLevel() {
        return 0;
    }

    public boolean hasPermissionLevel(int level) {
        return this.getPermissionLevel() >= level;
    }

    public boolean shouldReceiveFeedback() {
        return this.world.getGameRules().getBoolean(GameRules.SEND_COMMAND_FEEDBACK);
    }

    public boolean shouldReceiveErrors() {
        return true;
    }

    public boolean allowLogging() {
        return true;
    }

    public void lookAt(EntityAnchorArgument.Type anchor, Vector3d target) {
        Vector3d vector3d = anchor.apply(this);
        double d0 = target.x - vector3d.x;
        double d1 = target.y - vector3d.y;
        double d2 = target.z - vector3d.z;
        double d3 = (double) MathHelper.sqrt(d0 * d0 + d2 * d2);
        this.rotationPitch = MathHelper.wrapDegrees((float) (-(MathHelper.atan2(d1, d3) * (double) (180F / (float) Math.PI))));
        this.rotationYaw = MathHelper.wrapDegrees((float) (MathHelper.atan2(d2, d0) * (double) (180F / (float) Math.PI)) - 90.0F);
        this.setRotationYawHead(this.rotationYaw);
        this.prevRotationPitch = this.rotationPitch;
        this.prevRotationYaw = this.rotationYaw;
    }

    public boolean handleFluidAcceleration(ITag<Fluid> fluidTag, double p_210500_2_) {
        AxisAlignedBB axisalignedbb = this.getBoundingBox().shrink(0.001D);
        int i = MathHelper.floor(axisalignedbb.minX);
        int j = MathHelper.ceil(axisalignedbb.maxX);
        int k = MathHelper.floor(axisalignedbb.minY);
        int l = MathHelper.ceil(axisalignedbb.maxY);
        int i1 = MathHelper.floor(axisalignedbb.minZ);
        int j1 = MathHelper.ceil(axisalignedbb.maxZ);

        if (!this.world.isAreaLoaded(i, k, i1, j, l, j1)) {
            return false;
        } else {
            double d0 = 0.0D;
            boolean flag = this.isPushedByWater();
            boolean flag1 = false;
            Vector3d vector3d = Vector3d.ZERO;
            int k1 = 0;
            BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();

            for (int l1 = i; l1 < j; ++l1) {
                for (int i2 = k; i2 < l; ++i2) {
                    for (int j2 = i1; j2 < j1; ++j2) {
                        blockpos$mutable.setPos(l1, i2, j2);
                        FluidState fluidstate = this.world.getFluidState(blockpos$mutable);

                        if (fluidstate.isTagged(fluidTag)) {
                            double d1 = (double) ((float) i2 + fluidstate.getActualHeight(this.world, blockpos$mutable));

                            if (d1 >= axisalignedbb.minY) {
                                flag1 = true;
                                d0 = Math.max(d1 - axisalignedbb.minY, d0);

                                if (flag) {
                                    Vector3d vector3d1 = fluidstate.getFlow(this.world, blockpos$mutable);

                                    if (d0 < 0.4D) {
                                        vector3d1 = vector3d1.scale(d0);
                                    }

                                    vector3d = vector3d.add(vector3d1);
                                    ++k1;
                                }
                            }
                        }
                    }
                }
            }

            if (vector3d.length() > 0.0D) {
                if (k1 > 0) {
                    vector3d = vector3d.scale(1.0D / (double) k1);
                }

                if (!(this instanceof PlayerEntity)) {
                    vector3d = vector3d.normalize();
                }

                Vector3d vector3d2 = this.getMotion();
                vector3d = vector3d.scale(p_210500_2_ * 1.0D);
                double d2 = 0.003D;

                if (Math.abs(vector3d2.x) < 0.003D && Math.abs(vector3d2.z) < 0.003D && vector3d.length() < 0.0045000000000000005D) {
                    vector3d = vector3d.normalize().scale(0.0045000000000000005D);
                }

                this.setMotion(this.getMotion().add(vector3d));
            }

            this.eyesFluidLevel.put(fluidTag, d0);
            return flag1;
        }
    }

    public boolean handleFluidAccelerationPlayer(AxisAlignedBB aab, ITag<Fluid> fluidTag) {
        int i = MathHelper.floor(aab.minX);
        int j = MathHelper.ceil(aab.maxX);
        int k = MathHelper.floor(aab.minY);
        int l = MathHelper.ceil(aab.maxY);
        int i1 = MathHelper.floor(aab.minZ);
        int j1 = MathHelper.ceil(aab.maxZ);

        if (!this.world.isAreaLoaded(i, k, i1, j, l, j1)) {
            return false;
        } else {
            double d0 = 0.0D;
            boolean flag = this.isPushedByWater();
            boolean flag1 = false;
            Vector3d vector3d = Vector3d.ZERO;
            int k1 = 0;
            BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();

            for (int l1 = i; l1 < j; ++l1) {
                for (int i2 = k; i2 < l; ++i2) {
                    for (int j2 = i1; j2 < j1; ++j2) {
                        blockpos$mutable.setPos(l1, i2, j2);
                        FluidState fluidstate = this.world.getFluidState(blockpos$mutable);

                        if (fluidstate.isTagged(fluidTag)) {
                            double d1 = (double) ((float) i2 + fluidstate.getActualHeight(this.world, blockpos$mutable));

                            if (d1 >= aab.minY) {
                                flag1 = true;
                                d0 = Math.max(d1 - aab.minY, d0);

                                if (flag) {
                                    Vector3d vector3d1 = fluidstate.getFlow(this.world, blockpos$mutable);

                                    if (d0 < 0.4D) {
                                        vector3d1 = vector3d1.scale(d0);
                                    }

                                    vector3d = vector3d.add(vector3d1);
                                    ++k1;
                                }
                            }
                        }
                    }
                }
            }

            if (vector3d.length() > 0.0D) {
                if (k1 > 0) {
                    vector3d = vector3d.scale(1.0D / (double) k1);
                }

                if (!(this instanceof PlayerEntity)) {
                    vector3d = vector3d.normalize();
                }

                Vector3d vector3d2 = this.getMotion();
                vector3d = vector3d.scale(0.014D * 1.0D);
                double d2 = 0.003D;

                if (Math.abs(vector3d2.x) < 0.003D && Math.abs(vector3d2.z) < 0.003D && vector3d.length() < 0.0045000000000000005D) {
                    vector3d = vector3d.normalize().scale(0.0045000000000000005D);
                }
                if (this instanceof ClientPlayerEntity) {
                    Minecraft.getInstance().player.setMotion(this.getMotion().add(vector3d));
                }
            }

            this.eyesFluidLevel.put(fluidTag, d0);
            return flag1;
        }
    }

    public boolean handleFluidAcceleration(AxisAlignedBB aab, ITag<Fluid> fluidTag) {
        int i = MathHelper.floor(aab.minX);
        int j = MathHelper.ceil(aab.maxX);
        int k = MathHelper.floor(aab.minY);
        int l = MathHelper.ceil(aab.maxY);
        int i1 = MathHelper.floor(aab.minZ);
        int j1 = MathHelper.ceil(aab.maxZ);

        if (!this.world.isAreaLoaded(i, k, i1, j, l, j1)) {
            return false;
        } else {
            double d0 = 0.0D;
            boolean flag = this.isPushedByWater();
            boolean flag1 = false;
            Vector3d vector3d = Vector3d.ZERO;
            int k1 = 0;
            BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();

            for (int l1 = i; l1 < j; ++l1) {
                for (int i2 = k; i2 < l; ++i2) {
                    for (int j2 = i1; j2 < j1; ++j2) {
                        blockpos$mutable.setPos(l1, i2, j2);
                        FluidState fluidstate = this.world.getFluidState(blockpos$mutable);

                        if (fluidstate.isTagged(fluidTag)) {
                            double d1 = (double) ((float) i2 + fluidstate.getActualHeight(this.world, blockpos$mutable));

                            if (d1 >= aab.minY) {
                                flag1 = true;
                                d0 = Math.max(d1 - aab.minY, d0);

                                if (flag) {
                                    Vector3d vector3d1 = fluidstate.getFlow(this.world, blockpos$mutable);

                                    if (d0 < 0.4D) {
                                        vector3d1 = vector3d1.scale(d0);
                                    }

                                    vector3d = vector3d.add(vector3d1);
                                    ++k1;
                                }
                            }
                        }
                    }
                }
            }

            if (vector3d.length() > 0.0D) {
                if (k1 > 0) {
                    vector3d = vector3d.scale(1.0D / (double) k1);
                }

                if (!(this instanceof PlayerEntity)) {
                    vector3d = vector3d.normalize();
                }

                Vector3d vector3d2 = this.getMotion();
                vector3d = vector3d.scale(0.014D * 1.0D);
                double d2 = 0.003D;

                if (Math.abs(vector3d2.x) < 0.003D && Math.abs(vector3d2.z) < 0.003D && vector3d.length() < 0.0045000000000000005D) {
                    vector3d = vector3d.normalize().scale(0.0045000000000000005D);
                }

                this.setMotion(this.getMotion().add(vector3d));
            }

            this.eyesFluidLevel.put(fluidTag, d0);
            return flag1;
        }
    }

    public double func_233571_b_(ITag<Fluid> p_233571_1_) {
        return this.eyesFluidLevel.getDouble(p_233571_1_);
    }

    public double func_233579_cu_() {
        return (double) this.getEyeHeight() < 0.4D ? 0.0D : 0.4D;
    }

    public final float getWidth() {
        return this.size.width;
    }

    public final float getHeight() {
        return this.size.height;
    }

    public abstract IPacket<?> createSpawnPacket();

    public EntitySize getSize(Pose poseIn) {
        return this.type.getSize();
    }

    public Vector3d getPositionVec() {
        return this.positionVec;
    }

    public BlockPos getPosition() {
        return this.position;
    }

    public Vector3d getMotion() {
        return this.motion;
    }

    public void setMotion(Vector3d motionIn) {
        this.motion = motionIn;
    }

    public void setMotion(double x, double y, double z) {
        this.setMotion(new Vector3d(x, y, z));
    }

    public final double getPosX() {
        return this.positionVec.x;
    }

    public double getPosXWidth(double p_226275_1_) {
        return this.positionVec.x + (double) this.getWidth() * p_226275_1_;
    }

    public double getPosXRandom(double p_226282_1_) {
        return this.getPosXWidth((2.0D * this.rand.nextDouble() - 1.0D) * p_226282_1_);
    }

    public final double getPosY() {
        return this.positionVec.y;
    }

    public double getPosYHeight(double p_226283_1_) {
        return this.positionVec.y + (double) this.getHeight() * p_226283_1_;
    }

    public double getPosYRandom() {
        return this.getPosYHeight(this.rand.nextDouble());
    }

    public double getPosYEye() {
        return this.positionVec.y + (double) this.eyeHeight;
    }

    public final double getPosZ() {
        return this.positionVec.z;
    }

    public double getPosZWidth(double p_226285_1_) {
        return this.positionVec.z + (double) this.getWidth() * p_226285_1_;
    }

    public double getPosZRandom(double p_226287_1_) {
        return this.getPosZWidth((2.0D * this.rand.nextDouble() - 1.0D) * p_226287_1_);
    }

    /**
     * Directly updates the {@link #posX}, {@link posY}, and {@link posZ} fields, without performing any collision
     * checks, updating the bounding box position, or sending any packets. In general, this is not what you want and
     * {@link #setPosition} is better, as that handles the bounding box.
     */
    public void setRawPosition(double x, double y, double z) {
        if (this.positionVec.x != x || this.positionVec.y != y || this.positionVec.z != z) {
            this.positionVec = new Vector3d(x, y, z);
            int i = MathHelper.floor(x);
            int j = MathHelper.floor(y);
            int k = MathHelper.floor(z);

            if (i != this.position.getX() || j != this.position.getY() || k != this.position.getZ()) {
                this.position = new BlockPos(i, j, k);
            }

            this.isLoaded = true;
        }
    }

    /**
     * Makes the entity despawn if requirements are reached
     */
    public void checkDespawn() {
    }

    public Vector3d getLeashPosition(float partialTicks) {
        return this.func_242282_l(partialTicks).add(0.0D, (double) this.eyeHeight * 0.7D, 0.0D);
    }

    @FunctionalInterface
    public interface IMoveCallback {
        void accept(Entity p_accept_1_, double p_accept_2_, double p_accept_4_, double p_accept_6_);
    }
}

LivingEntity:
package net.minecraft.entity;

import baritone.api.BaritoneAPI;
import baritone.api.IBaritone;
import baritone.api.event.events.RotationMoveEvent;
import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.mojang.datafixers.util.Pair;
import com.mojang.serialization.DataResult;
import com.mojang.serialization.Dynamic;

import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.UUID;
import java.util.function.Predicate;
import javax.annotation.Nullable;

import net.minecraft.advancements.CriteriaTriggers;
import net.minecraft.block.*;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.player.ClientPlayerEntity;
import net.minecraft.command.arguments.EntityAnchorArgument;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.enchantment.Enchantments;
import net.minecraft.enchantment.FrostWalkerEnchantment;
import net.minecraft.entity.ai.attributes.Attribute;
import net.minecraft.entity.ai.attributes.AttributeModifier;
import net.minecraft.entity.ai.attributes.AttributeModifierManager;
import net.minecraft.entity.ai.attributes.AttributeModifierMap;
import net.minecraft.entity.ai.attributes.Attributes;
import net.minecraft.entity.ai.attributes.GlobalEntityTypeAttributes;
import net.minecraft.entity.ai.attributes.ModifiableAttributeInstance;
import net.minecraft.entity.ai.brain.Brain;
import net.minecraft.entity.boss.WitherEntity;
import net.minecraft.entity.item.ExperienceOrbEntity;
import net.minecraft.entity.item.ItemEntity;
import net.minecraft.entity.passive.IFlyingAnimal;
import net.minecraft.entity.passive.WolfEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.ServerPlayerEntity;
import net.minecraft.entity.projectile.AbstractArrowEntity;
import net.minecraft.fluid.Fluid;
import net.minecraft.fluid.FluidState;
import net.minecraft.inventory.EquipmentSlotType;
import net.minecraft.item.ArmorItem;
import net.minecraft.item.ElytraItem;
import net.minecraft.item.Food;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.item.UseAction;
import net.minecraft.loot.LootContext;
import net.minecraft.loot.LootParameterSets;
import net.minecraft.loot.LootParameters;
import net.minecraft.loot.LootTable;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.INBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.nbt.NBTDynamicOps;
import net.minecraft.network.IPacket;
import net.minecraft.network.datasync.DataParameter;
import net.minecraft.network.datasync.DataSerializers;
import net.minecraft.network.datasync.EntityDataManager;
import net.minecraft.network.play.server.SAnimateHandPacket;
import net.minecraft.network.play.server.SCollectItemPacket;
import net.minecraft.network.play.server.SEntityEquipmentPacket;
import net.minecraft.network.play.server.SEntityStatusPacket;
import net.minecraft.network.play.server.SSpawnMobPacket;
import net.minecraft.particles.BlockParticleData;
import net.minecraft.particles.ItemParticleData;
import net.minecraft.particles.ParticleTypes;
import net.minecraft.potion.Effect;
import net.minecraft.potion.EffectInstance;
import net.minecraft.potion.EffectUtils;
import net.minecraft.potion.Effects;
import net.minecraft.potion.PotionUtils;
import net.minecraft.scoreboard.ScorePlayerTeam;
import net.minecraft.stats.Stats;
import net.minecraft.tags.BlockTags;
import net.minecraft.tags.FluidTags;
import net.minecraft.tags.ITag;
import net.minecraft.util.CombatRules;
import net.minecraft.util.CombatTracker;
import net.minecraft.util.DamageSource;
import net.minecraft.util.Direction;
import net.minecraft.util.EntityDamageSource;
import net.minecraft.util.EntityPredicates;
import net.minecraft.util.Hand;
import net.minecraft.util.HandSide;
import net.minecraft.util.NonNullList;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.SoundEvents;
import net.minecraft.util.TeleportationRepositioner;
import net.minecraft.util.math.*;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.world.GameRules;
import net.minecraft.world.World;
import net.minecraft.world.server.ServerChunkProvider;
import net.minecraft.world.server.ServerWorld;
import wtf.expensive.events.EventManager;
import wtf.expensive.events.impl.player.EventDamage;
import wtf.expensive.events.impl.player.EventJump;
import wtf.expensive.events.impl.player.EventStrafe;
import wtf.expensive.events.impl.player.EventTravel;
import wtf.expensive.managment.Managment;
import wtf.expensive.modules.impl.render.SwingAnimationFunction;

public abstract class LivingEntity extends Entity {
    private static final UUID SPRINTING_SPEED_BOOST_ID = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
    private static final UUID SOUL_SPEED_BOOT_ID = UUID.fromString("87f46a96-686f-4796-b035-22e16ee9e038");
    private static final AttributeModifier SPRINTING_SPEED_BOOST = new AttributeModifier(SPRINTING_SPEED_BOOST_ID, "Sprinting speed boost", (double) 0.3F, AttributeModifier.Operation.MULTIPLY_TOTAL);
    protected static final DataParameter<Byte> LIVING_FLAGS = EntityDataManager.createKey(LivingEntity.class, DataSerializers.BYTE);
    private static final DataParameter<Float> HEALTH = EntityDataManager.createKey(LivingEntity.class, DataSerializers.FLOAT);
    private static final DataParameter<Integer> POTION_EFFECTS = EntityDataManager.createKey(LivingEntity.class, DataSerializers.VARINT);
    private static final DataParameter<Boolean> HIDE_PARTICLES = EntityDataManager.createKey(LivingEntity.class, DataSerializers.BOOLEAN);
    private static final DataParameter<Integer> ARROW_COUNT_IN_ENTITY = EntityDataManager.createKey(LivingEntity.class, DataSerializers.VARINT);
    private static final DataParameter<Integer> BEE_STING_COUNT = EntityDataManager.createKey(LivingEntity.class, DataSerializers.VARINT);
    private static final DataParameter<Optional<BlockPos>> BED_POSITION = EntityDataManager.createKey(LivingEntity.class, DataSerializers.OPTIONAL_BLOCK_POS);
    protected static final EntitySize SLEEPING_SIZE = EntitySize.fixed(0.2F, 0.2F);
    private final AttributeModifierManager attributes;
    private final CombatTracker combatTracker = new CombatTracker(this);
    private final Map<Effect, EffectInstance> activePotionsMap = Maps.newHashMap();
    private final NonNullList<ItemStack> handInventory = NonNullList.withSize(2, ItemStack.EMPTY);
    private final NonNullList<ItemStack> armorArray = NonNullList.withSize(4, ItemStack.EMPTY);
    public boolean isSwingInProgress;
    public Hand swingingHand;
    public int swingProgressInt;
    public int arrowHitTimer;
    public int beeStingRemovalCooldown;
    public int hurtTime;
    public int maxHurtTime;
    public float attackedAtYaw;
    public int deathTime;
    public float prevSwingProgress;
    public float swingProgress;
    protected int ticksSinceLastSwing;
    public float prevLimbSwingAmount;
    public float limbSwingAmount;
    public float limbSwing;
    public final int maxHurtResistantTime = 20;
    public final float randomUnused2;
    public final float randomUnused1;
    public float renderYawOffset;
    public float prevRenderYawOffset;
    public float rotationYawHead;
    public float rotationPitchHead;
    public float prevRotationPitchHead;

    public float prevRotationYawHead;

    public float jumpMovementFactor = 0.02F;
    @Nullable
    protected PlayerEntity attackingPlayer;
    protected int recentlyHit;
    protected boolean dead;
    protected int idleTime;
    protected float prevOnGroundSpeedFactor;
    protected float onGroundSpeedFactor;
    protected float movedDistance;
    protected float prevMovedDistance;
    protected float unused180;
    protected int scoreValue;

    /**
     * Damage taken in the last hit. Mobs are resistant to damage less than this for a short time after taking damage.
     */
    protected float lastDamage;
    protected boolean isJumping;
    public float moveStrafing;
    public float moveVertical;
    public float moveForward;
    protected int newPosRotationIncrements;
    protected double interpTargetX;
    protected double interpTargetY;
    protected double prevServerX, prevServerY, prevServerZ;
    protected double interpTargetZ;
    protected double interpTargetYaw;
    protected double interpTargetPitch;
    protected double interpTargetHeadYaw;
    protected int interpTicksHead;
    private boolean potionsNeedUpdate = true;
    @Nullable
    private LivingEntity revengeTarget;
    private int revengeTimer;
    private LivingEntity lastAttackedEntity;

    /**
     * Holds the value of ticksExisted when setLastAttacker was last called.
     */
    private int lastAttackedEntityTime;
    private float landMovementFactor;
    public int jumpTicks;
    private float absorptionAmount;
    protected ItemStack activeItemStack = ItemStack.EMPTY;
    protected int activeItemStackUseCount;
    protected int ticksElytraFlying;
    private BlockPos prevBlockpos;
    private Optional<BlockPos> field_233624_bE_ = Optional.empty();
    private DamageSource lastDamageSource;
    private long lastDamageStamp;
    protected int spinAttackDuration;
    private float swimAnimation;
    private float lastSwimAnimation;
    protected Brain<?> brain;

    protected LivingEntity(EntityType<? extends LivingEntity> type, World worldIn) {
        super(type, worldIn);
        this.attributes = new AttributeModifierManager(GlobalEntityTypeAttributes.getAttributesForEntity(type));
        this.setHealth(this.getMaxHealth());
        this.preventEntitySpawning = true;
        this.randomUnused1 = (float) ((Math.random() + 1.0D) * (double) 0.01F);
        this.recenterBoundingBox();
        this.randomUnused2 = (float) Math.random() * 12398.0F;
        this.rotationYaw = (float) (Math.random() * (double) ((float) Math.PI * 2F));
        this.rotationYawHead = this.rotationYaw;
        this.stepHeight = 0.6F;
        NBTDynamicOps nbtdynamicops = NBTDynamicOps.INSTANCE;
        this.brain = this.createBrain(new Dynamic<>(nbtdynamicops, nbtdynamicops.createMap(ImmutableMap.of(nbtdynamicops.createString("memories"), nbtdynamicops.emptyMap()))));
    }

    public Brain<?> getBrain() {
        return this.brain;
    }

    protected Brain.BrainCodec<?> getBrainCodec() {
        return Brain.createCodec(ImmutableList.of(), ImmutableList.of());
    }

    protected Brain<?> createBrain(Dynamic<?> dynamicIn) {
        return this.getBrainCodec().deserialize(dynamicIn);
    }

    /**
     * Called by the /kill command.
     */
    public void onKillCommand() {
        this.attackEntityFrom(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
    }

    public boolean canAttack(EntityType<?> typeIn) {
        return true;
    }

    protected void registerData() {
        this.dataManager.register(LIVING_FLAGS, (byte) 0);
        this.dataManager.register(POTION_EFFECTS, 0);
        this.dataManager.register(HIDE_PARTICLES, false);
        this.dataManager.register(ARROW_COUNT_IN_ENTITY, 0);
        this.dataManager.register(BEE_STING_COUNT, 0);
        this.dataManager.register(HEALTH, 1.0F);
        this.dataManager.register(BED_POSITION, Optional.empty());
    }

    public static AttributeModifierMap.MutableAttribute registerAttributes() {
        return AttributeModifierMap.createMutableAttribute().createMutableAttribute(Attributes.MAX_HEALTH).createMutableAttribute(Attributes.KNOCKBACK_RESISTANCE).createMutableAttribute(Attributes.MOVEMENT_SPEED).createMutableAttribute(Attributes.ARMOR).createMutableAttribute(Attributes.ARMOR_TOUGHNESS);
    }

    protected void updateFallState(double y, boolean onGroundIn, BlockState state, BlockPos pos) {
        if (!this.isInWater()) {
            this.func_233567_aH_();
        }

        if (!this.world.isRemote && onGroundIn && this.fallDistance > 0.0F) {
            this.func_233641_cN_();
            this.func_233642_cO_();
        }

        if (!this.world.isRemote && this.fallDistance > 3.0F && onGroundIn) {
            float f = (float) MathHelper.ceil(this.fallDistance - 3.0F);

            if (!state.isAir()) {
                double d0 = Math.min((double) (0.2F + f / 15.0F), 2.5D);
                int i = (int) (150.0D * d0);
                ((ServerWorld) this.world).spawnParticle(new BlockParticleData(ParticleTypes.BLOCK, state), this.getPosX(), this.getPosY(), this.getPosZ(), i, 0.0D, 0.0D, 0.0D, (double) 0.15F);
            }
        }

        super.updateFallState(y, onGroundIn, state, pos);
    }

    public boolean canBreatheUnderwater() {
        return this.getCreatureAttribute() == CreatureAttribute.UNDEAD;
    }

    public float getSwimAnimation(float partialTicks) {
        return MathHelper.lerp(partialTicks, this.lastSwimAnimation, this.swimAnimation);
    }

    /**
     * Gets called every tick from main Entity class
     */
    public void baseTick() {
        this.prevSwingProgress = this.swingProgress;

        if (this.firstUpdate) {
            this.getBedPosition().ifPresent(this::setSleepingPosition);
        }

        if (this.getMovementSpeed()) {
            this.addSprintingEffect();
        }

        super.baseTick();
        this.world.getProfiler().startSection("livingEntityBaseTick");
        boolean flag = this instanceof PlayerEntity;

        if (this.isAlive()) {
            if (this.isEntityInsideOpaqueBlock()) {
                this.attackEntityFrom(DamageSource.IN_WALL, 1.0F);
            } else if (flag && !this.world.getWorldBorder().contains(this.getBoundingBox())) {
                double d0 = this.world.getWorldBorder().getClosestDistance(this) + this.world.getWorldBorder().getDamageBuffer();

                if (d0 < 0.0D) {
                    double d1 = this.world.getWorldBorder().getDamagePerBlock();

                    if (d1 > 0.0D) {
                        this.attackEntityFrom(DamageSource.IN_WALL, (float) Math.max(1, MathHelper.floor(-d0 * d1)));
                    }
                }
            }
        }

        if (this.isImmuneToFire() || this.world.isRemote) {
            this.extinguish();
        }

        boolean flag1 = flag && ((PlayerEntity) this).abilities.disableDamage;

        if (this.isAlive()) {
            if (this.areEyesInFluid(FluidTags.WATER) && !this.world.getBlockState(new BlockPos(this.getPosX(), this.getPosYEye(), this.getPosZ())).isIn(Blocks.BUBBLE_COLUMN)) {
                if (!this.canBreatheUnderwater() && !EffectUtils.canBreatheUnderwater(this) && !flag1) {
                    this.setAir(this.decreaseAirSupply(this.getAir()));

                    if (this.getAir() == -20) {
                        this.setAir(0);
                        Vector3d vector3d = this.getMotion();

                        for (int i = 0; i < 8; ++i) {
                            double d2 = this.rand.nextDouble() - this.rand.nextDouble();
                            double d3 = this.rand.nextDouble() - this.rand.nextDouble();
                            double d4 = this.rand.nextDouble() - this.rand.nextDouble();
                            this.world.addParticle(ParticleTypes.BUBBLE, this.getPosX() + d2, this.getPosY() + d3, this.getPosZ() + d4, vector3d.x, vector3d.y, vector3d.z);
                        }

                        this.attackEntityFrom(DamageSource.DROWN, 2.0F);
                    }
                }

                if (!this.world.isRemote && this.isPassenger() && this.getRidingEntity() != null && !this.getRidingEntity().canBeRiddenInWater()) {
                    this.stopRiding();
                }
            } else if (this.getAir() < this.getMaxAir()) {
                this.setAir(this.determineNextAir(this.getAir()));
            }

            if (!this.world.isRemote) {
                BlockPos blockpos = this.getPosition();

                if (!Objects.equal(this.prevBlockpos, blockpos)) {
                    this.prevBlockpos = blockpos;
                    this.frostWalk(blockpos);
                }
            }
        }

        if (this.isAlive() && this.isInWaterRainOrBubbleColumn()) {
            this.extinguish();
        }

        if (this.hurtTime > 0) {
            --this.hurtTime;
        }

        if (this.hurtResistantTime > 0 && !(this instanceof ServerPlayerEntity)) {
            --this.hurtResistantTime;
        }

        if (this.getShouldBeDead()) {
            this.onDeathUpdate();
        }

        if (this.recentlyHit > 0) {
            --this.recentlyHit;
        } else {
            this.attackingPlayer = null;
        }

        if (this.lastAttackedEntity != null && !this.lastAttackedEntity.isAlive()) {
            this.lastAttackedEntity = null;
        }

        if (this.revengeTarget != null) {
            if (!this.revengeTarget.isAlive()) {
                this.setRevengeTarget((LivingEntity) null);
            } else if (this.ticksExisted - this.revengeTimer > 100) {
                this.setRevengeTarget((LivingEntity) null);
            }
        }

        this.updatePotionEffects();
        this.prevMovedDistance = this.movedDistance;
        this.prevRenderYawOffset = this.renderYawOffset;
        this.prevRotationYawHead = this.rotationYawHead;
        this.prevRotationYaw = this.rotationYaw;
        this.prevRotationPitch = this.rotationPitch;
        this.prevRotationPitchHead = this.rotationPitchHead;
        this.world.getProfiler().endSection();
    }

    public boolean getMovementSpeed() {
        return this.ticksExisted % 5 == 0 && this.getMotion().x != 0.0D && this.getMotion().z != 0.0D && !this.isSpectator() && EnchantmentHelper.hasSoulSpeed(this) && this.func_230296_cM_();
    }

    protected void addSprintingEffect() {
        Vector3d vector3d = this.getMotion();
        this.world.addParticle(ParticleTypes.SOUL, this.getPosX() + (this.rand.nextDouble() - 0.5D) * (double) this.getWidth(), this.getPosY() + 0.1D, this.getPosZ() + (this.rand.nextDouble() - 0.5D) * (double) this.getWidth(), vector3d.x * -0.2D, 0.1D, vector3d.z * -0.2D);
        float f = this.rand.nextFloat() * 0.4F + this.rand.nextFloat() > 0.9F ? 0.6F : 0.0F;
        this.playSound(SoundEvents.PARTICLE_SOUL_ESCAPE, f, 0.6F + this.rand.nextFloat() * 0.4F);
    }

    protected boolean func_230296_cM_() {
        return this.world.getBlockState(this.getPositionUnderneath()).isIn(BlockTags.SOUL_SPEED_BLOCKS);
    }

    protected float getSpeedFactor() {
        return this.func_230296_cM_() && EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.SOUL_SPEED, this) > 0 ? 1.0F : super.getSpeedFactor();
    }

    protected boolean func_230295_b_(BlockState p_230295_1_) {
        return !p_230295_1_.isAir() || this.isElytraFlying();
    }

    protected void func_233641_cN_() {
        ModifiableAttributeInstance modifiableattributeinstance = this.getAttribute(Attributes.MOVEMENT_SPEED);

        if (modifiableattributeinstance != null) {
            if (modifiableattributeinstance.getModifier(SOUL_SPEED_BOOT_ID) != null) {
                modifiableattributeinstance.removeModifier(SOUL_SPEED_BOOT_ID);
            }
        }
    }

    protected void func_233642_cO_() {
        if (!this.getStateBelow().isAir()) {
            int i = EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.SOUL_SPEED, this);

            if (i > 0 && this.func_230296_cM_()) {
                ModifiableAttributeInstance modifiableattributeinstance = this.getAttribute(Attributes.MOVEMENT_SPEED);

                if (modifiableattributeinstance == null) {
                    return;
                }

                modifiableattributeinstance.applyNonPersistentModifier(new AttributeModifier(SOUL_SPEED_BOOT_ID, "Soul speed boost", (double) (0.03F * (1.0F + (float) i * 0.35F)), AttributeModifier.Operation.ADDITION));

                if (this.getRNG().nextFloat() < 0.04F) {
                    ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.FEET);
                    itemstack.damageItem(1, this, (p_233654_0_) ->
                    {
                        p_233654_0_.sendBreakAnimation(EquipmentSlotType.FEET);
                    });
                }
            }
        }
    }

    protected void frostWalk(BlockPos pos) {
        int i = EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.FROST_WALKER, this);

        if (i > 0) {
            FrostWalkerEnchantment.freezeNearby(this, this.world, pos, i);
        }

        if (this.func_230295_b_(this.getStateBelow())) {
            this.func_233641_cN_();
        }

        this.func_233642_cO_();
    }

    /**
     * If Animal, checks if the age timer is negative
     */
    public boolean isChild() {
        return false;
    }

    public float getRenderScale() {
        return this.isChild() ? 0.5F : 1.0F;
    }

    protected boolean func_241208_cS_() {
        return true;
    }

    public boolean canBeRiddenInWater() {
        return false;
    }

    /**
     * handles entity death timer, experience orb and particle creation
     */
    protected void onDeathUpdate() {
        ++this.deathTime;

        if (this.deathTime == 20) {
            this.remove();

            for (int i = 0; i < 20; ++i) {
                double d0 = this.rand.nextGaussian() * 0.02D;
                double d1 = this.rand.nextGaussian() * 0.02D;
                double d2 = this.rand.nextGaussian() * 0.02D;
                this.world.addParticle(ParticleTypes.POOF, this.getPosXRandom(1.0D), this.getPosYRandom(), this.getPosZRandom(1.0D), d0, d1, d2);
            }
        }
    }

    /**
     * Entity won't drop items or experience points if this returns false
     */
    protected boolean canDropLoot() {
        return !this.isChild();
    }

    protected boolean func_230282_cS_() {
        return !this.isChild();
    }

    /**
     * Decrements the entity's air supply when underwater
     */
    protected int decreaseAirSupply(int air) {
        int i = EnchantmentHelper.getRespirationModifier(this);
        return i > 0 && this.rand.nextInt(i + 1) > 0 ? air : air - 1;
    }

    protected int determineNextAir(int currentAir) {
        return Math.min(currentAir + 4, this.getMaxAir());
    }

    /**
     * Get the experience points the entity currently has.
     */
    protected int getExperiencePoints(PlayerEntity player) {
        return 0;
    }

    /**
     * Only use is to identify if class is an instance of player for experience dropping
     */
    protected boolean isPlayer() {
        return false;
    }

    public Random getRNG() {
        return this.rand;
    }

    @Nullable
    public LivingEntity getRevengeTarget() {
        return this.revengeTarget;
    }

    public int getRevengeTimer() {
        return this.revengeTimer;
    }

    public void func_230246_e_(@Nullable PlayerEntity p_230246_1_) {
        this.attackingPlayer = p_230246_1_;
        this.recentlyHit = this.ticksExisted;
    }

    /**
     * Hint to AI tasks that we were attacked by the passed EntityLivingBase and should retaliate. Is not guaranteed to
     * change our actual active target (for example if we are currently busy attacking someone else)
     */
    public void setRevengeTarget(@Nullable LivingEntity livingBase) {
        this.revengeTarget = livingBase;
        this.revengeTimer = this.ticksExisted;
    }

    @Nullable
    public LivingEntity getLastAttackedEntity() {
        return this.lastAttackedEntity;
    }

    public int getLastAttackedEntityTime() {
        return this.lastAttackedEntityTime;
    }

    public void setLastAttackedEntity(Entity entityIn) {
        if (entityIn instanceof LivingEntity) {
            this.lastAttackedEntity = (LivingEntity) entityIn;
        } else {
            this.lastAttackedEntity = null;
        }

        this.lastAttackedEntityTime = this.ticksExisted;
    }

    public int getIdleTime() {
        return this.idleTime;
    }

    public void setIdleTime(int idleTimeIn) {
        this.idleTime = idleTimeIn;
    }

    protected void playEquipSound(ItemStack stack) {
        if (!stack.isEmpty()) {
            SoundEvent soundevent = SoundEvents.ITEM_ARMOR_EQUIP_GENERIC;
            Item item = stack.getItem();

            if (item instanceof ArmorItem) {
                soundevent = ((ArmorItem) item).getArmorMaterial().getSoundEvent();
            } else if (item == Items.ELYTRA) {
                soundevent = SoundEvents.ITEM_ARMOR_EQUIP_ELYTRA;
            }

            this.playSound(soundevent, 1.0F, 1.0F);
        }
    }

    public void writeAdditional(CompoundNBT compound) {
        compound.putFloat("Health", this.getHealth());
        compound.putShort("HurtTime", (short) this.hurtTime);
        compound.putInt("HurtByTimestamp", this.revengeTimer);
        compound.putShort("DeathTime", (short) this.deathTime);
        compound.putFloat("AbsorptionAmount", this.getAbsorptionAmount());
        compound.put("Attributes", this.getAttributeManager().serialize());

        if (!this.activePotionsMap.isEmpty()) {
            ListNBT listnbt = new ListNBT();

            for (EffectInstance effectinstance : this.activePotionsMap.values()) {
                listnbt.add(effectinstance.write(new CompoundNBT()));
            }

            compound.put("ActiveEffects", listnbt);
        }

        compound.putBoolean("FallFlying", this.isElytraFlying());
        this.getBedPosition().ifPresent((p_213338_1_) ->
        {
            compound.putInt("SleepingX", p_213338_1_.getX());
            compound.putInt("SleepingY", p_213338_1_.getY());
            compound.putInt("SleepingZ", p_213338_1_.getZ());
        });
        DataResult<INBT> dataresult = this.brain.encode(NBTDynamicOps.INSTANCE);
        dataresult.resultOrPartial(LOGGER::error).ifPresent((p_233636_1_) ->
        {
            compound.put("Brain", p_233636_1_);
        });
    }

    /**
     * (abstract) Protected helper method to read subclass entity data from NBT.
     */
    public void readAdditional(CompoundNBT compound) {
        this.setAbsorptionAmount(compound.getFloat("AbsorptionAmount"));

        if (compound.contains("Attributes", 9) && this.world != null && !this.world.isRemote) {
            this.getAttributeManager().deserialize(compound.getList("Attributes", 10));
        }

        if (compound.contains("ActiveEffects", 9)) {
            ListNBT listnbt = compound.getList("ActiveEffects", 10);

            for (int i = 0; i < listnbt.size(); ++i) {
                CompoundNBT compoundnbt = listnbt.getCompound(i);
                EffectInstance effectinstance = EffectInstance.read(compoundnbt);

                if (effectinstance != null) {
                    this.activePotionsMap.put(effectinstance.getPotion(), effectinstance);
                }
            }
        }

        if (compound.contains("Health", 99)) {
            this.setHealth(compound.getFloat("Health"));
        }

        this.hurtTime = compound.getShort("HurtTime");
        this.deathTime = compound.getShort("DeathTime");
        this.revengeTimer = compound.getInt("HurtByTimestamp");

        if (compound.contains("Team", 8)) {
            String s = compound.getString("Team");
            ScorePlayerTeam scoreplayerteam = this.world.getScoreboard().getTeam(s);
            boolean flag = scoreplayerteam != null && this.world.getScoreboard().addPlayerToTeam(this.getCachedUniqueIdString(), scoreplayerteam);

            if (!flag) {
                LOGGER.warn("Unable to add mob to team \"{}\" (that team probably doesn't exist)", (Object) s);
            }
        }

        if (compound.getBoolean("FallFlying")) {
            this.setFlag(7, true);
        }

        if (compound.contains("SleepingX", 99) && compound.contains("SleepingY", 99) && compound.contains("SleepingZ", 99)) {
            BlockPos blockpos = new BlockPos(compound.getInt("SleepingX"), compound.getInt("SleepingY"), compound.getInt("SleepingZ"));
            this.setBedPosition(blockpos);
            this.dataManager.set(POSE, Pose.SLEEPING);

            if (!this.firstUpdate) {
                this.setSleepingPosition(blockpos);
            }
        }

        if (compound.contains("Brain", 10)) {
            this.brain = this.createBrain(new Dynamic<>(NBTDynamicOps.INSTANCE, compound.get("Brain")));
        }
    }

    protected void updatePotionEffects() {
        Iterator<Effect> iterator = this.activePotionsMap.keySet().iterator();

        try {
            while (iterator.hasNext()) {
                Effect effect = iterator.next();
                EffectInstance effectinstance = this.activePotionsMap.get(effect);

                if (!effectinstance.tick(this, () ->
                {
                    this.onChangedPotionEffect(effectinstance, true);
                })) {
                    if (!this.world.isRemote) {
                        iterator.remove();
                        this.onFinishedPotionEffect(effectinstance);
                    }
                } else if (effectinstance.getDuration() % 600 == 0) {
                    this.onChangedPotionEffect(effectinstance, false);
                }
            }
        } catch (ConcurrentModificationException concurrentmodificationexception) {
        }

        if (this.potionsNeedUpdate) {
            if (!this.world.isRemote) {
                this.updatePotionMetadata();
            }

            this.potionsNeedUpdate = false;
        }

        int i = this.dataManager.get(POTION_EFFECTS);
        boolean flag1 = this.dataManager.get(HIDE_PARTICLES);

        if (i > 0) {
            boolean flag;

            if (this.isInvisible()) {
                flag = this.rand.nextInt(15) == 0;
            } else {
                flag = this.rand.nextBoolean();
            }

            if (flag1) {
                flag &= this.rand.nextInt(5) == 0;
            }

            if (flag && i > 0) {
                double d0 = (double) (i >> 16 & 255) / 255.0D;
                double d1 = (double) (i >> 8 & 255) / 255.0D;
                double d2 = (double) (i >> 0 & 255) / 255.0D;
                this.world.addParticle(flag1 ? ParticleTypes.AMBIENT_ENTITY_EFFECT : ParticleTypes.ENTITY_EFFECT, this.getPosXRandom(0.5D), this.getPosYRandom(), this.getPosZRandom(0.5D), d0, d1, d2);
            }
        }
    }

    /**
     * Clears potion metadata values if the entity has no potion effects. Otherwise, updates potion effect color,
     * ambience, and invisibility metadata values
     */
    protected void updatePotionMetadata() {
        if (this.activePotionsMap.isEmpty()) {
            this.resetPotionEffectMetadata();
            this.setInvisible(false);
        } else {
            Collection<EffectInstance> collection = this.activePotionsMap.values();
            this.dataManager.set(HIDE_PARTICLES, areAllPotionsAmbient(collection));
            this.dataManager.set(POTION_EFFECTS, PotionUtils.getPotionColorFromEffectList(collection));
            this.setInvisible(this.isPotionActive(Effects.INVISIBILITY));
        }
    }

    public double getVisibilityMultiplier(@Nullable Entity lookingEntity) {
        double d0 = 1.0D;

        if (this.isDiscrete()) {
            d0 *= 0.8D;
        }

        if (this.isInvisible()) {
            float f = this.getArmorCoverPercentage();

            if (f < 0.1F) {
                f = 0.1F;
            }

            d0 *= 0.7D * (double) f;
        }

        if (lookingEntity != null) {
            ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.HEAD);
            Item item = itemstack.getItem();
            EntityType<?> entitytype = lookingEntity.getType();

            if (entitytype == EntityType.SKELETON && item == Items.SKELETON_SKULL || entitytype == EntityType.ZOMBIE && item == Items.ZOMBIE_HEAD || entitytype == EntityType.CREEPER && item == Items.CREEPER_HEAD) {
                d0 *= 0.5D;
            }
        }

        return d0;
    }

    public boolean canAttack(LivingEntity target) {
        return true;
    }

    public boolean canAttack(LivingEntity livingentityIn, EntityPredicate predicateIn) {
        return predicateIn.canTarget(this, livingentityIn);
    }

    /**
     * Returns true if all of the potion effects in the specified collection are ambient.
     */
    public static boolean areAllPotionsAmbient(Collection<EffectInstance> potionEffects) {
        for (EffectInstance effectinstance : potionEffects) {
            if (!effectinstance.isAmbient()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Resets the potion effect color and ambience metadata values
     */
    protected void resetPotionEffectMetadata() {
        this.dataManager.set(HIDE_PARTICLES, false);
        this.dataManager.set(POTION_EFFECTS, 0);
    }

    public boolean clearActivePotions() {
        if (this.world.isRemote) {
            return false;
        } else {
            Iterator<EffectInstance> iterator = this.activePotionsMap.values().iterator();
            boolean flag;

            for (flag = false; iterator.hasNext(); flag = true) {
                this.onFinishedPotionEffect(iterator.next());
                iterator.remove();
            }

            return flag;
        }
    }

    public Collection<EffectInstance> getActivePotionEffects() {
        return this.activePotionsMap.values();
    }

    public Map<Effect, EffectInstance> getActivePotionMap() {
        return this.activePotionsMap;
    }

    public boolean isPotionActive(Effect potionIn) {
        return this.activePotionsMap.containsKey(potionIn);
    }

    @Nullable

    /**
     * returns the PotionEffect for the supplied Potion if it is active, null otherwise.
     */
    public EffectInstance getActivePotionEffect(Effect potionIn) {
        return this.activePotionsMap.get(potionIn);
    }

    public boolean addPotionEffect(EffectInstance effectInstanceIn) {
        if (!this.isPotionApplicable(effectInstanceIn)) {
            return false;
        } else {
            EffectInstance effectinstance = this.activePotionsMap.get(effectInstanceIn.getPotion());

            if (effectinstance == null) {
                this.activePotionsMap.put(effectInstanceIn.getPotion(), effectInstanceIn);
                this.onNewPotionEffect(effectInstanceIn);
                return true;
            } else if (effectinstance.combine(effectInstanceIn)) {
                this.onChangedPotionEffect(effectinstance, true);
                return true;
            } else {
                return false;
            }
        }
    }

    public boolean isPotionApplicable(EffectInstance potioneffectIn) {
        if (this.getCreatureAttribute() == CreatureAttribute.UNDEAD) {
            Effect effect = potioneffectIn.getPotion();

            if (effect == Effects.REGENERATION || effect == Effects.POISON) {
                return false;
            }
        }

        return true;
    }

    public void func_233646_e_(EffectInstance p_233646_1_) {
        if (this.isPotionApplicable(p_233646_1_)) {
            EffectInstance effectinstance = this.activePotionsMap.put(p_233646_1_.getPotion(), p_233646_1_);

            if (effectinstance == null) {
                this.onNewPotionEffect(p_233646_1_);
            } else {
                this.onChangedPotionEffect(p_233646_1_, true);
            }
        }
    }

    /**
     * Returns true if this entity is undead.
     */
    public boolean isEntityUndead() {
        return this.getCreatureAttribute() == CreatureAttribute.UNDEAD;
    }

    @Nullable

    /**
     * Removes the given potion effect from the active potion map and returns it. Does not call cleanup callbacks for
     * the end of the potion effect.
     */
    public EffectInstance removeActivePotionEffect(@Nullable Effect potioneffectin) {
        return this.activePotionsMap.remove(potioneffectin);
    }

    public boolean removePotionEffect(Effect effectIn) {
        EffectInstance effectinstance = this.removeActivePotionEffect(effectIn);

        if (effectinstance != null) {
            this.onFinishedPotionEffect(effectinstance);
            return true;
        } else {
            return false;
        }
    }

    protected void onNewPotionEffect(EffectInstance id) {
        this.potionsNeedUpdate = true;

        if (!this.world.isRemote) {
            id.getPotion().applyAttributesModifiersToEntity(this, this.getAttributeManager(), id.getAmplifier());
        }
    }

    protected void onChangedPotionEffect(EffectInstance id, boolean reapply) {
        this.potionsNeedUpdate = true;

        if (reapply && !this.world.isRemote) {
            Effect effect = id.getPotion();
            effect.removeAttributesModifiersFromEntity(this, this.getAttributeManager(), id.getAmplifier());
            effect.applyAttributesModifiersToEntity(this, this.getAttributeManager(), id.getAmplifier());
        }
    }

    protected void onFinishedPotionEffect(EffectInstance effect) {
        this.potionsNeedUpdate = true;

        if (!this.world.isRemote) {
            effect.getPotion().removeAttributesModifiersFromEntity(this, this.getAttributeManager(), effect.getAmplifier());
        }
    }

    /**
     * Heal living entity (param: amount of half-hearts)
     */
    public void heal(float healAmount) {
        float f = this.getHealth();

        if (f > 0.0F) {
            this.setHealth(f + healAmount);
        }
    }

    public float getHealth() {
        return this.dataManager.get(HEALTH);
    }

    public void setHealth(float health) {
        this.dataManager.set(HEALTH, MathHelper.clamp(health, 0.0F, this.getMaxHealth()));
    }

    public boolean getShouldBeDead() {
        return this.getHealth() <= 0.0F;
    }

    /**
     * Called when the entity is attacked.
     */
    public boolean attackEntityFrom(DamageSource source, float amount) {
        if (this.isInvulnerableTo(source)) {
            return false;
        } else if (this.world.isRemote) {
            return false;
        } else if (this.getShouldBeDead()) {
            return false;
        } else if (source.isFireDamage() && this.isPotionActive(Effects.FIRE_RESISTANCE)) {
            return false;
        } else {
            if (this.isSleeping() && !this.world.isRemote) {
                this.wakeUp();
            }

            this.idleTime = 0;
            float f = amount;

            if ((source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) && !this.getItemStackFromSlot(EquipmentSlotType.HEAD).isEmpty()) {
                this.getItemStackFromSlot(EquipmentSlotType.HEAD).damageItem((int) (amount * 4.0F + this.rand.nextFloat() * amount * 2.0F), this, (p_233653_0_) ->
                {
                    p_233653_0_.sendBreakAnimation(EquipmentSlotType.HEAD);
                });
                amount *= 0.75F;
            }

            boolean flag = false;
            float f1 = 0.0F;

            if (amount > 0.0F && this.canBlockDamageSource(source)) {
                this.damageShield(amount);
                f1 = amount;
                amount = 0.0F;

                if (!source.isProjectile()) {
                    Entity entity = source.getImmediateSource();

                    if (entity instanceof LivingEntity) {
                        this.blockUsingShield((LivingEntity) entity);
                    }
                }

                flag = true;
            }

            this.limbSwingAmount = 1.5F;
            boolean flag1 = true;

            if ((float) this.hurtResistantTime > 10.0F) {
                if (amount <= this.lastDamage) {
                    return false;
                }

                this.damageEntity(source, amount - this.lastDamage);
                this.lastDamage = amount;
                flag1 = false;
            } else {
                this.lastDamage = amount;
                this.hurtResistantTime = 20;
                this.damageEntity(source, amount);
                this.maxHurtTime = 10;
                this.hurtTime = this.maxHurtTime;
            }

            this.attackedAtYaw = 0.0F;
            Entity entity1 = source.getTrueSource();

            if (entity1 != null) {
                if (entity1 instanceof LivingEntity) {
                    this.setRevengeTarget((LivingEntity) entity1);
                }

                if (entity1 instanceof PlayerEntity) {
                    this.recentlyHit = 100;
                    this.attackingPlayer = (PlayerEntity) entity1;
                } else if (entity1 instanceof WolfEntity) {
                    WolfEntity wolfentity = (WolfEntity) entity1;

                    if (wolfentity.isTamed()) {
                        this.recentlyHit = 100;
                        LivingEntity livingentity = wolfentity.getOwner();

                        if (livingentity != null && livingentity.getType() == EntityType.PLAYER) {
                            this.attackingPlayer = (PlayerEntity) livingentity;
                        } else {
                            this.attackingPlayer = null;
                        }
                    }
                }
            }

            if (flag1) {
                if (flag) {
                    this.world.setEntityState(this, (byte) 29);
                } else if (source instanceof EntityDamageSource && ((EntityDamageSource) source).getIsThornsDamage()) {
                    this.world.setEntityState(this, (byte) 33);
                } else {
                    byte b0;

                    if (source == DamageSource.DROWN) {
                        b0 = 36;
                    } else if (source.isFireDamage()) {
                        b0 = 37;
                    } else if (source == DamageSource.SWEET_BERRY_BUSH) {
                        b0 = 44;
                    } else {
                        b0 = 2;
                    }

                    this.world.setEntityState(this, b0);
                }

                if (source != DamageSource.DROWN && (!flag || amount > 0.0F)) {
                    this.markVelocityChanged();
                }

                if (entity1 != null) {
                    double d1 = entity1.getPosX() - this.getPosX();
                    double d0;

                    for (d0 = entity1.getPosZ() - this.getPosZ(); d1 * d1 + d0 * d0 < 1.0E-4D; d0 = (Math.random() - Math.random()) * 0.01D) {
                        d1 = (Math.random() - Math.random()) * 0.01D;
                    }

                    this.attackedAtYaw = (float) (MathHelper.atan2(d0, d1) * (double) (180F / (float) Math.PI) - (double) this.rotationYaw);
                    this.applyKnockback(0.4F, d1, d0);
                } else {
                    this.attackedAtYaw = (float) ((int) (Math.random() * 2.0D) * 180);
                }
            }

            if (this.getShouldBeDead()) {
                if (!this.checkTotemDeathProtection(source)) {
                    SoundEvent soundevent = this.getDeathSound();

                    if (flag1 && soundevent != null) {
                        this.playSound(soundevent, this.getSoundVolume(), this.getSoundPitch());
                    }

                    this.onDeath(source);
                }
            } else if (flag1) {
                this.playHurtSound(source);
            }

            boolean flag2 = !flag || amount > 0.0F;

            if (flag2) {
                this.lastDamageSource = source;
                this.lastDamageStamp = this.world.getGameTime();
            }

            if (this instanceof ServerPlayerEntity) {
                CriteriaTriggers.ENTITY_HURT_PLAYER.trigger((ServerPlayerEntity) this, source, f, amount, flag);

                if (f1 > 0.0F && f1 < 3.4028235E37F) {
                    ((ServerPlayerEntity) this).addStat(Stats.DAMAGE_BLOCKED_BY_SHIELD, Math.round(f1 * 10.0F));
                }
            }

            if (entity1 instanceof ServerPlayerEntity) {
                CriteriaTriggers.PLAYER_HURT_ENTITY.trigger((ServerPlayerEntity) entity1, this, source, f, amount, flag);
            }

            return flag2;
        }
    }

    protected void blockUsingShield(LivingEntity entityIn) {
        entityIn.constructKnockBackVector(this);
    }

    protected void constructKnockBackVector(LivingEntity entityIn) {
        entityIn.applyKnockback(0.5F, entityIn.getPosX() - this.getPosX(), entityIn.getPosZ() - this.getPosZ());
    }

    private boolean checkTotemDeathProtection(DamageSource damageSourceIn) {
        if (damageSourceIn.canHarmInCreative()) {
            return false;
        } else {
            ItemStack itemstack = null;

            for (Hand hand : Hand.values()) {
                ItemStack itemstack1 = this.getHeldItem(hand);

                if (itemstack1.getItem() == Items.TOTEM_OF_UNDYING) {
                    itemstack = itemstack1.copy();
                    itemstack1.shrink(1);
                    break;
                }
            }

            if (itemstack != null) {
                if (this instanceof ServerPlayerEntity) {
                    ServerPlayerEntity serverplayerentity = (ServerPlayerEntity) this;
                    serverplayerentity.addStat(Stats.ITEM_USED.get(Items.TOTEM_OF_UNDYING));
                    CriteriaTriggers.USED_TOTEM.trigger(serverplayerentity, itemstack);
                }

                this.setHealth(1.0F);
                this.clearActivePotions();
                this.addPotionEffect(new EffectInstance(Effects.REGENERATION, 900, 1));
                this.addPotionEffect(new EffectInstance(Effects.ABSORPTION, 100, 1));
                this.addPotionEffect(new EffectInstance(Effects.FIRE_RESISTANCE, 800, 0));
                this.world.setEntityState(this, (byte) 35);
            }

            return itemstack != null;
        }
    }

    @Nullable
    public DamageSource getLastDamageSource() {
        if (this.world.getGameTime() - this.lastDamageStamp > 40L) {
            this.lastDamageSource = null;
        }

        return this.lastDamageSource;
    }

    protected void playHurtSound(DamageSource source) {
        SoundEvent soundevent = this.getHurtSound(source);

        if (soundevent != null) {
            this.playSound(soundevent, this.getSoundVolume(), this.getSoundPitch());
        }
    }

    /**
     * Determines whether the entity can block the damage source based on the damage source's location, whether the
     * damage source is blockable, and whether the entity is blocking.
     */
    private boolean canBlockDamageSource(DamageSource damageSourceIn) {
        Entity entity = damageSourceIn.getImmediateSource();
        boolean flag = false;

        if (entity instanceof AbstractArrowEntity) {
            AbstractArrowEntity abstractarrowentity = (AbstractArrowEntity) entity;

            if (abstractarrowentity.getPierceLevel() > 0) {
                flag = true;
            }
        }

        if (!damageSourceIn.isUnblockable() && this.isActiveItemStackBlocking() && !flag) {
            Vector3d vector3d2 = damageSourceIn.getDamageLocation();

            if (vector3d2 != null) {
                Vector3d vector3d = this.getLook(1.0F);
                Vector3d vector3d1 = vector3d2.subtractReverse(this.getPositionVec()).normalize();
                vector3d1 = new Vector3d(vector3d1.x, 0.0D, vector3d1.z);

                if (vector3d1.dotProduct(vector3d) < 0.0D) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Renders broken item particles using the given ItemStack
     */
    private void renderBrokenItemStack(ItemStack stack) {
        if (!stack.isEmpty()) {
            if (!this.isSilent()) {
                this.world.playSound(this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.ENTITY_ITEM_BREAK, this.getSoundCategory(), 0.8F, 0.8F + this.world.rand.nextFloat() * 0.4F, false);
            }

            this.addItemParticles(stack, 5);
        }
    }

    /**
     * Called when the mob's health reaches 0.
     */
    public void onDeath(DamageSource cause) {
        if (!this.removed && !this.dead) {
            Entity entity = cause.getTrueSource();
            LivingEntity livingentity = this.getAttackingEntity();

            if (this.scoreValue >= 0 && livingentity != null) {
                livingentity.awardKillScore(this, this.scoreValue, cause);
            }

            if (this.isSleeping()) {
                this.wakeUp();
            }

            this.dead = true;
            this.getCombatTracker().reset();

            if (this.world instanceof ServerWorld) {
                if (entity != null) {
                    entity.func_241847_a((ServerWorld) this.world, this);
                }

                this.spawnDrops(cause);
                this.createWitherRose(livingentity);
            }

            this.world.setEntityState(this, (byte) 3);
            this.setPose(Pose.DYING);
        }
    }

    protected void createWitherRose(@Nullable LivingEntity entitySource) {
        if (!this.world.isRemote) {
            boolean flag = false;

            if (entitySource instanceof WitherEntity) {
                if (this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING)) {
                    BlockPos blockpos = this.getPosition();
                    BlockState blockstate = Blocks.WITHER_ROSE.getDefaultState();

                    if (this.world.getBlockState(blockpos).isAir() && blockstate.isValidPosition(this.world, blockpos)) {
                        this.world.setBlockState(blockpos, blockstate, 3);
                        flag = true;
                    }
                }

                if (!flag) {
                    ItemEntity itementity = new ItemEntity(this.world, this.getPosX(), this.getPosY(), this.getPosZ(), new ItemStack(Items.WITHER_ROSE));
                    this.world.addEntity(itementity);
                }
            }
        }
    }

    protected void spawnDrops(DamageSource damageSourceIn) {
        Entity entity = damageSourceIn.getTrueSource();
        int i;

        if (entity instanceof PlayerEntity) {
            i = EnchantmentHelper.getLootingModifier((LivingEntity) entity);
        } else {
            i = 0;
        }

        boolean flag = this.recentlyHit > 0;

        if (this.func_230282_cS_() && this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT)) {
            this.dropLoot(damageSourceIn, flag);
            this.dropSpecialItems(damageSourceIn, i, flag);
        }

        this.dropInventory();
        this.dropExperience();
    }

    protected void dropInventory() {
    }

    protected void dropExperience() {
        if (!this.world.isRemote && (this.isPlayer() || this.recentlyHit > 0 && this.canDropLoot() && this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT))) {
            int i = this.getExperiencePoints(this.attackingPlayer);

            while (i > 0) {
                int j = ExperienceOrbEntity.getXPSplit(i);
                i -= j;
                this.world.addEntity(new ExperienceOrbEntity(this.world, this.getPosX(), this.getPosY(), this.getPosZ(), j));
            }
        }
    }

    protected void dropSpecialItems(DamageSource source, int looting, boolean recentlyHitIn) {
    }

    public ResourceLocation getLootTableResourceLocation() {
        return this.getType().getLootTable();
    }

    protected void dropLoot(DamageSource damageSourceIn, boolean attackedRecently) {
        ResourceLocation resourcelocation = this.getLootTableResourceLocation();
        LootTable loottable = this.world.getServer().getLootTableManager().getLootTableFromLocation(resourcelocation);
        LootContext.Builder lootcontext$builder = this.getLootContextBuilder(attackedRecently, damageSourceIn);
        loottable.generate(lootcontext$builder.build(LootParameterSets.ENTITY), this::entityDropItem);
    }

    protected LootContext.Builder getLootContextBuilder(boolean attackedRecently, DamageSource damageSourceIn) {
        LootContext.Builder lootcontext$builder = (new LootContext.Builder((ServerWorld) this.world)).withRandom(this.rand).withParameter(LootParameters.THIS_ENTITY, this).withParameter(LootParameters.field_237457_g_, this.getPositionVec()).withParameter(LootParameters.DAMAGE_SOURCE, damageSourceIn).withNullableParameter(LootParameters.KILLER_ENTITY, damageSourceIn.getTrueSource()).withNullableParameter(LootParameters.DIRECT_KILLER_ENTITY, damageSourceIn.getImmediateSource());

        if (attackedRecently && this.attackingPlayer != null) {
            lootcontext$builder = lootcontext$builder.withParameter(LootParameters.LAST_DAMAGE_PLAYER, this.attackingPlayer).withLuck(this.attackingPlayer.getLuck());
        }

        return lootcontext$builder;
    }

    public void applyKnockback(float strength, double ratioX, double ratioZ) {
        strength = (float) ((double) strength * (1.0D - this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE)));

        if (!(strength <= 0.0F)) {
            this.isAirBorne = true;
            Vector3d vector3d = this.getMotion();
            Vector3d vector3d1 = (new Vector3d(ratioX, 0.0D, ratioZ)).normalize().scale((double) strength);
            this.setMotion(vector3d.x / 2.0D - vector3d1.x, this.onGround ? Math.min(0.4D, vector3d.y / 2.0D + (double) strength) : vector3d.y, vector3d.z / 2.0D - vector3d1.z);
        }
    }

    @Nullable
    protected SoundEvent getHurtSound(DamageSource damageSourceIn) {
        return SoundEvents.ENTITY_GENERIC_HURT;
    }

    @Nullable
    protected SoundEvent getDeathSound() {
        return SoundEvents.ENTITY_GENERIC_DEATH;
    }

    protected SoundEvent getFallSound(int heightIn) {
        return heightIn > 4 ? SoundEvents.ENTITY_GENERIC_BIG_FALL : SoundEvents.ENTITY_GENERIC_SMALL_FALL;
    }

    protected SoundEvent getDrinkSound(ItemStack stack) {
        return stack.getDrinkSound();
    }

    public SoundEvent getEatSound(ItemStack itemStackIn) {
        return itemStackIn.getEatSound();
    }

    public void setOnGround(boolean grounded) {
        super.setOnGround(grounded);

        if (grounded) {
            this.field_233624_bE_ = Optional.empty();
        }
    }

    public Optional<BlockPos> func_233644_dn_() {
        return this.field_233624_bE_;
    }

    /**
     * Returns true if this entity should move as if it were on a ladder (either because it's actually on a ladder, or
     * for AI reasons)
     */
    public boolean isOnLadder() {
        if (this.isSpectator()) {
            return false;
        } else {
            BlockPos blockpos = this.getPosition();
            BlockState blockstate = this.getBlockState();
            Block block = blockstate.getBlock();

            if (block.isIn(BlockTags.CLIMBABLE)) {
                this.field_233624_bE_ = Optional.of(blockpos);
                return true;
            } else if (block instanceof TrapDoorBlock && this.canGoThroughtTrapDoorOnLadder(blockpos, blockstate)) {
                this.field_233624_bE_ = Optional.of(blockpos);
                return true;
            } else {
                return false;
            }
        }
    }

    public BlockState getBlockState() {
        return this.world.getBlockState(this.getPosition());
    }

    private boolean canGoThroughtTrapDoorOnLadder(BlockPos pos, BlockState state) {
        if (state.get(TrapDoorBlock.OPEN)) {
            BlockState blockstate = this.world.getBlockState(pos.down());

            if (blockstate.isIn(Blocks.LADDER) && blockstate.get(LadderBlock.FACING) == state.get(TrapDoorBlock.HORIZONTAL_FACING)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns true if the entity has not been {@link #removed}.
     */
    public boolean isAlive() {
        return !this.removed && this.getHealth() > 0.0F;
    }

    public boolean onLivingFall(float distance, float damageMultiplier) {
        boolean flag = super.onLivingFall(distance, damageMultiplier);
        int i = this.calculateFallDamage(distance, damageMultiplier);

        if (i > 0) {
            this.playSound(this.getFallSound(i), 1.0F, 1.0F);
            this.playFallSound();
            this.attackEntityFrom(DamageSource.FALL, (float) i);
            if (this instanceof ClientPlayerEntity) {
                EventManager.call(new EventDamage(EventDamage.DamageType.FALL));
            }
            return true;
        } else {
            return flag;
        }
    }

    protected int calculateFallDamage(float distance, float damageMultiplier) {
        EffectInstance effectinstance = this.getActivePotionEffect(Effects.JUMP_BOOST);
        float f = effectinstance == null ? 0.0F : (float) (effectinstance.getAmplifier() + 1);
        return MathHelper.ceil((distance - 3.0F - f) * damageMultiplier);
    }

    /**
     * Plays the fall sound for the block landed on
     */
    protected void playFallSound() {
        if (!this.isSilent()) {
            int i = MathHelper.floor(this.getPosX());
            int j = MathHelper.floor(this.getPosY() - (double) 0.2F);
            int k = MathHelper.floor(this.getPosZ());
            BlockState blockstate = this.world.getBlockState(new BlockPos(i, j, k));

            if (!blockstate.isAir()) {
                SoundType soundtype = blockstate.getSoundType();
                this.playSound(soundtype.getFallSound(), soundtype.getVolume() * 0.5F, soundtype.getPitch() * 0.75F);
            }
        }
    }

    /**
     * Setups the entity to do the hurt animation. Only used by packets in multiplayer.
     */
    public void performHurtAnimation() {
        this.maxHurtTime = 10;
        this.hurtTime = this.maxHurtTime;
        this.attackedAtYaw = 0.0F;
    }

    /**
     * Returns the current armor value as determined by a call to InventoryPlayer.getTotalArmorValue
     */
    public int getTotalArmorValue() {
        return MathHelper.floor(this.getAttributeValue(Attributes.ARMOR));
    }

    protected void damageArmor(DamageSource damageSource, float damage) {
    }

    protected void damageShield(float damage) {
    }

    /**
     * Reduces damage, depending on armor
     */
    protected float applyArmorCalculations(DamageSource source, float damage) {
        if (!source.isUnblockable()) {
            this.damageArmor(source, damage);
            damage = CombatRules.getDamageAfterAbsorb(damage, (float) this.getTotalArmorValue(), (float) this.getAttributeValue(Attributes.ARMOR_TOUGHNESS));
        }

        return damage;
    }

    /**
     * Reduces damage, depending on potions
     */
    protected float applyPotionDamageCalculations(DamageSource source, float damage) {
        if (source.isDamageAbsolute()) {
            return damage;
        } else {
            if (this.isPotionActive(Effects.RESISTANCE) && source != DamageSource.OUT_OF_WORLD) {
                int i = (this.getActivePotionEffect(Effects.RESISTANCE).getAmplifier() + 1) * 5;
                int j = 25 - i;
                float f = damage * (float) j;
                float f1 = damage;
                damage = Math.max(f / 25.0F, 0.0F);
                float f2 = f1 - damage;

                if (f2 > 0.0F && f2 < 3.4028235E37F) {
                    if (this instanceof ServerPlayerEntity) {
                        ((ServerPlayerEntity) this).addStat(Stats.DAMAGE_RESISTED, Math.round(f2 * 10.0F));
                    } else if (source.getTrueSource() instanceof ServerPlayerEntity) {
                        ((ServerPlayerEntity) source.getTrueSource()).addStat(Stats.DAMAGE_DEALT_RESISTED, Math.round(f2 * 10.0F));
                    }
                }
            }

            if (damage <= 0.0F) {
                return 0.0F;
            } else {
                int k = EnchantmentHelper.getEnchantmentModifierDamage(this.getArmorInventoryList(), source);

                if (k > 0) {
                    damage = CombatRules.getDamageAfterMagicAbsorb(damage, (float) k);
                }

                return damage;
            }
        }
    }

    /**
     * Deals damage to the entity. This will take the armor of the entity into consideration before damaging the health
     * bar.
     */
    protected void damageEntity(DamageSource damageSrc, float damageAmount) {
        if (!this.isInvulnerableTo(damageSrc)) {
            damageAmount = this.applyArmorCalculations(damageSrc, damageAmount);
            damageAmount = this.applyPotionDamageCalculations(damageSrc, damageAmount);
            float f2 = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
            this.setAbsorptionAmount(this.getAbsorptionAmount() - (damageAmount - f2));
            float f = damageAmount - f2;

            if (f > 0.0F && f < 3.4028235E37F && damageSrc.getTrueSource() instanceof ServerPlayerEntity) {
                ((ServerPlayerEntity) damageSrc.getTrueSource()).addStat(Stats.DAMAGE_DEALT_ABSORBED, Math.round(f * 10.0F));
            }

            if (f2 != 0.0F) {
                float f1 = this.getHealth();
                this.setHealth(f1 - f2);
                this.getCombatTracker().trackDamage(damageSrc, f1, f2);
                this.setAbsorptionAmount(this.getAbsorptionAmount() - f2);
            }
        }
    }

    /**
     * 1.8.9
     */
    public CombatTracker getCombatTracker() {
        return this.combatTracker;
    }

    @Nullable
    public LivingEntity getAttackingEntity() {
        if (this.combatTracker.getBestAttacker() != null) {
            return this.combatTracker.getBestAttacker();
        } else if (this.attackingPlayer != null) {
            return this.attackingPlayer;
        } else {
            return this.revengeTarget != null ? this.revengeTarget : null;
        }
    }

    /**
     * Returns the maximum health of the entity (what it is able to regenerate up to, what it spawned with, etc)
     */
    public final float getMaxHealth() {
        return (float) this.getAttributeValue(Attributes.MAX_HEALTH);
    }

    /**
     * counts the amount of arrows stuck in the entity. getting hit by arrows increases this, used in rendering
     */
    public final int getArrowCountInEntity() {
        return this.dataManager.get(ARROW_COUNT_IN_ENTITY);
    }

    /**
     * sets the amount of arrows stuck in the entity. used for rendering those
     */
    public final void setArrowCountInEntity(int count) {
        this.dataManager.set(ARROW_COUNT_IN_ENTITY, count);
    }

    public final int getBeeStingCount() {
        return this.dataManager.get(BEE_STING_COUNT);
    }

    public final void setBeeStingCount(int p_226300_1_) {
        this.dataManager.set(BEE_STING_COUNT, p_226300_1_);
    }

    /**
     * Returns an integer indicating the end point of the swing animation, used by {@link #swingProgress} to provide a
     * progress indicator. Takes dig speed enchantments into account.
     */
    private int getArmSwingAnimationEnd() {
        SwingAnimationFunction swingAnimationFunction = (Managment.FUNCTION_MANAGER.swingAnimationFunction);
        if (swingAnimationFunction.state && this instanceof ClientPlayerEntity) {
            return swingAnimationFunction.swipeSpeed.getValue().intValue();
        }
        if (EffectUtils.hasMiningSpeedup(this)) {
            return 6 - (1 + EffectUtils.getMiningSpeedup(this));
        } else {
            return this.isPotionActive(Effects.MINING_FATIGUE) ? 6 + (1 + this.getActivePotionEffect(Effects.MINING_FATIGUE).getAmplifier()) * 2 : 6;
        }
    }

    public void swingArm(Hand hand) {
        this.swing(hand, false);
    }

    public void swing(Hand handIn, boolean updateSelf) {
        if (!this.isSwingInProgress || this.swingProgressInt >= this.getArmSwingAnimationEnd() / 2 || this.swingProgressInt < 0) {
            this.swingProgressInt = -1;
            this.isSwingInProgress = true;
            this.swingingHand = handIn;

            if (this.world instanceof ServerWorld) {
                SAnimateHandPacket sanimatehandpacket = new SAnimateHandPacket(this, handIn == Hand.MAIN_HAND ? 0 : 3);
                ServerChunkProvider serverchunkprovider = ((ServerWorld) this.world).getChunkProvider();

                if (updateSelf) {
                    serverchunkprovider.sendToTrackingAndSelf(this, sanimatehandpacket);
                } else {
                    serverchunkprovider.sendToAllTracking(this, sanimatehandpacket);
                }
            }
        }
    }

    /**
     * Handler for {@link World#setEntityState}
     */
    public void handleStatusUpdate(byte id) {
        switch (id) {
            case 2:
            case 33:
            case 36:
            case 37:
            case 44:
                boolean flag1 = id == 33;
                boolean flag2 = id == 36;
                boolean flag3 = id == 37;
                boolean flag = id == 44;
                this.limbSwingAmount = 1.5F;
                this.hurtResistantTime = 20;
                this.maxHurtTime = 10;
                this.hurtTime = this.maxHurtTime;
                this.attackedAtYaw = 0.0F;

                if (flag1) {
                    this.playSound(SoundEvents.ENCHANT_THORNS_HIT, this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
                }

                DamageSource damagesource;

                if (flag3) {
                    damagesource = DamageSource.ON_FIRE;
                } else if (flag2) {
                    damagesource = DamageSource.DROWN;
                } else if (flag) {
                    damagesource = DamageSource.SWEET_BERRY_BUSH;
                } else {
                    damagesource = DamageSource.GENERIC;
                }

                SoundEvent soundevent1 = this.getHurtSound(damagesource);

                if (soundevent1 != null) {
                    this.playSound(soundevent1, this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
                }

                this.attackEntityFrom(DamageSource.GENERIC, 0.0F);
                break;

            case 3:
                SoundEvent soundevent = this.getDeathSound();

                if (soundevent != null) {
                    this.playSound(soundevent, this.getSoundVolume(), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
                }

                if (!(this instanceof PlayerEntity)) {
                    this.setHealth(0.0F);
                    this.onDeath(DamageSource.GENERIC);
                }

                break;

            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 31:
            case 32:
            case 34:
            case 35:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 53:
            default:
                super.handleStatusUpdate(id);
                break;

            case 29:
                this.playSound(SoundEvents.ITEM_SHIELD_BLOCK, 1.0F, 0.8F + this.world.rand.nextFloat() * 0.4F);
                break;

            case 30:
                this.playSound(SoundEvents.ITEM_SHIELD_BREAK, 0.8F, 0.8F + this.world.rand.nextFloat() * 0.4F);
                break;

            case 46:
                int i = 128;

                for (int j = 0; j < 128; ++j) {
                    double d0 = (double) j / 127.0D;
                    float f = (this.rand.nextFloat() - 0.5F) * 0.2F;
                    float f1 = (this.rand.nextFloat() - 0.5F) * 0.2F;
                    float f2 = (this.rand.nextFloat() - 0.5F) * 0.2F;
                    double d1 = MathHelper.lerp(d0, this.prevPosX, this.getPosX()) + (this.rand.nextDouble() - 0.5D) * (double) this.getWidth() * 2.0D;
                    double d2 = MathHelper.lerp(d0, this.prevPosY, this.getPosY()) + this.rand.nextDouble() * (double) this.getHeight();
                    double d3 = MathHelper.lerp(d0, this.prevPosZ, this.getPosZ()) + (this.rand.nextDouble() - 0.5D) * (double) this.getWidth() * 2.0D;
                    this.world.addParticle(ParticleTypes.PORTAL, d1, d2, d3, (double) f, (double) f1, (double) f2);
                }

                break;

            case 47:
                this.renderBrokenItemStack(this.getItemStackFromSlot(EquipmentSlotType.MAINHAND));
                break;

            case 48:
                this.renderBrokenItemStack(this.getItemStackFromSlot(EquipmentSlotType.OFFHAND));
                break;

            case 49:
                this.renderBrokenItemStack(this.getItemStackFromSlot(EquipmentSlotType.HEAD));
                break;

            case 50:
                this.renderBrokenItemStack(this.getItemStackFromSlot(EquipmentSlotType.CHEST));
                break;

            case 51:
                this.renderBrokenItemStack(this.getItemStackFromSlot(EquipmentSlotType.LEGS));
                break;

            case 52:
                this.renderBrokenItemStack(this.getItemStackFromSlot(EquipmentSlotType.FEET));
                break;

            case 54:
                HoneyBlock.livingSlideParticles(this);
                break;

            case 55:
                this.swapHands();
        }
    }

    private void swapHands() {
        ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.OFFHAND);
        this.setItemStackToSlot(EquipmentSlotType.OFFHAND, this.getItemStackFromSlot(EquipmentSlotType.MAINHAND));
        this.setItemStackToSlot(EquipmentSlotType.MAINHAND, itemstack);
    }

    /**
     * sets the dead flag. Used when you fall off the bottom of the world.
     */
    protected void outOfWorld() {
        this.attackEntityFrom(DamageSource.OUT_OF_WORLD, 4.0F);
    }

    /**
     * Updates the arm swing progress counters and animation progress
     */
    protected void updateArmSwingProgress() {
        int i = this.getArmSwingAnimationEnd();

        if (this.isSwingInProgress) {
            ++this.swingProgressInt;

            if (this.swingProgressInt >= i) {
                this.swingProgressInt = 0;
                this.isSwingInProgress = false;
            }
        } else {
            this.swingProgressInt = 0;
        }

        this.swingProgress = (float) this.swingProgressInt / (float) i;
    }

    @Nullable
    public ModifiableAttributeInstance getAttribute(Attribute attribute) {
        return this.getAttributeManager().createInstanceIfAbsent(attribute);
    }

    public double getAttributeValue(Attribute attribute) {
        return this.getAttributeManager().getAttributeValue(attribute);
    }

    public double getBaseAttributeValue(Attribute attribute) {
        return this.getAttributeManager().getAttributeBaseValue(attribute);
    }

    public AttributeModifierManager getAttributeManager() {
        return this.attributes;
    }

    public CreatureAttribute getCreatureAttribute() {
        return CreatureAttribute.UNDEFINED;
    }

    public ItemStack getHeldItemMainhand() {
        return this.getItemStackFromSlot(EquipmentSlotType.MAINHAND);
    }

    public ItemStack getHeldItemOffhand() {
        return this.getItemStackFromSlot(EquipmentSlotType.OFFHAND);
    }

    public boolean canEquip(Item item) {
        return this.func_233634_a_((p_233632_1_) ->
        {
            return p_233632_1_ == item;
        });
    }

    public boolean func_233634_a_(Predicate<Item> p_233634_1_) {
        return p_233634_1_.test(this.getHeldItemMainhand().getItem()) || p_233634_1_.test(this.getHeldItemOffhand().getItem());
    }

    public ItemStack getHeldItem(Hand hand) {
        if (hand == Hand.MAIN_HAND) {
            return this.getItemStackFromSlot(EquipmentSlotType.MAINHAND);
        } else if (hand == Hand.OFF_HAND) {
            return this.getItemStackFromSlot(EquipmentSlotType.OFFHAND);
        } else {
            throw new IllegalArgumentException("Invalid hand " + hand);
        }
    }

    public void setHeldItem(Hand hand, ItemStack stack) {
        if (hand == Hand.MAIN_HAND) {
            this.setItemStackToSlot(EquipmentSlotType.MAINHAND, stack);
        } else {
            if (hand != Hand.OFF_HAND) {
                throw new IllegalArgumentException("Invalid hand " + hand);
            }

            this.setItemStackToSlot(EquipmentSlotType.OFFHAND, stack);
        }
    }

    public boolean hasItemInSlot(EquipmentSlotType slotIn) {
        return !this.getItemStackFromSlot(slotIn).isEmpty();
    }

    public abstract Iterable<ItemStack> getArmorInventoryList();

    public abstract ItemStack getItemStackFromSlot(EquipmentSlotType slotIn);

    public abstract void setItemStackToSlot(EquipmentSlotType slotIn, ItemStack stack);

    public float getArmorCoverPercentage() {
        Iterable<ItemStack> iterable = this.getArmorInventoryList();
        int i = 0;
        int j = 0;

        for (ItemStack itemstack : iterable) {
            if (!itemstack.isEmpty()) {
                ++j;
            }

            ++i;
        }

        return i > 0 ? (float) j / (float) i : 0.0F;
    }

    /**
     * Set sprinting switch for Entity.
     */
    public void setSprinting(boolean sprinting) {
        super.setSprinting(sprinting);
        ModifiableAttributeInstance modifiableattributeinstance = this.getAttribute(Attributes.MOVEMENT_SPEED);

        if (modifiableattributeinstance.getModifier(SPRINTING_SPEED_BOOST_ID) != null) {
            modifiableattributeinstance.removeModifier(SPRINTING_SPEED_BOOST);
        }

        if (sprinting) {
            modifiableattributeinstance.applyNonPersistentModifier(SPRINTING_SPEED_BOOST);
        }
    }

    /**
     * Returns the volume for the sounds this mob makes.
     */
    protected float getSoundVolume() {
        return 1.0F;
    }

    /**
     * Gets the pitch of living sounds in living entities.
     */
    protected float getSoundPitch() {
        return this.isChild() ? (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.5F : (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F;
    }

    /**
     * Dead and sleeping entities cannot move
     */
    protected boolean isMovementBlocked() {
        return this.getShouldBeDead();
    }

    /**
     * Applies a velocity to the entities, to push them away from eachother.
     */
    public void applyEntityCollision(Entity entityIn) {
        if (!this.isSleeping()) {
            super.applyEntityCollision(entityIn);
        }
    }

    private void func_233628_a_(Entity p_233628_1_) {
        Vector3d vector3d;

        if (!p_233628_1_.removed && !this.world.getBlockState(p_233628_1_.getPosition()).getBlock().isIn(BlockTags.PORTALS)) {
            vector3d = p_233628_1_.func_230268_c_(this);
        } else {
            vector3d = new Vector3d(p_233628_1_.getPosX(), p_233628_1_.getPosY() + (double) p_233628_1_.getHeight(), p_233628_1_.getPosZ());
        }

        this.setPositionAndUpdate(vector3d.x, vector3d.y, vector3d.z);
    }

    public boolean getAlwaysRenderNameTagForRender() {
        return this.isCustomNameVisible();
    }

    protected float getJumpUpwardsMotion() {
        return 0.42F * this.getJumpFactor();
    }

    private RotationMoveEvent jumpRotationEvent;

    /**
     * Causes this entity to do an upwards motion (jumping).
     */
    protected void jump() {

        // noinspection ConstantConditions
        if (ClientPlayerEntity.class.isInstance(this)) {
            IBaritone baritone = BaritoneAPI.getProvider().getBaritoneForPlayer((ClientPlayerEntity) (Object) this);
            if (baritone != null) {
                this.jumpRotationEvent = new RotationMoveEvent(RotationMoveEvent.Type.JUMP, this.rotationYaw);
                baritone.getGameEventHandler().onPlayerRotationMove(this.jumpRotationEvent);
            }
        }

        if (this instanceof ClientPlayerEntity) {
            EventManager.call(new EventJump());
        }

        float f = this.getJumpUpwardsMotion();

        if (this.isPotionActive(Effects.JUMP_BOOST)) {
            f += 0.1F * (float) (this.getActivePotionEffect(Effects.JUMP_BOOST).getAmplifier() + 1);
        }

        Vector3d vector3d = this.getMotion();
        this.setMotion(vector3d.x, (double) f, vector3d.z);
        if (Managment.FUNCTION_MANAGER.auraFunction.state && Managment.FUNCTION_MANAGER.auraFunction.settings.get(1)) {
            if (this.isSprinting()) {
                float f1 = Managment.FUNCTION_MANAGER.auraFunction.rotate.x * ((float) Math.PI / 180F);
                this.setMotion(this.getMotion().add((double) (-MathHelper.sin(f1) * 0.2F), 0.0D, (double) (MathHelper.cos(f1) * 0.2F)));
            }

            this.isAirBorne = true;
            return;
        }
/*        if (Managment.FUNCTION_MANAGER.auraFunction.state && Managment.FUNCTION_MANAGER.auraFunction.correction.get()) {
            if (this.isSprinting()) {
                float f1 = Managment.FUNCTION_MANAGER.auraFunction.rotate.x * ((float) Math.PI / 180F);
                this.setMotion(this.getMotion().add((double) (-MathHelper.sin(f1) * 0.2F), 0.0D, (double) (MathHelper.cos(f1) * 0.2F)));
            }

            this.isAirBorne = true;
            return;
        }*/
        if (Managment.FUNCTION_MANAGER.autoExplosionFunction.check()) {
            if (this.isSprinting()) {
                float f1 = Managment.FUNCTION_MANAGER.autoExplosionFunction.server.x * ((float) Math.PI / 180F);
                this.setMotion(this.getMotion().add((double) (-MathHelper.sin(f1) * 0.2F), 0.0D, (double) (MathHelper.cos(f1) * 0.2F)));
            }

            this.isAirBorne = true;
            return;
        }
//        if (Managment.FUNCTION_MANAGER.scaffold.state && Managment.FUNCTION_MANAGER.scaffold.rotation != null) {
//            if (this.isSprinting()) {
//                float f1 =  Managment.FUNCTION_MANAGER.scaffold.rotation.x * ((float) Math.PI / 180F);
//                this.setMotion(this.getMotion().add((double) (-MathHelper.sin(f1) * 0.2F), 0.0D, (double) (MathHelper.cos(f1) * 0.2F)));
//            }
//
//            this.isAirBorne = true;
//            return;
//        }

        EventStrafe eventStrafe = new EventStrafe(this.rotationYaw);
        EventManager.call(eventStrafe);

        if (this.isSprinting()) {
            float f1 = this.rotationYaw * ((float) Math.PI / 180F);
            if (this instanceof ClientPlayerEntity) {
                f1 = eventStrafe.yaw * ((float) Math.PI / 180F);
            }

            if (this instanceof ClientPlayerEntity && BaritoneAPI.getProvider().getBaritoneForPlayer((ClientPlayerEntity) (Object) this) != null) {
                f1 = this.jumpRotationEvent.getYaw() * ((float) Math.PI / 180F);
            }
            this.setMotion(this.getMotion().add((double) (-MathHelper.sin(f1) * 0.2F), 0.0D, (double) (MathHelper.cos(f1) * 0.2F)));
        }

        this.isAirBorne = true;
    }

    protected void handleFluidSneak() {
        this.setMotion(this.getMotion().add(0.0D, (double) -0.04F, 0.0D));
    }

    protected void handleFluidJump(ITag<Fluid> fluidTag) {
        this.setMotion(this.getMotion().add(0.0D, (double) 0.04F, 0.0D));
    }

    protected float getWaterSlowDown() {
        return 0.8F;
    }

    public boolean func_230285_a_(Fluid p_230285_1_) {
        return false;
    }

    public void travel(Vector3d travelVector) {
        if (this.isServerWorld() || this.canPassengerSteer()) {
            double d0 = 0.08D;
            boolean flag = this.getMotion().y <= 0.0D;

            if (flag && this.isPotionActive(Effects.SLOW_FALLING)) {
                d0 = 0.01D;
                this.fallDistance = 0.0F;
            }

            FluidState fluidstate = this.world.getFluidState(this.getPosition());

            if (this.isInWater() && this.func_241208_cS_() && !this.func_230285_a_(fluidstate.getFluid())) {
                double d8 = this.getPosY();
                float f5 = this.isSprinting() ? 0.9F : this.getWaterSlowDown();
                float f6 = 0.02F;
                float f7 = (float) EnchantmentHelper.getDepthStriderModifier(this);

                if (f7 > 3.0F) {
                    f7 = 3.0F;
                }

                if (!this.onGround) {
                    f7 *= 0.5F;
                }

                if (f7 > 0.0F) {
                    f5 += (0.54600006F - f5) * f7 / 3.0F;
                    f6 += (this.getAIMoveSpeed() - f6) * f7 / 3.0F;
                }

                if (this.isPotionActive(Effects.DOLPHINS_GRACE)) {
                    f5 = 0.96F;
                }
                EventTravel travel = new EventTravel(f6);
                if (this instanceof ClientPlayerEntity)
                    EventManager.call(travel);
                this.moveRelative(travel.speed, travelVector);
                this.move(MoverType.SELF, this.getMotion());
                Vector3d vector3d6 = this.getMotion();

                if (this.collidedHorizontally && this.isOnLadder()) {
                    vector3d6 = new Vector3d(vector3d6.x, 0.2D, vector3d6.z);
                }

                this.setMotion(vector3d6.mul((double) f5, (double) 0.8F, (double) f5));
                Vector3d vector3d2 = this.func_233626_a_(d0, flag, this.getMotion());
                this.setMotion(vector3d2);

                if (this.collidedHorizontally && this.isOffsetPositionInLiquid(vector3d2.x, vector3d2.y + (double) 0.6F - this.getPosY() + d8, vector3d2.z)) {
                    this.setMotion(vector3d2.x, (double) 0.3F, vector3d2.z);
                }
            } else if (this.isInLava() && this.func_241208_cS_() && !this.func_230285_a_(fluidstate.getFluid())) {
                double d7 = this.getPosY();
                this.moveRelative(0.02F, travelVector);
                this.move(MoverType.SELF, this.getMotion());

                if (this.func_233571_b_(FluidTags.LAVA) <= this.func_233579_cu_()) {
                    this.setMotion(this.getMotion().mul(0.5D, (double) 0.8F, 0.5D));
                    Vector3d vector3d3 = this.func_233626_a_(d0, flag, this.getMotion());
                    this.setMotion(vector3d3);
                } else {
                    this.setMotion(this.getMotion().scale(0.5D));
                }

                if (!this.hasNoGravity()) {
                    this.setMotion(this.getMotion().add(0.0D, -d0 / 4.0D, 0.0D));
                }

                Vector3d vector3d4 = this.getMotion();

                if (this.collidedHorizontally && this.isOffsetPositionInLiquid(vector3d4.x, vector3d4.y + (double) 0.6F - this.getPosY() + d7, vector3d4.z)) {
                    this.setMotion(vector3d4.x, (double) 0.3F, vector3d4.z);
                }
            } else if (this.isElytraFlying()) {
                Vector3d vector3d = this.getMotion();

                if (vector3d.y > -0.5D) {
                    this.fallDistance = 1.0F;
                }

                Vector3d vector3d1 = this.getLookVec();

                if (Managment.FUNCTION_MANAGER.auraFunction.state && Managment.FUNCTION_MANAGER.auraFunction.settings.get(1) && this instanceof ClientPlayerEntity) {
                    vector3d1 = this.getVectorForRotation(Managment.FUNCTION_MANAGER.auraFunction.rotate.y, Managment.FUNCTION_MANAGER.auraFunction.rotate.x);
                }
                float f = this.rotationPitch * ((float) Math.PI / 180F);
                if (Managment.FUNCTION_MANAGER.auraFunction.state && Managment.FUNCTION_MANAGER.auraFunction.settings.get(1) && this instanceof ClientPlayerEntity) {
                    f = Managment.FUNCTION_MANAGER.auraFunction.rotate.y * ((float) Math.PI / 180F);
                }
                double d1 = Math.sqrt(vector3d1.x * vector3d1.x + vector3d1.z * vector3d1.z);
                double d3 = Math.sqrt(horizontalMag(vector3d));
                double d4 = vector3d1.length();
                float f1 = MathHelper.cos(f);
                f1 = (float) ((double) f1 * (double) f1 * Math.min(1.0D, d4 / 0.4D));
                vector3d = this.getMotion().add(0.0D, d0 * (-1.0D + (double) f1 * 0.75D), 0.0D);

                if (vector3d.y < 0.0D && d1 > 0.0D) {
                    double d5 = vector3d.y * -0.1D * (double) f1;
                    vector3d = vector3d.add(vector3d1.x * d5 / d1, d5, vector3d1.z * d5 / d1);
                }

                if (f < 0.0F && d1 > 0.0D) {
                    double d9 = d3 * (double) (-MathHelper.sin(f)) * 0.04D;
                    vector3d = vector3d.add(-vector3d1.x * d9 / d1, d9 * 3.2D, -vector3d1.z * d9 / d1);
                }

                if (d1 > 0.0D) {
                    vector3d = vector3d.add((vector3d1.x / d1 * d3 - vector3d.x) * 0.1D, 0.0D, (vector3d1.z / d1 * d3 - vector3d.z) * 0.1D);
                }

                this.setMotion(vector3d.mul((double) 0.99F, (double) 0.98F, (double) 0.99F));
                this.move(MoverType.SELF, this.getMotion());

                if (this.collidedHorizontally && !this.world.isRemote) {
                    double d10 = Math.sqrt(horizontalMag(this.getMotion()));
                    double d6 = d3 - d10;
                    float f2 = (float) (d6 * 10.0D - 3.0D);

                    if (f2 > 0.0F) {
                        this.playSound(this.getFallSound((int) f2), 1.0F, 1.0F);
                        this.attackEntityFrom(DamageSource.FLY_INTO_WALL, f2);
                    }
                }

                if (this.onGround && !this.world.isRemote) {
                    this.setFlag(7, false);
                }
            } else {
                BlockPos blockpos = this.getPositionUnderneath();
                float f3 = this.world.getBlockState(blockpos).getBlock().getSlipperiness();
                float f4 = this.onGround ? f3 * 0.91F : 0.91F;
                Vector3d vector3d5 = this.func_233633_a_(travelVector, f3);
                double d2 = vector3d5.y;

                if (this.isPotionActive(Effects.LEVITATION)) {
                    d2 += (0.05D * (double) (this.getActivePotionEffect(Effects.LEVITATION).getAmplifier() + 1) - vector3d5.y) * 0.2D;
                    this.fallDistance = 0.0F;
                } else if (this.world.isRemote && !this.world.isBlockLoaded(blockpos)) {
                    if (this.getPosY() > 0.0D) {
                        d2 = -0.1D;
                    } else {
                        d2 = 0.0D;
                    }
                } else if (!this.hasNoGravity()) {
                    d2 -= d0;
                }

                this.setMotion(vector3d5.x * (double) f4, d2 * (double) 0.98F, vector3d5.z * (double) f4);
            }
        }

        this.func_233629_a_(this, this instanceof IFlyingAnimal);
    }

    public void func_233629_a_(LivingEntity p_233629_1_, boolean p_233629_2_) {
        p_233629_1_.prevLimbSwingAmount = p_233629_1_.limbSwingAmount;
        double d0 = p_233629_1_.getPosX() - p_233629_1_.prevPosX;
        double d1 = p_233629_2_ ? p_233629_1_.getPosY() - p_233629_1_.prevPosY : 0.0D;
        double d2 = p_233629_1_.getPosZ() - p_233629_1_.prevPosZ;
        float f = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 4.0F;

        if (f > 1.0F) {
            f = 1.0F;
        }

        p_233629_1_.limbSwingAmount += (f - p_233629_1_.limbSwingAmount) * 0.4F;
        p_233629_1_.limbSwing += p_233629_1_.limbSwingAmount;
    }

    public Vector3d func_233633_a_(Vector3d p_233633_1_, float p_233633_2_) {
        this.moveRelative(this.getRelevantMoveFactor(p_233633_2_), p_233633_1_);
        this.setMotion(this.handleOnClimbable(this.getMotion()));
        this.move(MoverType.SELF, this.getMotion());
        Vector3d vector3d = this.getMotion();

        if ((this.collidedHorizontally || this.isJumping) && this.isOnLadder()) {
            vector3d = new Vector3d(vector3d.x, 0.2D, vector3d.z);
        }

        return vector3d;
    }

    public Vector3d func_233626_a_(double p_233626_1_, boolean p_233626_3_, Vector3d p_233626_4_) {
        if (!this.hasNoGravity() && !this.isSprinting()) {
            double d0;

            if (p_233626_3_ && Math.abs(p_233626_4_.y - 0.005D) >= 0.003D && Math.abs(p_233626_4_.y - p_233626_1_ / 16.0D) < 0.003D) {
                d0 = -0.003D;
            } else {
                d0 = p_233626_4_.y - p_233626_1_ / 16.0D;
            }

            return new Vector3d(p_233626_4_.x, d0, p_233626_4_.z);
        } else {
            return p_233626_4_;
        }
    }

    private Vector3d handleOnClimbable(Vector3d p_213362_1_) {
        if (this.isOnLadder()) {
            this.fallDistance = 0.0F;
            float f = 0.15F;
            double d0 = MathHelper.clamp(p_213362_1_.x, (double) -0.15F, (double) 0.15F);
            double d1 = MathHelper.clamp(p_213362_1_.z, (double) -0.15F, (double) 0.15F);
            double d2 = Math.max(p_213362_1_.y, (double) -0.15F);

            if (d2 < 0.0D && !this.getBlockState().isIn(Blocks.SCAFFOLDING) && this.hasStoppedClimbing() && this instanceof PlayerEntity) {
                d2 = 0.0D;
            }

            p_213362_1_ = new Vector3d(d0, d2, d1);
        }

        return p_213362_1_;
    }

    private float getRelevantMoveFactor(float p_213335_1_) {
        return this.onGround ? this.getAIMoveSpeed() * (0.21600002F / (p_213335_1_ * p_213335_1_ * p_213335_1_)) : this.jumpMovementFactor;
    }

    /**
     * the movespeed used for the new AI system
     */
    public float getAIMoveSpeed() {
        return this.landMovementFactor;
    }

    /**
     * set the movespeed used for the new AI system
     */
    public void setAIMoveSpeed(float speedIn) {
        this.landMovementFactor = speedIn;
    }

    public boolean attackEntityAsMob(Entity entityIn) {
        this.setLastAttackedEntity(entityIn);
        return false;
    }

    /**
     * Called to update the entity's position/logic.
     */
    public void tick() {
        super.tick();
        this.updateActiveHand();
        this.updateSwimAnimation();

        if (!this.world.isRemote) {
            int i = this.getArrowCountInEntity();

            if (i > 0) {
                if (this.arrowHitTimer <= 0) {
                    this.arrowHitTimer = 20 * (30 - i);
                }

                --this.arrowHitTimer;

                if (this.arrowHitTimer <= 0) {
                    this.setArrowCountInEntity(i - 1);
                }
            }

            int j = this.getBeeStingCount();

            if (j > 0) {
                if (this.beeStingRemovalCooldown <= 0) {
                    this.beeStingRemovalCooldown = 20 * (30 - j);
                }

                --this.beeStingRemovalCooldown;

                if (this.beeStingRemovalCooldown <= 0) {
                    this.setBeeStingCount(j - 1);
                }
            }

            this.func_241353_q_();

            if (this.ticksExisted % 20 == 0) {
                this.getCombatTracker().reset();
            }

            if (!this.glowing) {
                boolean flag = this.isPotionActive(Effects.GLOWING);

                if (this.getFlag(6) != flag) {
                    this.setFlag(6, flag);
                }
            }

            if (this.isSleeping() && !this.isInValidBed()) {
                this.wakeUp();
            }
        }

        this.livingTick();
        double d0 = this.getPosX() - this.prevPosX;
        double d1 = this.getPosZ() - this.prevPosZ;
        float f = (float) (d0 * d0 + d1 * d1);
        float f1 = this.renderYawOffset;
        float f2 = 0.0F;
        this.prevOnGroundSpeedFactor = this.onGroundSpeedFactor;
        float f3 = 0.0F;

        if (f > 0.0025000002F) {
            f3 = 1.0F;
            f2 = (float) Math.sqrt((double) f) * 3.0F;
            float f4 = (float) MathHelper.atan2(d1, d0) * (180F / (float) Math.PI) - 90.0F;
            float f5 = MathHelper.abs(MathHelper.wrapDegrees(this.rotationYaw) - f4);

            if (95.0F < f5 && f5 < 265.0F) {
                f1 = f4 - 180.0F;
            } else {
                f1 = f4;
            }
        }

        if (this.swingProgress > 0.0F) {
            f1 = this.rotationYaw;
        }

        if (!this.onGround) {
            f3 = 0.0F;
        }

        this.onGroundSpeedFactor += (f3 - this.onGroundSpeedFactor) * 0.3F;
        this.world.getProfiler().startSection("headTurn");
        f2 = this.updateDistance(f1, f2);
        this.world.getProfiler().endSection();
        this.world.getProfiler().startSection("rangeChecks");

        while (this.rotationYaw - this.prevRotationYaw < -180.0F) {
            this.prevRotationYaw -= 360.0F;
        }

        while (this.rotationYaw - this.prevRotationYaw >= 180.0F) {
            this.prevRotationYaw += 360.0F;
        }

        while (this.renderYawOffset - this.prevRenderYawOffset < -180.0F) {
            this.prevRenderYawOffset -= 360.0F;
        }

        while (this.renderYawOffset - this.prevRenderYawOffset >= 180.0F) {
            this.prevRenderYawOffset += 360.0F;
        }

        while (this.rotationPitch - this.prevRotationPitch < -180.0F) {
            this.prevRotationPitch -= 360.0F;
        }

        while (this.rotationPitch - this.prevRotationPitch >= 180.0F) {
            this.prevRotationPitch += 360.0F;
        }

        while (this.rotationYawHead - this.prevRotationYawHead < -180.0F) {
            this.prevRotationYawHead -= 360.0F;
        }

        while (this.rotationYawHead - this.prevRotationYawHead >= 180.0F) {
            this.prevRotationYawHead += 360.0F;
        }

        this.world.getProfiler().endSection();
        this.movedDistance += f2;

        if (this.isElytraFlying()) {
            ++this.ticksElytraFlying;
        } else {
            this.ticksElytraFlying = 0;
        }

        if (this.isSleeping()) {
            this.rotationPitch = 0.0F;
        }
    }

    private void func_241353_q_() {
        Map<EquipmentSlotType, ItemStack> map = this.func_241354_r_();

        if (map != null) {
            this.func_241342_a_(map);

            if (!map.isEmpty()) {
                this.func_241344_b_(map);
            }
        }
    }

    @Nullable
    private Map<EquipmentSlotType, ItemStack> func_241354_r_() {
        Map<EquipmentSlotType, ItemStack> map = null;

        for (EquipmentSlotType equipmentslottype : EquipmentSlotType.values()) {
            ItemStack itemstack;

            switch (equipmentslottype.getSlotType()) {
                case HAND:
                    itemstack = this.getItemInHand(equipmentslottype);
                    break;

                case ARMOR:
                    itemstack = this.getArmorInSlot(equipmentslottype);
                    break;

                default:
                    continue;
            }

            ItemStack itemstack1 = this.getItemStackFromSlot(equipmentslottype);

            if (!ItemStack.areItemStacksEqual(itemstack1, itemstack)) {
                if (map == null) {
                    map = Maps.newEnumMap(EquipmentSlotType.class);
                }

                map.put(equipmentslottype, itemstack1);

                if (!itemstack.isEmpty()) {
                    this.getAttributeManager().removeModifiers(itemstack.getAttributeModifiers(equipmentslottype));
                }

                if (!itemstack1.isEmpty()) {
                    this.getAttributeManager().reapplyModifiers(itemstack1.getAttributeModifiers(equipmentslottype));
                }
            }
        }

        return map;
    }

    private void func_241342_a_(Map<EquipmentSlotType, ItemStack> p_241342_1_) {
        ItemStack itemstack = p_241342_1_.get(EquipmentSlotType.MAINHAND);
        ItemStack itemstack1 = p_241342_1_.get(EquipmentSlotType.OFFHAND);

        if (itemstack != null && itemstack1 != null && ItemStack.areItemStacksEqual(itemstack, this.getItemInHand(EquipmentSlotType.OFFHAND)) && ItemStack.areItemStacksEqual(itemstack1, this.getItemInHand(EquipmentSlotType.MAINHAND))) {
            ((ServerWorld) this.world).getChunkProvider().sendToAllTracking(this, new SEntityStatusPacket(this, (byte) 55));
            p_241342_1_.remove(EquipmentSlotType.MAINHAND);
            p_241342_1_.remove(EquipmentSlotType.OFFHAND);
            this.setItemInHand(EquipmentSlotType.MAINHAND, itemstack.copy());
            this.setItemInHand(EquipmentSlotType.OFFHAND, itemstack1.copy());
        }
    }

    private void func_241344_b_(Map<EquipmentSlotType, ItemStack> p_241344_1_) {
        List<Pair<EquipmentSlotType, ItemStack>> list = Lists.newArrayListWithCapacity(p_241344_1_.size());
        p_241344_1_.forEach((p_241341_2_, p_241341_3_) ->
        {
            ItemStack itemstack = p_241341_3_.copy();
            list.add(Pair.of(p_241341_2_, itemstack));

            switch (p_241341_2_.getSlotType()) {
                case HAND:
                    this.setItemInHand(p_241341_2_, itemstack);
                    break;

                case ARMOR:
                    this.setArmorInSlot(p_241341_2_, itemstack);
            }
        });
        ((ServerWorld) this.world).getChunkProvider().sendToAllTracking(this, new SEntityEquipmentPacket(this.getEntityId(), list));
    }

    private ItemStack getArmorInSlot(EquipmentSlotType slot) {
        return this.armorArray.get(slot.getIndex());
    }

    private void setArmorInSlot(EquipmentSlotType slot, ItemStack stack) {
        this.armorArray.set(slot.getIndex(), stack);
    }

    private ItemStack getItemInHand(EquipmentSlotType slot) {
        return this.handInventory.get(slot.getIndex());
    }

    private void setItemInHand(EquipmentSlotType slot, ItemStack stack) {
        this.handInventory.set(slot.getIndex(), stack);
    }

    protected float updateDistance(float p_110146_1_, float p_110146_2_) {
        float f = MathHelper.wrapDegrees(p_110146_1_ - this.renderYawOffset);
        this.renderYawOffset += f * 0.3F;
        float f1 = MathHelper.wrapDegrees(this.rotationYaw - this.renderYawOffset);
        boolean flag = f1 < -90.0F || f1 >= 90.0F;

        if (f1 < -75.0F) {
            f1 = -75.0F;
        }

        if (f1 >= 75.0F) {
            f1 = 75.0F;
        }

        this.renderYawOffset = this.rotationYaw - f1;

        if (f1 * f1 > 2500.0F) {
            this.renderYawOffset += f1 * 0.2F;
        }

        if (flag) {
            p_110146_2_ *= -1.0F;
        }

        return p_110146_2_;
    }

    /**
     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
     * use this to react to sunlight and start to burn.
     */
    public void livingTick() {
        if (this.jumpTicks > 0) {
            --this.jumpTicks;
        }

        if (this.canPassengerSteer()) {
            this.newPosRotationIncrements = 0;
            this.setPacketCoordinates(this.getPosX(), this.getPosY(), this.getPosZ());
        }

        if (this.newPosRotationIncrements > 0) {
            double d0 = this.getPosX() + (this.interpTargetX - this.getPosX()) / (double) this.newPosRotationIncrements;
            double d2 = this.getPosY() + (this.interpTargetY - this.getPosY()) / (double) this.newPosRotationIncrements;
            double d4 = this.getPosZ() + (this.interpTargetZ - this.getPosZ()) / (double) this.newPosRotationIncrements;
            double d6 = MathHelper.wrapDegrees(this.interpTargetYaw - (double) this.rotationYaw);
            this.rotationYaw = (float) ((double) this.rotationYaw + d6 / (double) this.newPosRotationIncrements);
            this.rotationPitch = (float) ((double) this.rotationPitch + (this.interpTargetPitch - (double) this.rotationPitch) / (double) this.newPosRotationIncrements);
            --this.newPosRotationIncrements;
            this.setPosition(d0, d2, d4);
            this.setRotation(this.rotationYaw, this.rotationPitch);
        } else if (!this.isServerWorld()) {
            this.setMotion(this.getMotion().scale(0.98D));
        }

        if (this.interpTicksHead > 0) {
            this.rotationYawHead = (float) ((double) this.rotationYawHead + MathHelper.wrapDegrees(this.interpTargetHeadYaw - (double) this.rotationYawHead) / (double) this.interpTicksHead);
            --this.interpTicksHead;
        }

        Vector3d vector3d = this.getMotion();
        double d1 = vector3d.x;
        double d3 = vector3d.y;
        double d5 = vector3d.z;

        if (Math.abs(vector3d.x) < 0.003D) {
            d1 = 0.0D;
        }

        if (Math.abs(vector3d.y) < 0.003D) {
            d3 = 0.0D;
        }

        if (Math.abs(vector3d.z) < 0.003D) {
            d5 = 0.0D;
        }

        this.setMotion(d1, d3, d5);
        this.world.getProfiler().startSection("ai");

        if (this.isMovementBlocked()) {
            this.isJumping = false;
            this.moveStrafing = 0.0F;
            this.moveForward = 0.0F;
        } else if (this.isServerWorld()) {
            this.world.getProfiler().startSection("newAi");
            this.updateEntityActionState();
            this.world.getProfiler().endSection();
        }

        this.world.getProfiler().endSection();
        this.world.getProfiler().startSection("jump");

        if (this.isJumping && this.func_241208_cS_()) {
            double d7;

            if (this.isInLava()) {
                d7 = this.func_233571_b_(FluidTags.LAVA);
            } else {
                d7 = this.func_233571_b_(FluidTags.WATER);
            }

            boolean flag = this.isInWater() && d7 > 0.0D;
            double d8 = this.func_233579_cu_();

            if (!flag || this.onGround && !(d7 > d8)) {
                if (!this.isInLava() || this.onGround && !(d7 > d8)) {
                    if ((this.onGround || flag && d7 <= d8) && this.jumpTicks == 0) {
                        this.jump();
                        this.jumpTicks = 10;
                    }
                } else {
                    this.handleFluidJump(FluidTags.LAVA);
                }
            } else {
                this.handleFluidJump(FluidTags.WATER);
            }
        } else {
            this.jumpTicks = 0;
        }

        this.world.getProfiler().endSection();
        this.world.getProfiler().startSection("travel");
        this.moveStrafing *= 0.98F;
        this.moveForward *= 0.98F;
        this.updateElytra();
        AxisAlignedBB axisalignedbb = this.getBoundingBox();
        this.travel(new Vector3d((double) this.moveStrafing, (double) this.moveVertical, (double) this.moveForward));
        this.world.getProfiler().endSection();
        this.world.getProfiler().startSection("push");

        if (this.spinAttackDuration > 0) {
            --this.spinAttackDuration;
            this.updateSpinAttack(axisalignedbb, this.getBoundingBox());
        }

        this.collideWithNearbyEntities();
        this.world.getProfiler().endSection();

        if (!this.world.isRemote && this.isWaterSensitive() && this.isInWaterRainOrBubbleColumn()) {
            this.attackEntityFrom(DamageSource.DROWN, 1.0F);
        }
    }

    public boolean isWaterSensitive() {
        return false;
    }

    /**
     * Called each tick. Updates state for the elytra.
     */
    private void updateElytra() {
        boolean flag = this.getFlag(7);

        if (flag && !this.onGround && !this.isPassenger() && !this.isPotionActive(Effects.LEVITATION)) {
            ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.CHEST);

            if (itemstack.getItem() == Items.ELYTRA && ElytraItem.isUsable(itemstack)) {
                flag = true;

                if (!this.world.isRemote && (this.ticksElytraFlying + 1) % 20 == 0) {
                    itemstack.damageItem(1, this, (p_233652_0_) ->
                    {
                        p_233652_0_.sendBreakAnimation(EquipmentSlotType.CHEST);
                    });
                }
            } else {
                flag = false;
            }
        } else {
            flag = false;
        }

        if (!this.world.isRemote) {
            this.setFlag(7, flag);
        }
    }

    protected void updateEntityActionState() {
    }

    protected void collideWithNearbyEntities() {
        List<Entity> list = this.world.getEntitiesInAABBexcluding(this, this.getBoundingBox(), EntityPredicates.pushableBy(this));

        if (!list.isEmpty()) {
            int i = this.world.getGameRules().getInt(GameRules.MAX_ENTITY_CRAMMING);

            if (i > 0 && list.size() > i - 1 && this.rand.nextInt(4) == 0) {
                int j = 0;

                for (int k = 0; k < list.size(); ++k) {
                    if (!list.get(k).isPassenger()) {
                        ++j;
                    }
                }

                if (j > i - 1) {
                    this.attackEntityFrom(DamageSource.CRAMMING, 6.0F);
                }
            }

            for (int l = 0; l < list.size(); ++l) {
                Entity entity = list.get(l);
                this.collideWithEntity(entity);
            }
        }
    }

    protected void updateSpinAttack(AxisAlignedBB p_204801_1_, AxisAlignedBB p_204801_2_) {
        AxisAlignedBB axisalignedbb = p_204801_1_.union(p_204801_2_);
        List<Entity> list = this.world.getEntitiesWithinAABBExcludingEntity(this, axisalignedbb);

        if (!list.isEmpty()) {
            for (int i = 0; i < list.size(); ++i) {
                Entity entity = list.get(i);

                if (entity instanceof LivingEntity) {
                    this.spinAttack((LivingEntity) entity);
                    this.spinAttackDuration = 0;
                    this.setMotion(this.getMotion().scale(-0.2D));
                    break;
                }
            }
        } else if (this.collidedHorizontally) {
            this.spinAttackDuration = 0;
        }

        if (!this.world.isRemote && this.spinAttackDuration <= 0) {
            this.setLivingFlag(4, false);
        }
    }

    protected void collideWithEntity(Entity entityIn) {
        entityIn.applyEntityCollision(this);
    }

    protected void spinAttack(LivingEntity p_204804_1_) {
    }

    public void startSpinAttack(int p_204803_1_) {
        this.spinAttackDuration = p_204803_1_;

        if (!this.world.isRemote) {
            this.setLivingFlag(4, true);
        }
    }

    public boolean isSpinAttacking() {
        return (this.dataManager.get(LIVING_FLAGS) & 4) != 0;
    }

    /**
     * Dismounts this entity from the entity it is riding.
     */
    public void stopRiding() {
        Entity entity = this.getRidingEntity();
        super.stopRiding();

        if (entity != null && entity != this.getRidingEntity() && !this.world.isRemote) {
            this.func_233628_a_(entity);
        }
    }

    /**
     * Handles updating while riding another entity
     */
    public void updateRidden() {
        super.updateRidden();
        this.prevOnGroundSpeedFactor = this.onGroundSpeedFactor;
        this.onGroundSpeedFactor = 0.0F;
        this.fallDistance = 0.0F;
    }

    /**
     * Sets a target for the client to interpolate towards over the next few ticks
     */
    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport) {
        this.prevServerX = this.interpTargetX;
        this.prevServerY = this.interpTargetY;
        this.prevServerZ = this.interpTargetZ;
        this.interpTargetX = x;
        this.interpTargetY = y;
        this.interpTargetZ = z;
        this.interpTargetYaw = (double) yaw;
        this.interpTargetPitch = (double) pitch;
        this.newPosRotationIncrements = posRotationIncrements;
    }

    public void setHeadRotation(float yaw, int pitch) {
        this.interpTargetHeadYaw = (double) yaw;
        this.interpTicksHead = pitch;
    }

    public void setJumping(boolean jumping) {
        this.isJumping = jumping;
    }

    public void triggerItemPickupTrigger(ItemEntity item) {
        PlayerEntity playerentity = item.getThrowerId() != null ? this.world.getPlayerByUuid(item.getThrowerId()) : null;

        if (playerentity instanceof ServerPlayerEntity) {
            CriteriaTriggers.THROWN_ITEM_PICKED_UP_BY_ENTITY.test((ServerPlayerEntity) playerentity, item.getItem(), this);
        }
    }

    /**
     * Called when the entity picks up an item.
     */
    public void onItemPickup(Entity entityIn, int quantity) {
        if (!entityIn.removed && !this.world.isRemote && (entityIn instanceof ItemEntity || entityIn instanceof AbstractArrowEntity || entityIn instanceof ExperienceOrbEntity)) {
            ((ServerWorld) this.world).getChunkProvider().sendToAllTracking(entityIn, new SCollectItemPacket(entityIn.getEntityId(), this.getEntityId(), quantity));
        }
    }

    /**
     * returns true if the entity provided in the argument can be seen. (Raytrace)
     */
    public boolean canEntityBeSeen(Entity entityIn) {
        Vector3d vector3d = new Vector3d(this.getPosX(), this.getPosYEye(), this.getPosZ());
        Vector3d vector3d1 = new Vector3d(entityIn.getPosX(), entityIn.getPosYEye(), entityIn.getPosZ());
        return this.world.rayTraceBlocks(new RayTraceContext(vector3d, vector3d1, RayTraceContext.BlockMode.COLLIDER, RayTraceContext.FluidMode.NONE, this)).getType() == RayTraceResult.Type.MISS;
    }


    public boolean canEntityBeSeenFixed(Entity entityIn) {
        Vector3d vector3d = Minecraft.getInstance().getRenderManager().info.getProjectedView();
        Vector3d vector3d1 = new Vector3d(entityIn.getPosX(), entityIn.getPosYEye(), entityIn.getPosZ());

        BlockRayTraceResult result = this.world.rayTraceBlocks(new RayTraceContext(vector3d, vector3d1, RayTraceContext.BlockMode.COLLIDER, RayTraceContext.FluidMode.NONE, this));

        if (world.getBlockState(result.getPos()).getBlock() instanceof GlassBlock) {
            return true;
        }

        return result.getType() == RayTraceResult.Type.MISS;
    }

    public boolean canVectorBeSeenFixed(Vector3d entityIn) {
        Vector3d vector3d = Minecraft.getInstance().getRenderManager().info.getProjectedView();
        Vector3d vector3d1 = new Vector3d(entityIn.getX(), entityIn.getY(), entityIn.getZ());

        BlockRayTraceResult result = this.world.rayTraceBlocks(new RayTraceContext(vector3d, vector3d1, RayTraceContext.BlockMode.COLLIDER, RayTraceContext.FluidMode.NONE, this));

        if (world.getBlockState(result.getPos()).getBlock() instanceof GlassBlock) {
            return true;
        }

        return result.getType() == RayTraceResult.Type.MISS;
    }

    /**
     * Gets the current yaw of the entity
     */
    public float getYaw(float partialTicks) {
        return partialTicks == 1.0F ? this.rotationYawHead : MathHelper.lerp(partialTicks, this.prevRotationYawHead, this.rotationYawHead);
    }

    /**
     * Gets the progression of the swing animation, ranges from 0.0 to 1.0.
     */
    public float getSwingProgress(float partialTickTime) {
        float f = this.swingProgress - this.prevSwingProgress;

        if (f < 0.0F) {
            ++f;
        }

        return this.prevSwingProgress + f * partialTickTime;
    }

    /**
     * Returns whether the entity is in a server world
     */
    public boolean isServerWorld() {
        return !this.world.isRemote;
    }

    /**
     * Returns true if other Entities should be prevented from moving through this Entity.
     */
    public boolean canBeCollidedWith() {
        return !this.removed;
    }

    /**
     * Returns true if this entity should push and be pushed by other entities when colliding.
     */
    public boolean canBePushed() {
        if (Managment.FUNCTION_MANAGER.noPushFunction.state && Managment.FUNCTION_MANAGER.noPushFunction.modes.get(0) &&
                this instanceof ClientPlayerEntity)
            return false;

        return this.isAlive() && !this.isSpectator() && !this.isOnLadder();
    }

    /**
     * Marks this entity's velocity as changed, so that it can be re-synced with the client later
     */
    protected void markVelocityChanged() {
        this.velocityChanged = this.rand.nextDouble() >= this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
    }

    public float getRotationYawHead() {
        return this.rotationYawHead;
    }

    /**
     * Sets the head's yaw rotation of the entity.
     */
    public void setRotationYawHead(float rotation) {
        this.rotationYawHead = rotation;
    }

    /**
     * Set the render yaw offset
     */
    public void setRenderYawOffset(float offset) {
        this.renderYawOffset = offset;
    }

    protected Vector3d func_241839_a(Direction.Axis axis, TeleportationRepositioner.Result result) {
        return func_242288_h(super.func_241839_a(axis, result));
    }

    public static Vector3d func_242288_h(Vector3d p_242288_0_) {
        return new Vector3d(p_242288_0_.x, p_242288_0_.y, 0.0D);
    }

    /**
     * Returns the amount of health added by the Absorption effect.
     */
    public float getAbsorptionAmount() {
        return this.absorptionAmount;
    }

    public void setAbsorptionAmount(float amount) {
        if (amount < 0.0F) {
            amount = 0.0F;
        }

        this.absorptionAmount = amount;
    }

    /**
     * Sends an ENTER_COMBAT packet to the client
     */
    public void sendEnterCombat() {
    }

    /**
     * Sends an END_COMBAT packet to the client
     */
    public void sendEndCombat() {
    }

    protected void markPotionsDirty() {
        this.potionsNeedUpdate = true;
    }

    public abstract HandSide getPrimaryHand();

    public boolean isHandActive() {
        return (this.dataManager.get(LIVING_FLAGS) & 1) > 0;
    }

    public Hand getActiveHand() {
        return (this.dataManager.get(LIVING_FLAGS) & 2) > 0 ? Hand.OFF_HAND : Hand.MAIN_HAND;
    }

    private void updateActiveHand() {
        if (this.isHandActive()) {
            if (ItemStack.areItemsEqualIgnoreDurability(this.getHeldItem(this.getActiveHand()), this.activeItemStack)) {
                this.activeItemStack = this.getHeldItem(this.getActiveHand());
                this.activeItemStack.onItemUsed(this.world, this, this.getItemInUseCount());

                if (this.shouldTriggerItemUseEffects()) {
                    this.triggerItemUseEffects(this.activeItemStack, 5);
                }

                if (--this.activeItemStackUseCount == 0 && !this.world.isRemote && !this.activeItemStack.isCrossbowStack()) {
                    this.onItemUseFinish();
                }
            } else {
                this.resetActiveHand();
            }
        }
    }

    private boolean shouldTriggerItemUseEffects() {
        int i = this.getItemInUseCount();
        Food food = this.activeItemStack.getItem().getFood();
        boolean flag = food != null && food.isFastEating();
        flag = flag | i <= this.activeItemStack.getUseDuration() - 7;
        return flag && i % 4 == 0;
    }

    private void updateSwimAnimation() {
        this.lastSwimAnimation = this.swimAnimation;

        if (this.isActualySwimming()) {
            this.swimAnimation = Math.min(1.0F, this.swimAnimation + 0.09F);
        } else {
            this.swimAnimation = Math.max(0.0F, this.swimAnimation - 0.09F);
        }
    }

    protected void setLivingFlag(int key, boolean value) {
        int i = this.dataManager.get(LIVING_FLAGS);

        if (value) {
            i = i | key;
        } else {
            i = i & ~key;
        }

        this.dataManager.set(LIVING_FLAGS, (byte) i);
    }

    public void setActiveHand(Hand hand) {
        ItemStack itemstack = this.getHeldItem(hand);

        if (!itemstack.isEmpty() && !this.isHandActive()) {
            this.activeItemStack = itemstack;
            this.activeItemStackUseCount = itemstack.getUseDuration();

            if (!this.world.isRemote) {
                this.setLivingFlag(1, true);
                this.setLivingFlag(2, hand == Hand.OFF_HAND);
            }
        }
    }

    public void notifyDataManagerChange(DataParameter<?> key) {
        super.notifyDataManagerChange(key);

        if (BED_POSITION.equals(key)) {
            if (this.world.isRemote) {
                this.getBedPosition().ifPresent(this::setSleepingPosition);
            }
        } else if (LIVING_FLAGS.equals(key) && this.world.isRemote) {
            if (this.isHandActive() && this.activeItemStack.isEmpty()) {
                this.activeItemStack = this.getHeldItem(this.getActiveHand());

                if (!this.activeItemStack.isEmpty()) {
                    this.activeItemStackUseCount = this.activeItemStack.getUseDuration();
                }
            } else if (!this.isHandActive() && !this.activeItemStack.isEmpty()) {
                this.activeItemStack = ItemStack.EMPTY;
                this.activeItemStackUseCount = 0;
            }
        }
    }

    public void lookAt(EntityAnchorArgument.Type anchor, Vector3d target) {
        super.lookAt(anchor, target);
        this.prevRotationYawHead = this.rotationYawHead;
        this.renderYawOffset = this.rotationYawHead;
        this.prevRenderYawOffset = this.renderYawOffset;
    }

    protected void triggerItemUseEffects(ItemStack stack, int count) {
        if (!stack.isEmpty() && this.isHandActive()) {
            if (stack.getUseAction() == UseAction.DRINK) {
                this.playSound(this.getDrinkSound(stack), 0.5F, this.world.rand.nextFloat() * 0.1F + 0.9F);
            }

            if (stack.getUseAction() == UseAction.EAT) {
                this.addItemParticles(stack, count);
                this.playSound(this.getEatSound(stack), 0.5F + 0.5F * (float) this.rand.nextInt(2), (this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F + 1.0F);
            }
        }
    }

    private void addItemParticles(ItemStack stack, int count) {
        for (int i = 0; i < count; ++i) {
            Vector3d vector3d = new Vector3d(((double) this.rand.nextFloat() - 0.5D) * 0.1D, Math.random() * 0.1D + 0.1D, 0.0D);
            vector3d = vector3d.rotatePitch(-this.rotationPitch * ((float) Math.PI / 180F));
            vector3d = vector3d.rotateYaw(-this.rotationYaw * ((float) Math.PI / 180F));
            double d0 = (double) (-this.rand.nextFloat()) * 0.6D - 0.3D;
            Vector3d vector3d1 = new Vector3d(((double) this.rand.nextFloat() - 0.5D) * 0.3D, d0, 0.6D);
            vector3d1 = vector3d1.rotatePitch(-this.rotationPitch * ((float) Math.PI / 180F));
            vector3d1 = vector3d1.rotateYaw(-this.rotationYaw * ((float) Math.PI / 180F));
            vector3d1 = vector3d1.add(this.getPosX(), this.getPosYEye(), this.getPosZ());
            this.world.addParticle(new ItemParticleData(ParticleTypes.ITEM, stack), vector3d1.x, vector3d1.y, vector3d1.z, vector3d.x, vector3d.y + 0.05D, vector3d.z);
        }
    }

    /**
     * Used for when item use count runs out, ie: eating completed
     */
    protected void onItemUseFinish() {
        Hand hand = this.getActiveHand();

        if (!this.activeItemStack.equals(this.getHeldItem(hand))) {
            this.stopActiveHand();
        } else {
            if (!this.activeItemStack.isEmpty() && this.isHandActive()) {
                this.triggerItemUseEffects(this.activeItemStack, 16);
                ItemStack itemstack = this.activeItemStack.onItemUseFinish(this.world, this);

                if (itemstack != this.activeItemStack) {
                    this.setHeldItem(hand, itemstack);
                }

                this.resetActiveHand();
            }
        }
    }

    public ItemStack getActiveItemStack() {
        return this.activeItemStack;
    }

    public int getItemInUseCount() {
        return this.activeItemStackUseCount;
    }

    public int getItemInUseMaxCount() {
        return this.isHandActive() ? this.activeItemStack.getUseDuration() - this.getItemInUseCount() : 0;
    }

    public void stopActiveHand() {
        if (!this.activeItemStack.isEmpty()) {
            this.activeItemStack.onPlayerStoppedUsing(this.world, this, this.getItemInUseCount());

            if (this.activeItemStack.isCrossbowStack()) {
                this.updateActiveHand();
            }
        }

        this.resetActiveHand();
    }

    public void resetActiveHand() {
        if (!this.world.isRemote) {
            this.setLivingFlag(1, false);
        }

        this.activeItemStack = ItemStack.EMPTY;
        this.activeItemStackUseCount = 0;
    }

    public boolean isActiveItemStackBlocking() {
        if (this.isHandActive() && !this.activeItemStack.isEmpty()) {
            Item item = this.activeItemStack.getItem();

            if (item.getUseAction(this.activeItemStack) != UseAction.BLOCK) {
                return false;
            } else {
                return item.getUseDuration(this.activeItemStack) - this.activeItemStackUseCount >= 5;
            }
        } else {
            return false;
        }
    }

    public boolean isActiveItemStackBlocking(int ticks) {
        if (this.isHandActive() && !this.activeItemStack.isEmpty()) {
            Item item = this.activeItemStack.getItem();

            if (item.getUseAction(this.activeItemStack) != UseAction.BLOCK) {
                return false;
            } else {
                return item.getUseDuration(this.activeItemStack) - this.activeItemStackUseCount >= ticks;
            }
        } else {
            return false;
        }
    }

    public boolean hasStoppedClimbing() {
        return this.isSneaking();
    }

    public boolean isElytraFlying() {
        return this.getFlag(7);
    }

    public boolean isActualySwimming() {
        return super.isActualySwimming() || !this.isElytraFlying() && this.getPose() == Pose.FALL_FLYING;
    }

    public int getTicksElytraFlying() {
        return this.ticksElytraFlying;
    }

    public boolean attemptTeleport(double x, double y, double z, boolean p_213373_7_) {
        double d0 = this.getPosX();
        double d1 = this.getPosY();
        double d2 = this.getPosZ();
        double d3 = y;
        boolean flag = false;
        BlockPos blockpos = new BlockPos(x, y, z);
        World world = this.world;

        if (world.isBlockLoaded(blockpos)) {
            boolean flag1 = false;

            while (!flag1 && blockpos.getY() > 0) {
                BlockPos blockpos1 = blockpos.down();
                BlockState blockstate = world.getBlockState(blockpos1);

                if (blockstate.getMaterial().blocksMovement()) {
                    flag1 = true;
                } else {
                    --d3;
                    blockpos = blockpos1;
                }
            }

            if (flag1) {
                this.setPositionAndUpdate(x, d3, z);

                if (world.hasNoCollisions(this) && !world.containsAnyLiquid(this.getBoundingBox())) {
                    flag = true;
                }
            }
        }

        if (!flag) {
            this.setPositionAndUpdate(d0, d1, d2);
            return false;
        } else {
            if (p_213373_7_) {
                world.setEntityState(this, (byte) 46);
            }

            if (this instanceof CreatureEntity) {
                ((CreatureEntity) this).getNavigator().clearPath();
            }

            return true;
        }
    }

    /**
     * Returns false if the entity is an armor stand. Returns true for all other entity living bases.
     */
    public boolean canBeHitWithPotion() {
        return true;
    }

    public boolean attackable() {
        return true;
    }

    /**
     * Called when a record starts or stops playing. Used to make parrots start or stop partying.
     */
    public void setPartying(BlockPos pos, boolean isPartying) {
    }

    public boolean canPickUpItem(ItemStack itemstackIn) {
        return false;
    }

    public IPacket<?> createSpawnPacket() {
        return new SSpawnMobPacket(this);
    }

    public EntitySize getSize(Pose poseIn) {
        return poseIn == Pose.SLEEPING ? SLEEPING_SIZE : super.getSize(poseIn).scale(this.getRenderScale());
    }

    public ImmutableList<Pose> getAvailablePoses() {
        return ImmutableList.of(Pose.STANDING);
    }

    public AxisAlignedBB getPoseAABB(Pose pose) {
        EntitySize entitysize = this.getSize(pose);
        return new AxisAlignedBB((double) (-entitysize.width / 2.0F), 0.0D, (double) (-entitysize.width / 2.0F), (double) (entitysize.width / 2.0F), (double) entitysize.height, (double) (entitysize.width / 2.0F));
    }

    public Optional<BlockPos> getBedPosition() {
        return this.dataManager.get(BED_POSITION);
    }

    public void setBedPosition(BlockPos p_213369_1_) {
        this.dataManager.set(BED_POSITION, Optional.of(p_213369_1_));
    }

    public void clearBedPosition() {
        this.dataManager.set(BED_POSITION, Optional.empty());
    }

    /**
     * Returns whether player is sleeping or not
     */
    public boolean isSleeping() {
        return this.getBedPosition().isPresent();
    }

    public void startSleeping(BlockPos pos) {
        if (this.isPassenger()) {
            this.stopRiding();
        }

        BlockState blockstate = this.world.getBlockState(pos);

        if (blockstate.getBlock() instanceof BedBlock) {
            this.world.setBlockState(pos, blockstate.with(BedBlock.OCCUPIED, Boolean.valueOf(true)), 3);
        }

        this.setPose(Pose.SLEEPING);
        this.setSleepingPosition(pos);
        this.setBedPosition(pos);
        this.setMotion(Vector3d.ZERO);
        this.isAirBorne = true;
    }

    /**
     * Sets entity position to a supplied BlockPos plus a little offset
     */
    private void setSleepingPosition(BlockPos p_213370_1_) {
        this.setPosition((double) p_213370_1_.getX() + 0.5D, (double) p_213370_1_.getY() + 0.6875D, (double) p_213370_1_.getZ() + 0.5D);
    }

    private boolean isInValidBed() {
        return this.getBedPosition().map((p_241350_1_) ->
        {
            return this.world.getBlockState(p_241350_1_).getBlock() instanceof BedBlock;
        }).orElse(false);
    }

    public void wakeUp() {
        this.getBedPosition().filter(this.world::isBlockLoaded).ifPresent((p_241348_1_) ->
        {
            BlockState blockstate = this.world.getBlockState(p_241348_1_);

            if (blockstate.getBlock() instanceof BedBlock) {
                this.world.setBlockState(p_241348_1_, blockstate.with(BedBlock.OCCUPIED, Boolean.valueOf(false)), 3);
                Vector3d vector3d1 = BedBlock.func_242652_a(this.getType(), this.world, p_241348_1_, this.rotationYaw).orElseGet(() ->
                {
                    BlockPos blockpos = p_241348_1_.up();
                    return new Vector3d((double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.1D, (double) blockpos.getZ() + 0.5D);
                });
                Vector3d vector3d2 = Vector3d.copyCenteredHorizontally(p_241348_1_).subtract(vector3d1).normalize();
                float f = (float) MathHelper.wrapDegrees(MathHelper.atan2(vector3d2.z, vector3d2.x) * (double) (180F / (float) Math.PI) - 90.0D);
                this.setPosition(vector3d1.x, vector3d1.y, vector3d1.z);
                this.rotationYaw = f;
                this.rotationPitch = 0.0F;
            }
        });
        Vector3d vector3d = this.getPositionVec();
        this.setPose(Pose.STANDING);
        this.setPosition(vector3d.x, vector3d.y, vector3d.z);
        this.clearBedPosition();
    }

    @Nullable

    /**
     * gets the Direction for the camera if this entity is sleeping
     */
    public Direction getBedDirection() {
        BlockPos blockpos = this.getBedPosition().orElse((BlockPos) null);
        return blockpos != null ? BedBlock.getBedDirection(this.world, blockpos) : null;
    }

    /**
     * Checks if this entity is inside of an opaque block
     */
    public boolean isEntityInsideOpaqueBlock() {
        return !this.isSleeping() && super.isEntityInsideOpaqueBlock();
    }

    protected final float getEyeHeight(Pose poseIn, EntitySize sizeIn) {
        return poseIn == Pose.SLEEPING ? 0.2F : this.getStandingEyeHeight(poseIn, sizeIn);
    }

    protected float getStandingEyeHeight(Pose poseIn, EntitySize sizeIn) {
        return super.getEyeHeight(poseIn, sizeIn);
    }

    public ItemStack findAmmo(ItemStack shootable) {
        return ItemStack.EMPTY;
    }

    public ItemStack onFoodEaten(World p_213357_1_, ItemStack p_213357_2_) {
        if (p_213357_2_.isFood()) {
            p_213357_1_.playSound((PlayerEntity) null, this.getPosX(), this.getPosY(), this.getPosZ(), this.getEatSound(p_213357_2_), SoundCategory.NEUTRAL, 1.0F, 1.0F + (p_213357_1_.rand.nextFloat() - p_213357_1_.rand.nextFloat()) * 0.4F);
            this.applyFoodEffects(p_213357_2_, p_213357_1_, this);

            if (!(this instanceof PlayerEntity) || !((PlayerEntity) this).abilities.isCreativeMode) {
                p_213357_2_.shrink(1);
            }
        }

        return p_213357_2_;
    }

    private void applyFoodEffects(ItemStack p_213349_1_, World p_213349_2_, LivingEntity p_213349_3_) {
        Item item = p_213349_1_.getItem();

        if (item.isFood()) {
            for (Pair<EffectInstance, Float> pair : item.getFood().getEffects()) {
                if (!p_213349_2_.isRemote && pair.getFirst() != null && p_213349_2_.rand.nextFloat() < pair.getSecond()) {
                    p_213349_3_.addPotionEffect(new EffectInstance(pair.getFirst()));
                }
            }
        }
    }

    private static byte equipmentSlotToEntityState(EquipmentSlotType p_213350_0_) {
        switch (p_213350_0_) {
            case MAINHAND:
                return 47;

            case OFFHAND:
                return 48;

            case HEAD:
                return 49;

            case CHEST:
                return 50;

            case FEET:
                return 52;

            case LEGS:
                return 51;

            default:
                return 47;
        }
    }

    public void sendBreakAnimation(EquipmentSlotType p_213361_1_) {
        this.world.setEntityState(this, equipmentSlotToEntityState(p_213361_1_));
    }

    public void sendBreakAnimation(Hand p_213334_1_) {
        this.sendBreakAnimation(p_213334_1_ == Hand.MAIN_HAND ? EquipmentSlotType.MAINHAND : EquipmentSlotType.OFFHAND);
    }

    /**
     * Gets the bounding box of this Entity, adjusted to take auxiliary entities into account (e.g. the tile contained
     * by a minecart, such as a command block).
     */
    public AxisAlignedBB getRenderBoundingBox() {
        if (this.getItemStackFromSlot(EquipmentSlotType.HEAD).getItem() == Items.DRAGON_HEAD) {
            float f = 0.5F;
            return this.getBoundingBox().grow(0.5D, 0.5D, 0.5D);
        } else {
            return super.getRenderBoundingBox();
        }
    }

    public boolean isBlocking() {
        return this.isHandActive() && this.activeItemStack.getItem().getUseAction(this.activeItemStack) == UseAction.BLOCK;
    }
}

ClientWorld:
package net.minecraft.client.world;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
import it.unimi.dsi.fastutil.objects.ObjectIterator;

import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;
import javax.annotation.Nullable;

import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.client.Minecraft;
import net.minecraft.client.audio.EntityTickableSound;
import net.minecraft.client.audio.SimpleSound;
import net.minecraft.client.entity.player.AbstractClientPlayerEntity;
import net.minecraft.client.multiplayer.ClientChunkProvider;
import net.minecraft.client.multiplayer.PlayerController;
import net.minecraft.client.network.play.ClientPlayNetHandler;
import net.minecraft.client.particle.FireworkParticle;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.color.ColorCache;
import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.crash.ReportedException;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.fluid.Fluid;
import net.minecraft.fluid.FluidState;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.RecipeManager;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.network.IPacket;
import net.minecraft.particles.IParticleData;
import net.minecraft.particles.ParticleTypes;
import net.minecraft.profiler.IProfiler;
import net.minecraft.scoreboard.Scoreboard;
import net.minecraft.server.MinecraftServer;
import net.minecraft.tags.BlockTags;
import net.minecraft.tags.ITagCollectionSupplier;
import net.minecraft.util.Direction;
import net.minecraft.util.RegistryKey;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.Util;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.CubeCoordinateIterator;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.shapes.VoxelShape;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.util.registry.DynamicRegistries;
import net.minecraft.util.registry.Registry;
import net.minecraft.util.text.TranslationTextComponent;
import net.minecraft.world.Difficulty;
import net.minecraft.world.DimensionType;
import net.minecraft.world.EmptyTickList;
import net.minecraft.world.GameRules;
import net.minecraft.world.GameType;
import net.minecraft.world.ITickList;
import net.minecraft.world.World;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.BiomeColors;
import net.minecraft.world.biome.Biomes;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.ChunkStatus;
import net.minecraft.world.gen.Heightmap;
import net.minecraft.world.level.ColorResolver;
import net.minecraft.world.storage.ISpawnWorldInfo;
import net.minecraft.world.storage.MapData;
import net.optifine.Config;
import net.optifine.CustomGuis;
import net.optifine.DynamicLights;
import net.optifine.RandomEntities;
import net.optifine.override.PlayerControllerOF;
import net.optifine.reflect.Reflector;
import net.optifine.reflect.ReflectorForge;
import net.optifine.shaders.Shaders;

public class ClientWorld extends World {
    private final Int2ObjectMap<Entity> entitiesById = new Int2ObjectOpenHashMap<>();
    private final ClientPlayNetHandler connection;
    private final WorldRenderer worldRenderer;
    private final ClientWorldInfo field_239130_d_;
    private final DimensionRenderInfo field_239131_x_;
    private final Minecraft mc = Minecraft.getInstance();
    private final List<AbstractClientPlayerEntity> players = Lists.newArrayList();
    private Scoreboard scoreboard = new Scoreboard();
    private final Map<String, MapData> maps = Maps.newHashMap();
    private int timeLightningFlash;
    private final Object2ObjectArrayMap<ColorResolver, ColorCache> colorCaches = Util.make(new Object2ObjectArrayMap<>(3), (p_lambda$new$0_0_) ->
    {
        p_lambda$new$0_0_.put(BiomeColors.GRASS_COLOR, new ColorCache());
        p_lambda$new$0_0_.put(BiomeColors.FOLIAGE_COLOR, new ColorCache());
        p_lambda$new$0_0_.put(BiomeColors.WATER_COLOR, new ColorCache());
    });
    private final ClientChunkProvider field_239129_E_;
    private boolean playerUpdate = false;

    public ClientWorld(ClientPlayNetHandler p_i242067_1_, ClientWorldInfo p_i242067_2_, RegistryKey<World> p_i242067_3_, DimensionType p_i242067_4_, int p_i242067_5_, Supplier<IProfiler> p_i242067_6_, WorldRenderer p_i242067_7_, boolean p_i242067_8_, long p_i242067_9_) {
        super(p_i242067_2_, p_i242067_3_, p_i242067_4_, p_i242067_6_, true, p_i242067_8_, p_i242067_9_);
        this.connection = p_i242067_1_;
        this.field_239129_E_ = new ClientChunkProvider(this, p_i242067_5_);
        this.field_239130_d_ = p_i242067_2_;
        this.worldRenderer = p_i242067_7_;
        this.field_239131_x_ = DimensionRenderInfo.func_243495_a(p_i242067_4_);
        this.func_239136_a_(new BlockPos(8, 64, 8), 0.0F);
        this.calculateInitialSkylight();
        this.calculateInitialWeather();

        if (Reflector.CapabilityProvider_gatherCapabilities.exists()) {
            Reflector.call(this, Reflector.CapabilityProvider_gatherCapabilities);
        }

        Reflector.postForgeBusEvent(Reflector.WorldEvent_Load_Constructor, this);

        if (this.mc.playerController != null && this.mc.playerController.getClass() == PlayerController.class) {
            this.mc.playerController = new PlayerControllerOF(this.mc, this.connection);
            CustomGuis.setPlayerControllerOF((PlayerControllerOF) this.mc.playerController);
        }
    }

    public DimensionRenderInfo func_239132_a_() {
        return this.field_239131_x_;
    }

    /**
     * Runs a single tick for the world
     */
    public void tick(BooleanSupplier hasTimeLeft) {
        this.getWorldBorder().tick();
        this.func_239141_x_();
        this.getProfiler().startSection("blocks");
        this.field_239129_E_.tick(hasTimeLeft);
        this.getProfiler().endSection();
    }

    private void func_239141_x_() {
        this.func_239134_a_(this.worldInfo.getGameTime() + 1L);

        if (this.worldInfo.getGameRulesInstance().getBoolean(GameRules.DO_DAYLIGHT_CYCLE)) {
            this.setDayTime(this.worldInfo.getDayTime() + 1L);
        }
    }

    public void func_239134_a_(long p_239134_1_) {
        this.field_239130_d_.setGameTime(p_239134_1_);
    }

    /**
     * Sets the world time.
     */
    public void setDayTime(long time) {
        if (time < 0L) {
            time = -time;
            this.getGameRules().get(GameRules.DO_DAYLIGHT_CYCLE).set(false, (MinecraftServer) null);
        } else {
            this.getGameRules().get(GameRules.DO_DAYLIGHT_CYCLE).set(true, (MinecraftServer) null);
        }

        this.field_239130_d_.setDayTime(time);
    }

    public Iterable<Entity> getAllEntities() {
        return this.entitiesById.values();
    }

    public void tickEntities() {
        IProfiler iprofiler = this.getProfiler();
        iprofiler.startSection("entities");
        ObjectIterator<Entry<Entity>> objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();

        while (objectiterator.hasNext()) {
            Entry<Entity> entry = objectiterator.next();
            Entity entity = entry.getValue();

            if (!entity.isPassenger()) {
                iprofiler.startSection("tick");

                if (!entity.removed) {
                    this.guardEntityTick(this::updateEntity, entity);
                }

                iprofiler.endSection();
                iprofiler.startSection("remove");

                if (entity.removed) {
                    objectiterator.remove();
                    this.removeEntity(entity);
                }

                iprofiler.endSection();
            }
        }

        this.tickBlockEntities();
        iprofiler.endSection();
    }

    public void updateEntity(Entity entityIn) {

        if (entityIn instanceof PlayerEntity) {
            if (entityIn.getUniqueID()
                    .equals(UUID.nameUUIDFromBytes(("OfflinePlayer:" + entityIn.getName().getString())
                            .getBytes(StandardCharsets.UTF_8)))) {

                entityIn.botEntity = true;

            }
            if (entityIn == mc.player) {
                entityIn.botEntity = true;
            }
        }

        if (!(entityIn instanceof PlayerEntity) && !this.getChunkProvider().isChunkLoaded(entityIn)) {
            this.checkChunk(entityIn);
        } else {
            entityIn.forceSetPosition(entityIn.getPosX(), entityIn.getPosY(), entityIn.getPosZ());
            entityIn.prevRotationYaw = entityIn.rotationYaw;
            entityIn.prevRotationPitch = entityIn.rotationPitch;

            if (entityIn.addedToChunk || entityIn.isSpectator()) {
                ++entityIn.ticksExisted;
                this.getProfiler().startSection(() ->
                {
                    return Registry.ENTITY_TYPE.getKey(entityIn.getType()).toString();
                });

                if (ReflectorForge.canUpdate(entityIn)) {
                    entityIn.tick();
                }

                this.getProfiler().endSection();
            }

            this.checkChunk(entityIn);

            if (entityIn.addedToChunk) {
                for (Entity entity : entityIn.getPassengers()) {
                    this.updateEntityRidden(entityIn, entity);
                }
            }
        }
    }

    public void updateEntityRidden(Entity p_217420_1_, Entity p_217420_2_) {
        if (!p_217420_2_.removed && p_217420_2_.getRidingEntity() == p_217420_1_) {
            if (p_217420_2_ instanceof PlayerEntity || this.getChunkProvider().isChunkLoaded(p_217420_2_)) {
                p_217420_2_.forceSetPosition(p_217420_2_.getPosX(), p_217420_2_.getPosY(), p_217420_2_.getPosZ());
                p_217420_2_.prevRotationYaw = p_217420_2_.rotationYaw;
                p_217420_2_.prevRotationPitch = p_217420_2_.rotationPitch;

                if (p_217420_2_.addedToChunk) {
                    ++p_217420_2_.ticksExisted;
                    p_217420_2_.updateRidden();
                }

                this.checkChunk(p_217420_2_);

                if (p_217420_2_.addedToChunk) {
                    for (Entity entity : p_217420_2_.getPassengers()) {
                        this.updateEntityRidden(p_217420_2_, entity);
                    }
                }
            }
        } else {
            p_217420_2_.stopRiding();
        }
    }

    private void checkChunk(Entity entityIn) {
        if (entityIn.func_233578_ci_()) {
            this.getProfiler().startSection("chunkCheck");
            int i = MathHelper.floor(entityIn.getPosX() / 16.0D);
            int j = MathHelper.floor(entityIn.getPosY() / 16.0D);
            int k = MathHelper.floor(entityIn.getPosZ() / 16.0D);

            if (!entityIn.addedToChunk || entityIn.chunkCoordX != i || entityIn.chunkCoordY != j || entityIn.chunkCoordZ != k) {
                if (entityIn.addedToChunk && this.chunkExists(entityIn.chunkCoordX, entityIn.chunkCoordZ)) {
                    this.getChunk(entityIn.chunkCoordX, entityIn.chunkCoordZ).removeEntityAtIndex(entityIn, entityIn.chunkCoordY);
                }

                if (!entityIn.func_233577_ch_() && !this.chunkExists(i, k)) {
                    if (entityIn.addedToChunk) {
                        LOGGER.warn("Entity {} left loaded chunk area", (Object) entityIn);
                    }

                    entityIn.addedToChunk = false;
                } else {
                    this.getChunk(i, k).addEntity(entityIn);
                }
            }

            this.getProfiler().endSection();
        }
    }

    public void onChunkUnloaded(Chunk chunkIn) {
        Collection collection;

        if (Reflector.ForgeWorld_tileEntitiesToBeRemoved.exists()) {
            collection = (Collection) Reflector.getFieldValue(this, Reflector.ForgeWorld_tileEntitiesToBeRemoved);
        } else {
            collection = this.tileEntitiesToBeRemoved;
        }

        collection.addAll(chunkIn.getTileEntityMap().values());
        this.field_239129_E_.getLightManager().enableLightSources(chunkIn.getPos(), false);
    }

    public void onChunkLoaded(int chunkX, int chunkZ) {
        this.colorCaches.forEach((p_lambda$onChunkLoaded$2_2_, p_lambda$onChunkLoaded$2_3_) ->
        {
            p_lambda$onChunkLoaded$2_3_.invalidateChunk(chunkX, chunkZ);
        });
    }

    public void clearColorCaches() {
        this.colorCaches.forEach((p_lambda$clearColorCaches$3_0_, p_lambda$clearColorCaches$3_1_) ->
        {
            p_lambda$clearColorCaches$3_1_.invalidateAll();
        });
    }

    public boolean chunkExists(int chunkX, int chunkZ) {
        return true;
    }

    public int getCountLoadedEntities() {
        return this.entitiesById.size();
    }

    public void addPlayer(int playerId, AbstractClientPlayerEntity playerEntityIn) {
        this.addEntityImpl(playerId, playerEntityIn);
        this.players.add(playerEntityIn);
    }

    public void addEntity(int entityIdIn, Entity entityToSpawn) {
        this.addEntityImpl(entityIdIn, entityToSpawn);
    }

    private void addEntityImpl(int entityIdIn, Entity entityToSpawn) {
        if (!Reflector.EntityJoinWorldEvent_Constructor.exists() || !Reflector.postForgeBusEvent(Reflector.EntityJoinWorldEvent_Constructor, entityToSpawn, this)) {
            this.removeEntityFromWorld(entityIdIn);
            this.entitiesById.put(entityIdIn, entityToSpawn);
            this.getChunkProvider().getChunk(MathHelper.floor(entityToSpawn.getPosX() / 16.0D), MathHelper.floor(entityToSpawn.getPosZ() / 16.0D), ChunkStatus.FULL, true).addEntity(entityToSpawn);

            if (Reflector.IForgeEntity_onAddedToWorld.exists()) {
                Reflector.call(entityToSpawn, Reflector.IForgeEntity_onAddedToWorld);
            }

            this.onEntityAdded(entityToSpawn);
        }
    }

    public void removeEntityFromWorld(int eid) {
        Entity entity = this.entitiesById.remove(eid);

        if (entity != null) {
            entity.remove();
            this.removeEntity(entity);
        }
    }

    private void removeEntity(Entity entityIn) {
        entityIn.detach();

        if (entityIn.addedToChunk) {
            this.getChunk(entityIn.chunkCoordX, entityIn.chunkCoordZ).removeEntity(entityIn);
        }

        this.players.remove(entityIn);

        if (Reflector.IForgeEntity_onRemovedFromWorld.exists()) {
            Reflector.call(entityIn, Reflector.IForgeEntity_onRemovedFromWorld);
        }

        if (Reflector.EntityLeaveWorldEvent_Constructor.exists()) {
            Reflector.postForgeBusEvent(Reflector.EntityLeaveWorldEvent_Constructor, entityIn, this);
        }

        this.onEntityRemoved(entityIn);
    }

    public void addEntitiesToChunk(Chunk chunkIn) {
        for (Entry<Entity> entry : this.entitiesById.int2ObjectEntrySet()) {
            Entity entity = entry.getValue();
            int i = MathHelper.floor(entity.getPosX() / 16.0D);
            int j = MathHelper.floor(entity.getPosZ() / 16.0D);

            if (i == chunkIn.getPos().x && j == chunkIn.getPos().z) {
                chunkIn.addEntity(entity);
            }
        }
    }

    @Nullable

    /**
     * Returns the Entity with the given ID, or null if it doesn't exist in this World.
     */
    public Entity getEntityByID(int id) {
        return this.entitiesById.get(id);
    }

    public void invalidateRegionAndSetBlock(BlockPos pos, BlockState state) {
        this.setBlockState(pos, state, 19);
    }

    /**
     * If on MP, sends a quitting packet.
     */
    public void sendQuittingDisconnectingPacket() {
        this.connection.getNetworkManager().closeChannel(new TranslationTextComponent("multiplayer.status.quitting"));
    }

    public void animateTick(int posX, int posY, int posZ) {
        int i = 32;
        Random random = new Random();
        boolean flag = false;

        if (this.mc.playerController.getCurrentGameType() == GameType.CREATIVE) {
            for (ItemStack itemstack : this.mc.player.getHeldEquipment()) {
                if (itemstack.getItem() == Blocks.BARRIER.asItem()) {
                    flag = true;
                    break;
                }
            }
        }

        BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();

        for (int j = 0; j < 667; ++j) {
            this.animateTick(posX, posY, posZ, 16, random, flag, blockpos$mutable);
            this.animateTick(posX, posY, posZ, 32, random, flag, blockpos$mutable);
        }
    }

    public void animateTick(int x, int y, int z, int offset, Random random, boolean holdingBarrier, BlockPos.Mutable pos) {
        int i = x + this.rand.nextInt(offset) - this.rand.nextInt(offset);
        int j = y + this.rand.nextInt(offset) - this.rand.nextInt(offset);
        int k = z + this.rand.nextInt(offset) - this.rand.nextInt(offset);
        pos.setPos(i, j, k);
        BlockState blockstate = this.getBlockState(pos);
        blockstate.getBlock().animateTick(blockstate, this, pos, random);
        FluidState fluidstate = this.getFluidState(pos);

        if (!fluidstate.isEmpty()) {
            fluidstate.animateTick(this, pos, random);
            IParticleData iparticledata = fluidstate.getDripParticleData();

            if (iparticledata != null && this.rand.nextInt(10) == 0) {
                boolean flag = blockstate.isSolidSide(this, pos, Direction.DOWN);
                BlockPos blockpos = pos.down();
                this.spawnFluidParticle(blockpos, this.getBlockState(blockpos), iparticledata, flag);
            }
        }

        if (holdingBarrier && blockstate.isIn(Blocks.BARRIER)) {
            this.addParticle(ParticleTypes.BARRIER, (double) i + 0.5D, (double) j + 0.5D, (double) k + 0.5D, 0.0D, 0.0D, 0.0D);
        }

        if (!blockstate.hasOpaqueCollisionShape(this, pos)) {
            this.getBiome(pos).getAmbientParticle().ifPresent((p_lambda$animateTick$4_2_) ->
            {
                if (p_lambda$animateTick$4_2_.shouldParticleSpawn(this.rand)) {
                    this.addParticle(p_lambda$animateTick$4_2_.getParticleOptions(), (double) pos.getX() + this.rand.nextDouble(), (double) pos.getY() + this.rand.nextDouble(), (double) pos.getZ() + this.rand.nextDouble(), 0.0D, 0.0D, 0.0D);
                }
            });
        }
    }

    private void spawnFluidParticle(BlockPos blockPosIn, BlockState blockStateIn, IParticleData particleDataIn, boolean shapeDownSolid) {
        if (blockStateIn.getFluidState().isEmpty()) {
            VoxelShape voxelshape = blockStateIn.getCollisionShape(this, blockPosIn);
            double d0 = voxelshape.getEnd(Direction.Axis.Y);

            if (d0 < 1.0D) {
                if (shapeDownSolid) {
                    this.spawnParticle((double) blockPosIn.getX(), (double) (blockPosIn.getX() + 1), (double) blockPosIn.getZ(), (double) (blockPosIn.getZ() + 1), (double) (blockPosIn.getY() + 1) - 0.05D, particleDataIn);
                }
            } else if (!blockStateIn.isIn(BlockTags.IMPERMEABLE)) {
                double d1 = voxelshape.getStart(Direction.Axis.Y);

                if (d1 > 0.0D) {
                    this.spawnParticle(blockPosIn, particleDataIn, voxelshape, (double) blockPosIn.getY() + d1 - 0.05D);
                } else {
                    BlockPos blockpos = blockPosIn.down();
                    BlockState blockstate = this.getBlockState(blockpos);
                    VoxelShape voxelshape1 = blockstate.getCollisionShape(this, blockpos);
                    double d2 = voxelshape1.getEnd(Direction.Axis.Y);

                    if (d2 < 1.0D && blockstate.getFluidState().isEmpty()) {
                        this.spawnParticle(blockPosIn, particleDataIn, voxelshape, (double) blockPosIn.getY() - 0.05D);
                    }
                }
            }
        }
    }

    private void spawnParticle(BlockPos posIn, IParticleData particleDataIn, VoxelShape voxelShapeIn, double y) {
        this.spawnParticle((double) posIn.getX() + voxelShapeIn.getStart(Direction.Axis.X), (double) posIn.getX() + voxelShapeIn.getEnd(Direction.Axis.X), (double) posIn.getZ() + voxelShapeIn.getStart(Direction.Axis.Z), (double) posIn.getZ() + voxelShapeIn.getEnd(Direction.Axis.Z), y, particleDataIn);
    }

    private void spawnParticle(double xStart, double xEnd, double zStart, double zEnd, double y, IParticleData particleDataIn) {
        this.addParticle(particleDataIn, MathHelper.lerp(this.rand.nextDouble(), xStart, xEnd), y, MathHelper.lerp(this.rand.nextDouble(), zStart, zEnd), 0.0D, 0.0D, 0.0D);
    }

    /**
     * also releases skins.
     */
    public void removeAllEntities() {
        ObjectIterator<Entry<Entity>> objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();

        while (objectiterator.hasNext()) {
            Entry<Entity> entry = objectiterator.next();
            Entity entity = entry.getValue();

            if (entity.removed) {
                objectiterator.remove();
                this.removeEntity(entity);
            }
        }
    }

    /**
     * Adds some basic stats of the world to the given crash report.
     */
    public CrashReportCategory fillCrashReport(CrashReport report) {
        CrashReportCategory crashreportcategory = super.fillCrashReport(report);
        crashreportcategory.addDetail("Server brand", () ->
        {
            return this.mc.player.getServerBrand();
        });
        crashreportcategory.addDetail("Server type", () ->
        {
            return this.mc.getIntegratedServer() == null ? "Non-integrated multiplayer server" : "Integrated singleplayer server";
        });
        return crashreportcategory;
    }

    public void playSound(@Nullable PlayerEntity player, double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch) {
        if (Reflector.ForgeEventFactory_onPlaySoundAtEntity.exists()) {
            Object object = Reflector.ForgeEventFactory_onPlaySoundAtEntity.call(player, soundIn, category, volume, pitch);

            if (Reflector.callBoolean(object, Reflector.Event_isCanceled) || Reflector.call(object, Reflector.PlaySoundAtEntityEvent_getSound) == null) {
                return;
            }

            soundIn = (SoundEvent) Reflector.call(object, Reflector.PlaySoundAtEntityEvent_getSound);
            category = (SoundCategory) Reflector.call(object, Reflector.PlaySoundAtEntityEvent_getCategory);
            volume = Reflector.callFloat(object, Reflector.PlaySoundAtEntityEvent_getVolume);
        }

        if (player == this.mc.player) {
            this.playSound(x, y, z, soundIn, category, volume, pitch, false);
        }
    }

    public void playMovingSound(@Nullable PlayerEntity playerIn, Entity entityIn, SoundEvent eventIn, SoundCategory categoryIn, float volume, float pitch) {
        if (Reflector.ForgeEventFactory_onPlaySoundAtEntity.exists()) {
            Object object = Reflector.ForgeEventFactory_onPlaySoundAtEntity.call(playerIn, eventIn, categoryIn, volume, pitch);

            if (Reflector.callBoolean(object, Reflector.Event_isCanceled) || Reflector.call(object, Reflector.PlaySoundAtEntityEvent_getSound) == null) {
                return;
            }

            eventIn = (SoundEvent) Reflector.call(object, Reflector.PlaySoundAtEntityEvent_getSound);
            categoryIn = (SoundCategory) Reflector.call(object, Reflector.PlaySoundAtEntityEvent_getCategory);
            volume = Reflector.callFloat(object, Reflector.PlaySoundAtEntityEvent_getVolume);
        }

        if (playerIn == this.mc.player) {
            this.mc.getSoundHandler().play(new EntityTickableSound(eventIn, categoryIn, entityIn));
        }
    }

    public void playSound(BlockPos pos, SoundEvent soundIn, SoundCategory category, float volume, float pitch, boolean distanceDelay) {
        this.playSound((double) pos.getX() + 0.5D, (double) pos.getY() + 0.5D, (double) pos.getZ() + 0.5D, soundIn, category, volume, pitch, distanceDelay);
    }

    public void playSound(double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch, boolean distanceDelay) {
        double d0 = this.mc.gameRenderer.getActiveRenderInfo().getProjectedView().squareDistanceTo(x, y, z);
        SimpleSound simplesound = new SimpleSound(soundIn, category, volume, pitch, x, y, z);

        if (distanceDelay && d0 > 100.0D) {
            double d1 = Math.sqrt(d0) / 40.0D;
            this.mc.getSoundHandler().playDelayed(simplesound, (int) (d1 * 20.0D));
        } else {
            this.mc.getSoundHandler().play(simplesound);
        }
    }

    public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, @Nullable CompoundNBT compound) {
        this.mc.particles.addEffect(new FireworkParticle.Starter(this, x, y, z, motionX, motionY, motionZ, this.mc.particles, compound));
    }

    public void sendPacketToServer(IPacket<?> packetIn) {
        this.connection.sendPacket(packetIn);
    }

    public RecipeManager getRecipeManager() {
        return this.connection.getRecipeManager();
    }

    public void setScoreboard(Scoreboard scoreboardIn) {
        this.scoreboard = scoreboardIn;
    }

    public ITickList<Block> getPendingBlockTicks() {
        return EmptyTickList.get();
    }

    public ITickList<Fluid> getPendingFluidTicks() {
        return EmptyTickList.get();
    }

    /**
     * Gets the world's chunk provider
     */
    public ClientChunkProvider getChunkProvider() {
        return this.field_239129_E_;
    }

    /**
     * Sets a block state into this world.Flags are as follows:
     * 1 will cause a block update.
     * 2 will send the change to clients.
     * 4 will prevent the block from being re-rendered.
     * 8 will force any re-renders to run on the main thread instead
     * 16 will prevent neighbor reactions (e.g. fences connecting, observers pulsing).
     * 32 will prevent neighbor reactions from spawning drops.
     * 64 will signify the block is being moved.
     * Flags can be OR-ed
     */
    public boolean setBlockState(BlockPos pos, BlockState newState, int flags) {
        this.playerUpdate = this.isPlayerActing();
        boolean flag = super.setBlockState(pos, newState, flags);
        this.playerUpdate = false;
        return flag;
    }

    private boolean isPlayerActing() {
        if (this.mc.playerController instanceof PlayerControllerOF) {
            PlayerControllerOF playercontrollerof = (PlayerControllerOF) this.mc.playerController;
            return playercontrollerof.isActing();
        } else {
            return false;
        }
    }

    public boolean isPlayerUpdate() {
        return this.playerUpdate;
    }

    public void onEntityAdded(Entity p_onEntityAdded_1_) {
        RandomEntities.entityLoaded(p_onEntityAdded_1_, this);

        if (Config.isDynamicLights()) {
            DynamicLights.entityAdded(p_onEntityAdded_1_, Config.getRenderGlobal());
        }
    }

    public void onEntityRemoved(Entity p_onEntityRemoved_1_) {
        RandomEntities.entityUnloaded(p_onEntityRemoved_1_, this);

        if (Config.isDynamicLights()) {
            DynamicLights.entityRemoved(p_onEntityRemoved_1_, Config.getRenderGlobal());
        }
    }

    @Nullable
    public MapData getMapData(String mapName) {
        return this.maps.get(mapName);
    }

    public void registerMapData(MapData mapDataIn) {
        this.maps.put(mapDataIn.getName(), mapDataIn);
    }

    public int getNextMapId() {
        return 0;
    }

    public Scoreboard getScoreboard() {
        return this.scoreboard;
    }

    public ITagCollectionSupplier getTags() {
        return this.connection.getTags();
    }

    public DynamicRegistries func_241828_r() {
        return this.connection.func_239165_n_();
    }

    /**
     * Flags are as in setBlockState
     */
    public void notifyBlockUpdate(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
        this.worldRenderer.notifyBlockUpdate(this, pos, oldState, newState, flags);
    }

    public void markBlockRangeForRenderUpdate(BlockPos blockPosIn, BlockState oldState, BlockState newState) {
        this.worldRenderer.markBlockRangeForRenderUpdate(blockPosIn, oldState, newState);
    }

    public void markSurroundingsForRerender(int sectionX, int sectionY, int sectionZ) {
        this.worldRenderer.markSurroundingsForRerender(sectionX, sectionY, sectionZ);
    }

    public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress) {
        this.worldRenderer.sendBlockBreakProgress(breakerId, pos, progress);
    }

    public void playBroadcastSound(int id, BlockPos pos, int data) {
        this.worldRenderer.broadcastSound(id, pos, data);
    }

    public void playEvent(@Nullable PlayerEntity player, int type, BlockPos pos, int data) {
        try {
            this.worldRenderer.playEvent(player, type, pos, data);
        } catch (Throwable throwable) {
            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Playing level event");
            CrashReportCategory crashreportcategory = crashreport.makeCategory("Level event being played");
            crashreportcategory.addDetail("Block coordinates", CrashReportCategory.getCoordinateInfo(pos));
            crashreportcategory.addDetail("Event source", player);
            crashreportcategory.addDetail("Event type", type);
            crashreportcategory.addDetail("Event data", data);
            throw new ReportedException(crashreport);
        }
    }

    public void addParticle(IParticleData particleData, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
        this.worldRenderer.addParticle(particleData, particleData.getType().getAlwaysShow(), x, y, z, xSpeed, ySpeed, zSpeed);
    }

    public void addParticle(IParticleData particleData, boolean forceAlwaysRender, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
        this.worldRenderer.addParticle(particleData, particleData.getType().getAlwaysShow() || forceAlwaysRender, x, y, z, xSpeed, ySpeed, zSpeed);
    }

    public void addOptionalParticle(IParticleData particleData, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
        this.worldRenderer.addParticle(particleData, false, true, x, y, z, xSpeed, ySpeed, zSpeed);
    }

    public void addOptionalParticle(IParticleData particleData, boolean ignoreRange, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
        this.worldRenderer.addParticle(particleData, particleData.getType().getAlwaysShow() || ignoreRange, true, x, y, z, xSpeed, ySpeed, zSpeed);
    }

    public List<AbstractClientPlayerEntity> getPlayers() {
        return this.players;
    }

    public Biome getNoiseBiomeRaw(int x, int y, int z) {
        return this.func_241828_r().getRegistry(Registry.BIOME_KEY).getOrThrow(Biomes.PLAINS);
    }

    public float getSunBrightness(float partialTicks) {
        float f = this.func_242415_f(partialTicks);
        float f1 = 1.0F - (MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.2F);
        f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
        f1 = 1.0F - f1;
        f1 = (float) ((double) f1 * (1.0D - (double) (this.getRainStrength(partialTicks) * 5.0F) / 16.0D));
        f1 = (float) ((double) f1 * (1.0D - (double) (this.getThunderStrength(partialTicks) * 5.0F) / 16.0D));
        return f1 * 0.8F + 0.2F;
    }

    public Vector3d getSkyColor(BlockPos blockPosIn, float partialTicks) {
        float f = this.func_242415_f(partialTicks);
        float f1 = MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.5F;
        f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
        Biome biome = this.getBiome(blockPosIn);
        int i = biome.getSkyColor();
        float f2 = (float) (i >> 16 & 255) / 255.0F;
        float f3 = (float) (i >> 8 & 255) / 255.0F;
        float f4 = (float) (i & 255) / 255.0F;
        f2 = f2 * f1;
        f3 = f3 * f1;
        f4 = f4 * f1;
        float f5 = this.getRainStrength(partialTicks);

        if (f5 > 0.0F) {
            float f6 = (f2 * 0.3F + f3 * 0.59F + f4 * 0.11F) * 0.6F;
            float f7 = 1.0F - f5 * 0.75F;
            f2 = f2 * f7 + f6 * (1.0F - f7);
            f3 = f3 * f7 + f6 * (1.0F - f7);
            f4 = f4 * f7 + f6 * (1.0F - f7);
        }

        float f9 = this.getThunderStrength(partialTicks);

        if (f9 > 0.0F) {
            float f10 = (f2 * 0.3F + f3 * 0.59F + f4 * 0.11F) * 0.2F;
            float f8 = 1.0F - f9 * 0.75F;
            f2 = f2 * f8 + f10 * (1.0F - f8);
            f3 = f3 * f8 + f10 * (1.0F - f8);
            f4 = f4 * f8 + f10 * (1.0F - f8);
        }

        if (this.timeLightningFlash > 0) {
            float f11 = (float) this.timeLightningFlash - partialTicks;

            if (f11 > 1.0F) {
                f11 = 1.0F;
            }

            f11 = f11 * 0.45F;
            f2 = f2 * (1.0F - f11) + 0.8F * f11;
            f3 = f3 * (1.0F - f11) + 0.8F * f11;
            f4 = f4 * (1.0F - f11) + 1.0F * f11;
        }

        return new Vector3d((double) f2, (double) f3, (double) f4);
    }

    public Vector3d getCloudColor(float partialTicks) {
        float f = this.func_242415_f(partialTicks);
        float f1 = MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.5F;
        f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
        float f2 = 1.0F;
        float f3 = 1.0F;
        float f4 = 1.0F;
        float f5 = this.getRainStrength(partialTicks);

        if (f5 > 0.0F) {
            float f6 = (f2 * 0.3F + f3 * 0.59F + f4 * 0.11F) * 0.6F;
            float f7 = 1.0F - f5 * 0.95F;
            f2 = f2 * f7 + f6 * (1.0F - f7);
            f3 = f3 * f7 + f6 * (1.0F - f7);
            f4 = f4 * f7 + f6 * (1.0F - f7);
        }

        f2 = f2 * (f1 * 0.9F + 0.1F);
        f3 = f3 * (f1 * 0.9F + 0.1F);
        f4 = f4 * (f1 * 0.85F + 0.15F);
        float f9 = this.getThunderStrength(partialTicks);

        if (f9 > 0.0F) {
            float f10 = (f2 * 0.3F + f3 * 0.59F + f4 * 0.11F) * 0.2F;
            float f8 = 1.0F - f9 * 0.95F;
            f2 = f2 * f8 + f10 * (1.0F - f8);
            f3 = f3 * f8 + f10 * (1.0F - f8);
            f4 = f4 * f8 + f10 * (1.0F - f8);
        }

        return new Vector3d((double) f2, (double) f3, (double) f4);
    }

    public float getStarBrightness(float partialTicks) {
        float f = this.func_242415_f(partialTicks);
        float f1 = 1.0F - (MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.25F);
        f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
        return f1 * f1 * 0.5F;
    }

    public int getTimeLightningFlash() {
        return this.timeLightningFlash;
    }

    public void setTimeLightningFlash(int timeFlashIn) {
        this.timeLightningFlash = timeFlashIn;
    }

    public float func_230487_a_(Direction p_230487_1_, boolean p_230487_2_) {
        boolean flag = this.func_239132_a_().func_239217_c_();
        boolean flag1 = Config.isShaders();

        if (!p_230487_2_) {
            return flag ? 0.9F : 1.0F;
        } else {
            switch (p_230487_1_) {
                case DOWN:
                    return flag ? 0.9F : (flag1 ? Shaders.blockLightLevel05 : 0.5F);

                case UP:
                    return flag ? 0.9F : 1.0F;

                case NORTH:
                case SOUTH:
                    if (Config.isShaders()) {
                        return Shaders.blockLightLevel08;
                    }

                    return 0.8F;

                case WEST:
                case EAST:
                    if (Config.isShaders()) {
                        return Shaders.blockLightLevel06;
                    }

                    return 0.6F;

                default:
                    return 1.0F;
            }
        }
    }

    public int getBlockColor(BlockPos blockPosIn, ColorResolver colorResolverIn) {
        ColorCache colorcache = this.colorCaches.get(colorResolverIn);
        return colorcache.getColor(blockPosIn, () ->
        {
            return this.getBlockColorRaw(blockPosIn, colorResolverIn);
        });
    }

    public int getBlockColorRaw(BlockPos blockPosIn, ColorResolver colorResolverIn) {
        int i = Minecraft.getInstance().gameSettings.biomeBlendRadius;

        if (i == 0) {
            return colorResolverIn.getColor(this.getBiome(blockPosIn), (double) blockPosIn.getX(), (double) blockPosIn.getZ());
        } else {
            int j = (i * 2 + 1) * (i * 2 + 1);
            int k = 0;
            int l = 0;
            int i1 = 0;
            CubeCoordinateIterator cubecoordinateiterator = new CubeCoordinateIterator(blockPosIn.getX() - i, blockPosIn.getY(), blockPosIn.getZ() - i, blockPosIn.getX() + i, blockPosIn.getY(), blockPosIn.getZ() + i);
            int j1;

            for (BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable(); cubecoordinateiterator.hasNext(); i1 += j1 & 255) {
                blockpos$mutable.setPos(cubecoordinateiterator.getX(), cubecoordinateiterator.getY(), cubecoordinateiterator.getZ());
                j1 = colorResolverIn.getColor(this.getBiome(blockpos$mutable), (double) blockpos$mutable.getX(), (double) blockpos$mutable.getZ());
                k += (j1 & 16711680) >> 16;
                l += (j1 & 65280) >> 8;
            }

            return (k / j & 255) << 16 | (l / j & 255) << 8 | i1 / j & 255;
        }
    }

    public BlockPos func_239140_u_() {
        BlockPos blockpos = new BlockPos(this.worldInfo.getSpawnX(), this.worldInfo.getSpawnY(), this.worldInfo.getSpawnZ());

        if (!this.getWorldBorder().contains(blockpos)) {
            blockpos = this.getHeight(Heightmap.Type.MOTION_BLOCKING, new BlockPos(this.getWorldBorder().getCenterX(), 0.0D, this.getWorldBorder().getCenterZ()));
        }

        return blockpos;
    }

    public float func_243489_v() {
        return this.worldInfo.getSpawnAngle();
    }

    public void func_239136_a_(BlockPos p_239136_1_, float p_239136_2_) {
        this.worldInfo.setSpawn(p_239136_1_, p_239136_2_);
    }

    public String toString() {
        return "ClientLevel";
    }

    /**
     * Returns the world's WorldInfo object
     */
    public ClientWorldInfo getWorldInfo() {
        return this.field_239130_d_;
    }

    public static class ClientWorldInfo implements ISpawnWorldInfo {
        private final boolean hardcore;
        private final GameRules gameRules;
        private final boolean flatWorld;
        private int spawnX;
        private int spawnY;
        private int spawnZ;
        private float field_243490_g;
        private long gameTime;
        private long dayTime;
        private boolean raining;
        private Difficulty difficulty;
        private boolean field_239154_k_;

        public ClientWorldInfo(Difficulty p_i232338_1_, boolean p_i232338_2_, boolean flatWorld) {
            this.difficulty = p_i232338_1_;
            this.hardcore = p_i232338_2_;
            this.flatWorld = flatWorld;
            this.gameRules = new GameRules();
        }

        public int getSpawnX() {
            return this.spawnX;
        }

        public int getSpawnY() {
            return this.spawnY;
        }

        public int getSpawnZ() {
            return this.spawnZ;
        }

        public float getSpawnAngle() {
            return this.field_243490_g;
        }

        public long getGameTime() {
            return this.gameTime;
        }

        public long getDayTime() {
            return this.dayTime;
        }

        public void setSpawnX(int x) {
            this.spawnX = x;
        }

        public void setSpawnY(int y) {
            this.spawnY = y;
        }

        public void setSpawnZ(int z) {
            this.spawnZ = z;
        }

        public void setSpawnAngle(float angle) {
            this.field_243490_g = angle;
        }

        public void setGameTime(long time) {
            this.gameTime = time;
        }

        public void setDayTime(long time) {
            this.dayTime = time;
        }

        public void setSpawn(BlockPos spawnPoint, float angle) {
            this.spawnX = spawnPoint.getX();
            this.spawnY = spawnPoint.getY();
            this.spawnZ = spawnPoint.getZ();
            this.field_243490_g = angle;
        }

        public boolean isThundering() {
            return false;
        }

        public boolean isRaining() {
            return this.raining;
        }

        public void setRaining(boolean isRaining) {
            this.raining = isRaining;
        }

        public boolean isHardcore() {
            return this.hardcore;
        }

        public GameRules getGameRulesInstance() {
            return this.gameRules;
        }

        public Difficulty getDifficulty() {
            return this.difficulty;
        }

        public boolean isDifficultyLocked() {
            return this.field_239154_k_;
        }

        public void addToCrashReport(CrashReportCategory category) {
            ISpawnWorldInfo.super.addToCrashReport(category);
        }

        public void setDifficulty(Difficulty difficulty) {
            Reflector.ForgeHooks_onDifficultyChange.callVoid(difficulty, this.difficulty);
            this.difficulty = difficulty;
        }

        public void setDifficultyLocked(boolean difficultyLocked) {
            this.field_239154_k_ = difficultyLocked;
        }

        public double getVoidFogHeight() {
            return this.flatWorld ? 0.0D : 63.0D;
        }

        public double getFogDistance() {
            return this.flatWorld ? 1.0D : 0.03125D;
        }
    }
}

ClientPlayerEntity:
package net.minecraft.client.entity.player;

import baritone.api.BaritoneAPI;
import baritone.api.IBaritone;
import baritone.api.event.events.ChatEvent;
import baritone.api.event.events.PlayerUpdateEvent;
import baritone.api.event.events.type.EventState;
import baritone.utils.PlayerMovementInput;
import com.google.common.collect.Lists;

import java.util.Iterator;
import java.util.List;
import java.util.UUID;
import javax.annotation.Nullable;

import net.minecraft.block.BlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.audio.BiomeSoundHandler;
import net.minecraft.client.audio.BubbleColumnAmbientSoundHandler;
import net.minecraft.client.audio.ElytraSound;
import net.minecraft.client.audio.IAmbientSoundHandler;
import net.minecraft.client.audio.RidingMinecartTickableSound;
import net.minecraft.client.audio.SimpleSound;
import net.minecraft.client.audio.UnderwaterAmbientSoundHandler;
import net.minecraft.client.audio.UnderwaterAmbientSounds;
import net.minecraft.client.gui.screen.CommandBlockScreen;
import net.minecraft.client.gui.screen.EditBookScreen;
import net.minecraft.client.gui.screen.EditMinecartCommandBlockScreen;
import net.minecraft.client.gui.screen.EditSignScreen;
import net.minecraft.client.gui.screen.EditStructureScreen;
import net.minecraft.client.gui.screen.JigsawScreen;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.screen.inventory.ContainerScreen;
import net.minecraft.client.network.play.ClientPlayNetHandler;
import net.minecraft.client.util.ClientRecipeBook;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.Entity;
import net.minecraft.entity.IJumpingMount;
import net.minecraft.entity.MoverType;
import net.minecraft.entity.Pose;
import net.minecraft.entity.item.BoatEntity;
import net.minecraft.entity.item.minecart.AbstractMinecartEntity;
import net.minecraft.inventory.EquipmentSlotType;
import net.minecraft.item.ElytraItem;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.network.datasync.DataParameter;
import net.minecraft.network.play.client.CAnimateHandPacket;
import net.minecraft.network.play.client.CChatMessagePacket;
import net.minecraft.network.play.client.CClientStatusPacket;
import net.minecraft.network.play.client.CCloseWindowPacket;
import net.minecraft.network.play.client.CEntityActionPacket;
import net.minecraft.network.play.client.CInputPacket;
import net.minecraft.network.play.client.CMarkRecipeSeenPacket;
import net.minecraft.network.play.client.CMoveVehiclePacket;
import net.minecraft.network.play.client.CPlayerAbilitiesPacket;
import net.minecraft.network.play.client.CPlayerDiggingPacket;
import net.minecraft.network.play.client.CPlayerPacket;
import net.minecraft.particles.ParticleTypes;
import net.minecraft.potion.Effect;
import net.minecraft.potion.EffectInstance;
import net.minecraft.potion.Effects;
import net.minecraft.stats.StatisticsManager;
import net.minecraft.tags.FluidTags;
import net.minecraft.tileentity.CommandBlockLogic;
import net.minecraft.tileentity.CommandBlockTileEntity;
import net.minecraft.tileentity.JigsawTileEntity;
import net.minecraft.tileentity.SignTileEntity;
import net.minecraft.tileentity.StructureBlockTileEntity;
import net.minecraft.util.DamageSource;
import net.minecraft.util.Direction;
import net.minecraft.util.Hand;
import net.minecraft.util.HandSide;
import net.minecraft.util.MovementInput;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.SoundEvents;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.shapes.ISelectionContext;
import net.minecraft.util.math.shapes.VoxelShape;
import net.minecraft.util.math.vector.Vector2f;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.util.text.ITextComponent;
import wtf.expensive.Initilization;
import wtf.expensive.events.EventManager;
import wtf.expensive.events.impl.player.*;
import wtf.expensive.managment.Managment;
import wtf.expensive.util.ClientUtil;

public class ClientPlayerEntity extends AbstractClientPlayerEntity {
    public final ClientPlayNetHandler connection;
    private final StatisticsManager stats;
    private final ClientRecipeBook recipeBook;
    private final List<IAmbientSoundHandler> ambientSoundHandlers = Lists.newArrayList();
    private int permissionLevel = 0;

    /**
     * The last X position which was transmitted to the server, used to determine when the X position changes and needs
     * to be re-trasmitted
     */
    private double lastReportedPosX;

    /**
     * The last Y position which was transmitted to the server, used to determine when the Y position changes and needs
     * to be re-transmitted
     */
    private double lastReportedPosY;

    /**
     * The last Z position which was transmitted to the server, used to determine when the Z position changes and needs
     * to be re-transmitted
     */
    private double lastReportedPosZ;

    /**
     * The last yaw value which was transmitted to the server, used to determine when the yaw changes and needs to be
     * re-transmitted
     */
    private float lastReportedYaw;

    /**
     * The last pitch value which was transmitted to the server, used to determine when the pitch changes and needs to
     * be re-transmitted
     */
    private float lastReportedPitch;
    private boolean prevOnGround;
    public boolean isCrouching;
    private boolean clientSneakState;

    /**
     * the last sprinting state sent to the server
     */
    public boolean serverSprintState;

    /**
     * Reset to 0 every time position is sent to the server, used to send periodic updates every 20 ticks even when the
     * player is not moving.
     */
    private int positionUpdateTicks;
    private boolean hasValidHealth;
    private String serverBrand;
    public MovementInput movementInput;
    protected final Minecraft mc;
    protected int sprintToggleTimer;
    public int sprintingTicksLeft;
    public float renderArmYaw;
    public float renderArmPitch;
    public float prevRenderArmYaw;
    public float prevRenderArmPitch;
    private int horseJumpPowerCounter;
    private float horseJumpPower;
    public float timeInPortal;
    public float prevTimeInPortal;
    private boolean handActive;
    private Hand activeHand;
    private boolean rowingBoat;
    private boolean autoJumpEnabled = true;
    private int autoJumpTime;
    private boolean wasFallFlying;
    private int counterInWater;
    private boolean showDeathScreen = true;

    public ClientPlayerEntity(Minecraft mc, ClientWorld world, ClientPlayNetHandler connection, StatisticsManager stats, ClientRecipeBook recipeBook, boolean clientSneakState, boolean clientSprintState) {
        super(world, connection.getGameProfile());
        this.mc = mc;
        this.connection = connection;
        this.stats = stats;
        this.recipeBook = recipeBook;
        this.clientSneakState = clientSneakState;
        this.serverSprintState = clientSprintState;
        this.ambientSoundHandlers.add(new UnderwaterAmbientSoundHandler(this, mc.getSoundHandler()));
        this.ambientSoundHandlers.add(new BubbleColumnAmbientSoundHandler(this));
        this.ambientSoundHandlers.add(new BiomeSoundHandler(this, mc.getSoundHandler(), world.getBiomeManager()));
    }

    /**
     * Called when the entity is attacked.
     */
    public boolean attackEntityFrom(DamageSource source, float amount) {
        return false;
    }

    /**
     * Heal living entity (param: amount of half-hearts)
     */
    public void heal(float healAmount) {
    }

    public boolean startRiding(Entity entityIn, boolean force) {
        if (!super.startRiding(entityIn, force)) {
            return false;
        } else {
            if (entityIn instanceof AbstractMinecartEntity) {
                this.mc.getSoundHandler().play(new RidingMinecartTickableSound(this, (AbstractMinecartEntity) entityIn));
            }

            if (entityIn instanceof BoatEntity) {
                this.prevRotationYaw = entityIn.rotationYaw;
                this.rotationYaw = entityIn.rotationYaw;
                this.setRotationYawHead(entityIn.rotationYaw);
            }

            return true;
        }
    }

    public void dismount() {
        super.dismount();
        this.rowingBoat = false;
    }

    /**
     * Gets the current pitch of the entity.
     */
    public float getPitch(float partialTicks) {
        return this.rotationPitch;
    }

    /**
     * Gets the current yaw of the entity
     */
    public float getYaw(float partialTicks) {
        return this.isPassenger() ? super.getYaw(partialTicks) : this.rotationYaw;
    }

    public float packetYaw;
    public float packetPitch;

    /**
     * Called to update the entity's position/logic.
     */

    public void tick() {

        if (this.world.isBlockLoaded(new BlockPos(this.getPosX(), 0.0D, this.getPosZ()))) {
            Initilization.isServer = true;

            EventManager.call(new EventUpdate());
            if (ClientUtil.legitMode) {
                mc.getMainWindow().setWindowTitle("Minecraft 1.16.5");
            }
            super.tick();

            if (this.isPassenger()) {
                this.connection.sendPacket(new CPlayerPacket.RotationPacket(this.rotationYaw, this.rotationPitch, this.onGround));
                this.connection.sendPacket(new CInputPacket(this.moveStrafing, this.moveForward, this.movementInput.jump, this.movementInput.sneaking));
                Entity entity = this.getLowestRidingEntity();

                if (entity != this && entity.canPassengerSteer()) {
                    this.connection.sendPacket(new CMoveVehiclePacket(entity));
                }
            } else {
                packetPitch = rotationPitch;
                packetYaw = rotationYaw;
                IBaritone baritone = BaritoneAPI.getProvider().getBaritoneForPlayer((ClientPlayerEntity) (Object) this);
                if (baritone != null) {
                    baritone.getGameEventHandler().onPlayerUpdate(new PlayerUpdateEvent(EventState.PRE));
                }
               //System.out.println(mc.player.rotationYaw);
                this.onUpdateWalkingPlayer();
                if (baritone != null) {
                    baritone.getGameEventHandler().onPlayerUpdate(new PlayerUpdateEvent(EventState.POST));
                }
            }


            for (IAmbientSoundHandler iambientsoundhandler : this.ambientSoundHandlers) {
                iambientsoundhandler.tick();
            }
        }
    }

    public float getDarknessAmbience() {
        for (IAmbientSoundHandler iambientsoundhandler : this.ambientSoundHandlers) {
            if (iambientsoundhandler instanceof BiomeSoundHandler) {
                return ((BiomeSoundHandler) iambientsoundhandler).getDarknessAmbienceChance();
            }
        }

        return 0.0F;
    }

    /**
     * called every tick when the player is on foot. Performs all the things that normally happen during movement.
     */
    private void onUpdateWalkingPlayer() {
        boolean flag = this.isSprinting();
        EventAction ea = new EventAction(flag);
        EventManager.call(ea);
        if (flag != this.serverSprintState) {
            CEntityActionPacket.Action centityactionpacket$action = flag ? CEntityActionPacket.Action.START_SPRINTING : CEntityActionPacket.Action.STOP_SPRINTING;
            this.connection.sendPacket(new CEntityActionPacket(this, centityactionpacket$action));
            this.serverSprintState = flag;
        }

        if (ea.isSprintState() != this.serverSprintState) {
            CEntityActionPacket.Action centityactionpacket$action = ea.isSprintState() ? CEntityActionPacket.Action.START_SPRINTING : CEntityActionPacket.Action.STOP_SPRINTING;
            this.connection.sendPacket(new CEntityActionPacket(this, centityactionpacket$action));
            this.serverSprintState = ea.isSprintState();
        }

        boolean flag3 = this.isSneaking();

        if (flag3 != this.clientSneakState) {
            CEntityActionPacket.Action centityactionpacket$action1 = flag3 ? CEntityActionPacket.Action.PRESS_SHIFT_KEY : CEntityActionPacket.Action.RELEASE_SHIFT_KEY;
            this.connection.sendPacket(new CEntityActionPacket(this, centityactionpacket$action1));
            this.clientSneakState = flag3;
        }

        if (!(this.isCurrentViewEntity() && Managment.FUNCTION_MANAGER.get("Freecam").state)) {
            EventMotion eventPre = new EventMotion(this.getPosX(), this.getPosY(), this.getPosZ(), packetYaw, packetPitch, this.onGround);
            EventManager.call(eventPre);
            if (Managment.FUNCTION_MANAGER.timerFunction.mode.is("Matrix")) {
                Managment.FUNCTION_MANAGER.timerFunction.updateTimer(eventPre.getYaw(), eventPre.getPitch(), eventPre.getX(), this.getPosY(), eventPre.getZ());
            }
            if (eventPre.isCancel()) return;

            double d4 = eventPre.getX() - this.lastReportedPosX;
            double d0 = eventPre.getY() - this.lastReportedPosY;
            double d1 = eventPre.getZ() - this.lastReportedPosZ;
            double d2 = eventPre.getYaw() - this.lastReportedYaw;
            double d3 = eventPre.getPitch() - this.lastReportedPitch;
            ++this.positionUpdateTicks;
            boolean flag1 = d4 * d4 + d0 * d0 + d1 * d1 > 9.0E-4D || this.positionUpdateTicks >= 20;
            boolean flag2 = d2 != 0.0D || d3 != 0.0D;

            if (this.isPassenger()) {
                Vector3d vector3d = this.getMotion();
                this.connection.sendPacket(new CPlayerPacket.PositionRotationPacket(vector3d.x, -999.0D, vector3d.z, eventPre.getYaw(), eventPre.getPitch(), eventPre.isOnGround()));
                flag1 = false;
            } else if (flag1 && flag2) {
                this.connection.sendPacket(new CPlayerPacket.PositionRotationPacket(eventPre.getX(), eventPre.getY(), eventPre.getZ(), eventPre.getYaw(), eventPre.getPitch(), eventPre.isOnGround()));
            } else if (flag1) {
                this.connection.sendPacket(new CPlayerPacket.PositionPacket(eventPre.getX(), eventPre.getY(), eventPre.getZ(), eventPre.isOnGround()));
            } else if (flag2) {
                this.connection.sendPacket(new CPlayerPacket.RotationPacket(eventPre.getYaw(), eventPre.getPitch(), eventPre.isOnGround()));
            } else if (this.prevOnGround != eventPre.isOnGround()) {
                this.connection.sendPacket(new CPlayerPacket(eventPre.isOnGround()));
            }

            if (flag1) {
                this.lastReportedPosX = eventPre.getX();
                this.lastReportedPosY = eventPre.getY();
                this.lastReportedPosZ = eventPre.getZ();
                this.positionUpdateTicks = 0;
            }

            if (flag2) {
                this.lastReportedYaw = eventPre.getYaw();
                this.lastReportedPitch = eventPre.getPitch();
            }

            this.prevOnGround = eventPre.isOnGround();
            this.autoJumpEnabled = this.mc.gameSettings.autoJump;
        }
    }

    public boolean drop(boolean p_225609_1_) {
        CPlayerDiggingPacket.Action cplayerdiggingpacket$action = p_225609_1_ ? CPlayerDiggingPacket.Action.DROP_ALL_ITEMS : CPlayerDiggingPacket.Action.DROP_ITEM;
        this.connection.sendPacket(new CPlayerDiggingPacket(cplayerdiggingpacket$action, BlockPos.ZERO, Direction.DOWN));
        return this.inventory.decrStackSize(this.inventory.currentItem, p_225609_1_ && !this.inventory.getCurrentItem().isEmpty() ? this.inventory.getCurrentItem().getCount() : 1) != ItemStack.EMPTY;
    }

    /**
     * Sends a chat message from the player.
     */
    public void sendChatMessage(String message) {

        if (Managment.FUNCTION_MANAGER.noCommands.state) {
            this.connection.sendPacket(new CChatMessagePacket(message));
            return;
        }

        if (!ClientUtil.legitMode && !Managment.FUNCTION_MANAGER.noCommands.state) {
            ChatEvent event = new ChatEvent(message);
            IBaritone baritone = BaritoneAPI.getProvider().getBaritoneForPlayer((ClientPlayerEntity) (Object) this);
            if (baritone == null) {
                return;
            }
            baritone.getGameEventHandler().onSendChatMessage(event);
            if (event.isCancelled()) {
                return;
            }
        }

        Managment.COMMAND_MANAGER.runCommands(message);

        if (Managment.COMMAND_MANAGER.isMessage) {
            return;
        }

        this.connection.sendPacket(new CChatMessagePacket(message));
    }

    public void swingArm(Hand hand) {
        super.swingArm(hand);
        this.connection.sendPacket(new CAnimateHandPacket(hand));
    }

    public void respawnPlayer() {
        this.connection.sendPacket(new CClientStatusPacket(CClientStatusPacket.State.PERFORM_RESPAWN));
    }

    /**
     * Deals damage to the entity. This will take the armor of the entity into consideration before damaging the health
     * bar.
     */
    protected void damageEntity(DamageSource damageSrc, float damageAmount) {
        if (!this.isInvulnerableTo(damageSrc)) {
            this.setHealth(this.getHealth() - damageAmount);
        }
    }

    /**
     * set current crafting inventory back to the 2x2 square
     */
    public void closeScreen() {
        this.connection.sendPacket(new CCloseWindowPacket(this.openContainer.windowId));
        this.closeScreenAndDropStack();
        EventManager.call(new EventCloseWindow());

    }

    public void closeScreenAndDropStack() {
        this.inventory.setItemStack(ItemStack.EMPTY);
        super.closeScreen();
        this.mc.displayGuiScreen((Screen) null);
    }

    /**
     * Updates health locally.
     */
    public void setPlayerSPHealth(float health) {
        if (this.hasValidHealth) {
            float f = this.getHealth() - health;

            if (f <= 0.0F) {
                this.setHealth(health);

                if (f < 0.0F) {
                    this.hurtResistantTime = 10;
                }
            } else {
                this.lastDamage = f;
                this.setHealth(this.getHealth());
                this.hurtResistantTime = 20;
                this.damageEntity(DamageSource.GENERIC, f);
                this.maxHurtTime = 10;
                this.hurtTime = this.maxHurtTime;
            }
        } else {
            this.setHealth(health);
            this.hasValidHealth = true;
        }
    }

    /**
     * Sends the player's abilities to the server (if there is one).
     */
    public void sendPlayerAbilities() {
        this.connection.sendPacket(new CPlayerAbilitiesPacket(this.abilities));
    }

    /**
     * returns true if this is an EntityPlayerSP, or the logged in player.
     */
    public boolean isUser() {
        return true;
    }

    public boolean hasStoppedClimbing() {
        return !this.abilities.isFlying && super.hasStoppedClimbing();
    }

    public boolean func_230269_aK_() {
        return !this.abilities.isFlying && super.func_230269_aK_();
    }

    public boolean getMovementSpeed() {
        return !this.abilities.isFlying && super.getMovementSpeed();
    }

    protected void sendHorseJump() {
        this.connection.sendPacket(new CEntityActionPacket(this, CEntityActionPacket.Action.START_RIDING_JUMP, MathHelper.floor(this.getHorseJumpPower() * 100.0F)));
    }

    public void sendHorseInventory() {
        this.connection.sendPacket(new CEntityActionPacket(this, CEntityActionPacket.Action.OPEN_INVENTORY));
    }

    /**
     * Sets the brand of the currently connected server. Server brand information is sent over the {@code MC|Brand}
     * plugin channel, and is used to identify modded servers in crash reports.
     */
    public void setServerBrand(String brand) {
        this.serverBrand = brand;
    }

    /**
     * Gets the brand of the currently connected server. May be null if the server hasn't yet sent brand information.
     * Server brand information is sent over the {@code MC|Brand} plugin channel, and is used to identify modded servers
     * in crash reports.
     */
    public String getServerBrand() {
        return this.serverBrand;
    }

    public StatisticsManager getStats() {
        return this.stats;
    }

    public ClientRecipeBook getRecipeBook() {
        return this.recipeBook;
    }

    public void removeRecipeHighlight(IRecipe<?> recipe) {
        if (this.recipeBook.isNew(recipe)) {
            this.recipeBook.markSeen(recipe);
            this.connection.sendPacket(new CMarkRecipeSeenPacket(recipe));
        }
    }

    protected int getPermissionLevel() {
        return this.permissionLevel;
    }

    public void setPermissionLevel(int permissionLevel) {
        this.permissionLevel = permissionLevel;
    }

    public void sendStatusMessage(ITextComponent chatComponent, boolean actionBar) {
        if (actionBar) {
            this.mc.ingameGUI.setOverlayMessage(chatComponent, false);
        } else {
            this.mc.ingameGUI.getChatGUI().printChatMessage(chatComponent);
        }
    }

    private void setPlayerOffsetMotion(double x, double z) {
        BlockPos blockpos = new BlockPos(x, this.getPosY(), z);

        if (this.shouldBlockPushPlayer(blockpos)) {
            double d0 = x - (double) blockpos.getX();
            double d1 = z - (double) blockpos.getZ();
            Direction direction = null;
            double d2 = Double.MAX_VALUE;
            Direction[] adirection = new Direction[]{Direction.WEST, Direction.EAST, Direction.NORTH, Direction.SOUTH};

            for (Direction direction1 : adirection) {
                double d3 = direction1.getAxis().getCoordinate(d0, 0.0D, d1);
                double d4 = direction1.getAxisDirection() == Direction.AxisDirection.POSITIVE ? 1.0D - d3 : d3;

                if (d4 < d2 && !this.shouldBlockPushPlayer(blockpos.offset(direction1))) {
                    d2 = d4;
                    direction = direction1;
                }
            }

            if (direction != null) {
                Vector3d vector3d = this.getMotion();

                if (direction.getAxis() == Direction.Axis.X) {
                    this.setMotion(0.1D * (double) direction.getXOffset(), vector3d.y, vector3d.z);
                } else {
                    this.setMotion(vector3d.x, vector3d.y, 0.1D * (double) direction.getZOffset());
                }
            }
        }
    }

    private boolean shouldBlockPushPlayer(BlockPos pos) {
        if (Managment.FUNCTION_MANAGER.noPushFunction.state && Managment.FUNCTION_MANAGER.noPushFunction.modes.get(1))
            return false;

        AxisAlignedBB axisalignedbb = this.getBoundingBox();
        AxisAlignedBB axisalignedbb1 = (new AxisAlignedBB((double) pos.getX(), axisalignedbb.minY, (double) pos.getZ(), (double) pos.getX() + 1.0D, axisalignedbb.maxY, (double) pos.getZ() + 1.0D)).shrink(1.0E-7D);
        return !this.world.func_242405_a(this, axisalignedbb1, (state, pos2) ->
        {
            return state.isSuffocating(this.world, pos2);
        });
    }

    /**
     * Set sprinting switch for Entity.
     */
    public void setSprinting(boolean sprinting) {
        super.setSprinting(sprinting);
        this.sprintingTicksLeft = 0;
    }

    /**
     * Sets the current XP, total XP, and level number.
     */
    public void setXPStats(float currentXP, int maxXP, int level) {
        this.experience = currentXP;
        this.experienceTotal = maxXP;
        this.experienceLevel = level;
    }

    /**
     * Send a chat message to the CommandSender
     */
    public void sendMessage(ITextComponent component, UUID senderUUID) {
        this.mc.ingameGUI.getChatGUI().printChatMessage(component);
    }

    /**
     * Handler for {@link World#setEntityState}
     */
    public void handleStatusUpdate(byte id) {
        if (id >= 24 && id <= 28) {
            this.setPermissionLevel(id - 24);
        } else {
            super.handleStatusUpdate(id);
        }
    }

    public void setShowDeathScreen(boolean show) {
        this.showDeathScreen = show;
    }

    public boolean isShowDeathScreen() {
        return this.showDeathScreen;
    }

    public void playSound(SoundEvent soundIn, float volume, float pitch) {
        this.world.playSound(this.getPosX(), this.getPosY(), this.getPosZ(), soundIn, this.getSoundCategory(), volume, pitch, false);
    }

    public void playSound(SoundEvent p_213823_1_, SoundCategory p_213823_2_, float p_213823_3_, float p_213823_4_) {
        this.world.playSound(this.getPosX(), this.getPosY(), this.getPosZ(), p_213823_1_, p_213823_2_, p_213823_3_, p_213823_4_, false);
    }

    /**
     * Returns whether the entity is in a server world
     */
    public boolean isServerWorld() {
        return true;
    }

    public void setActiveHand(Hand hand) {
        ItemStack itemstack = this.getHeldItem(hand);

        if (!itemstack.isEmpty() && !this.isHandActive()) {
            super.setActiveHand(hand);
            this.handActive = true;
            this.activeHand = hand;
        }
    }

    public boolean isHandActive() {
        return this.handActive;
    }

    public void resetActiveHand() {
        super.resetActiveHand();
        this.handActive = false;
    }

    public Hand getActiveHand() {
        return this.activeHand;
    }

    public void notifyDataManagerChange(DataParameter<?> key) {
        super.notifyDataManagerChange(key);

        if (LIVING_FLAGS.equals(key)) {
            boolean flag = (this.dataManager.get(LIVING_FLAGS) & 1) > 0;
            Hand hand = (this.dataManager.get(LIVING_FLAGS) & 2) > 0 ? Hand.OFF_HAND : Hand.MAIN_HAND;

            if (flag && !this.handActive) {
                this.setActiveHand(hand);
            } else if (!flag && this.handActive) {
                this.resetActiveHand();
            }
        }

        if (FLAGS.equals(key) && this.isElytraFlying() && !this.wasFallFlying) {
            EventManager.call(new StartFallFlyingEvent());
            this.mc.getSoundHandler().play(new ElytraSound(this));
        }
    }

    public boolean isRidingHorse() {
        Entity entity = this.getRidingEntity();
        return this.isPassenger() && entity instanceof IJumpingMount && ((IJumpingMount) entity).canJump();
    }

    public float getHorseJumpPower() {
        return this.horseJumpPower;
    }

    public void openSignEditor(SignTileEntity signTile) {
        this.mc.displayGuiScreen(new EditSignScreen(signTile));
    }

    public void openMinecartCommandBlock(CommandBlockLogic commandBlock) {
        this.mc.displayGuiScreen(new EditMinecartCommandBlockScreen(commandBlock));
    }

    public void openCommandBlock(CommandBlockTileEntity commandBlock) {
        this.mc.displayGuiScreen(new CommandBlockScreen(commandBlock));
    }

    public void openStructureBlock(StructureBlockTileEntity structure) {
        this.mc.displayGuiScreen(new EditStructureScreen(structure));
    }

    public void openJigsaw(JigsawTileEntity p_213826_1_) {
        this.mc.displayGuiScreen(new JigsawScreen(p_213826_1_));
    }

    public void openBook(ItemStack stack, Hand hand) {
        Item item = stack.getItem();

        if (item == Items.WRITABLE_BOOK) {
            this.mc.displayGuiScreen(new EditBookScreen(this, stack, hand));
        }
    }

    /**
     * Called when the entity is dealt a critical hit.
     */
    public void onCriticalHit(Entity entityHit) {
        this.mc.particles.addParticleEmitter(entityHit, ParticleTypes.CRIT);
    }

    public void onEnchantmentCritical(Entity entityHit) {
        this.mc.particles.addParticleEmitter(entityHit, ParticleTypes.ENCHANTED_HIT);
    }

    public boolean isSneaking() {
        return this.movementInput != null && this.movementInput.sneaking;
    }

    public boolean isCrouching() {
        return this.isCrouching;
    }

    public boolean isForcedDown() {
        return this.isCrouching() || this.isVisuallySwimming();
    }

    public void updateEntityActionState() {
        super.updateEntityActionState();

        if (this.isCurrentViewEntity() || movementInput instanceof PlayerMovementInput) {
            this.moveStrafing = this.movementInput.moveStrafe;
            this.moveForward = this.movementInput.moveForward;
            this.isJumping = this.movementInput.jump;
            this.prevRenderArmYaw = this.renderArmYaw;
            this.prevRenderArmPitch = this.renderArmPitch;
            this.renderArmPitch = (float) ((double) this.renderArmPitch + (double) (this.rotationPitch - this.renderArmPitch) * 0.5D);
            this.renderArmYaw = (float) ((double) this.renderArmYaw + (double) (this.rotationYaw - this.renderArmYaw) * 0.5D);
        }
    }

    protected boolean isCurrentViewEntity() {
        return this.mc.getRenderViewEntity() == this;
    }

    /**
     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
     * use this to react to sunlight and start to burn.
     */
    public void livingTick() {
        ++this.sprintingTicksLeft;

        if (this.sprintToggleTimer > 0) {
            --this.sprintToggleTimer;
        }

        this.handlePortalTeleportation();
        boolean flag = this.movementInput.jump;
        boolean flag1 = this.movementInput.sneaking;
        boolean flag2 = this.isUsingSwimmingAnimation();
        this.isCrouching = !this.abilities.isFlying && !this.isSwimming() && this.isPoseClear(Pose.CROUCHING) && (this.isSneaking() || !this.isSleeping() && !this.isPoseClear(Pose.STANDING));

        EventLivingTick e = new EventLivingTick(isCrouching);
        EventManager.call(e);
        this.isCrouching = e.isCrouch;

        this.movementInput.tickMovement(this.isForcedDown());
        this.mc.getTutorial().handleMovement(this.movementInput);

        if (this.isHandActive() && !this.isPassenger()) {
            EventNoSlow noSlowEvent = new EventNoSlow();
            EventManager.call(noSlowEvent);
            if (!noSlowEvent.isCancel()) {
                this.movementInput.moveStrafe *= 0.2F;
                this.movementInput.moveForward *= 0.2F;
            }
            this.sprintToggleTimer = 0;
        }

        boolean flag3 = false;

        if (this.autoJumpTime > 0) {
            --this.autoJumpTime;
            flag3 = true;
            this.movementInput.jump = true;
        }

        if (!this.noClip) {
            this.setPlayerOffsetMotion(this.getPosX() - (double) this.getWidth() * 0.35D, this.getPosZ() + (double) this.getWidth() * 0.35D);
            this.setPlayerOffsetMotion(this.getPosX() - (double) this.getWidth() * 0.35D, this.getPosZ() - (double) this.getWidth() * 0.35D);
            this.setPlayerOffsetMotion(this.getPosX() + (double) this.getWidth() * 0.35D, this.getPosZ() - (double) this.getWidth() * 0.35D);
            this.setPlayerOffsetMotion(this.getPosX() + (double) this.getWidth() * 0.35D, this.getPosZ() + (double) this.getWidth() * 0.35D);
        }

        if (flag1) {
            this.sprintToggleTimer = 0;
        }


        boolean flag4 = (float) this.getFoodStats().getFoodLevel() > 6.0F || this.abilities.allowFlying;

        if ((this.onGround || this.canSwim()) && !flag1 && !flag2 && this.isUsingSwimmingAnimation() && !this.isSprinting() && flag4 && !this.isHandActive() && !this.isPotionActive(Effects.BLINDNESS)) {
            if (this.sprintToggleTimer <= 0 && !this.mc.gameSettings.keyBindSprint.isKeyDown()) {
                this.sprintToggleTimer = 7;
            } else {
                this.setSprinting(true);
            }
        }

        boolean sprinting;

        sprinting = this.mc.gameSettings.keyBindSprint.isKeyDown();

        if (!this.isSprinting() && (!this.isInWater() || this.canSwim()) && this.isUsingSwimmingAnimation() && flag4 && !this.isHandActive() && !this.isPotionActive(Effects.BLINDNESS) && sprinting) {
            this.setSprinting(true);
        }

        if (this.isSprinting()) {
            boolean flag5 = !this.movementInput.isMovingForward() || !flag4;
            boolean flag6 = flag5 || this.collidedHorizontally || this.isInWater() && !this.canSwim();

            if (this.isSwimming()) {
                if (!this.onGround && !this.movementInput.sneaking && flag5 || !this.isInWater()) {
                    this.setSprinting(false);
                }
            } else if (flag6) {
                this.setSprinting(false);
            }
        }

        boolean flag7 = false;

        if (this.abilities.allowFlying) {
            if (this.mc.playerController.isSpectatorMode()) {
                if (!this.abilities.isFlying) {
                    this.abilities.isFlying = true;
                    flag7 = true;
                    this.sendPlayerAbilities();
                }
            } else if (!flag && this.movementInput.jump && !flag3) {
                if (this.flyToggleTimer == 0) {
                    this.flyToggleTimer = 7;
                } else if (!this.isSwimming()) {
                    this.abilities.isFlying = !this.abilities.isFlying;
                    flag7 = true;
                    this.sendPlayerAbilities();
                    this.flyToggleTimer = 0;
                }
            }
        }

        if (this.movementInput.jump && !flag7 && !flag && !this.abilities.isFlying && !this.isPassenger() && !this.isOnLadder()) {
            ItemStack itemstack = this.getItemStackFromSlot(EquipmentSlotType.CHEST);

            if (itemstack.getItem() == Items.ELYTRA && ElytraItem.isUsable(itemstack) && this.tryToStartFallFlying()) {
                this.connection.sendPacket(new CEntityActionPacket(this, CEntityActionPacket.Action.START_FALL_FLYING));
            }
        }

        this.wasFallFlying = this.isElytraFlying();

        if (this.isInWater() && this.movementInput.sneaking && this.func_241208_cS_()) {
            this.handleFluidSneak();
        }

        if (this.areEyesInFluid(FluidTags.WATER)) {
            int i = this.isSpectator() ? 10 : 1;
            this.counterInWater = MathHelper.clamp(this.counterInWater + i, 0, 600);
        } else if (this.counterInWater > 0) {
            this.areEyesInFluid(FluidTags.WATER);
            this.counterInWater = MathHelper.clamp(this.counterInWater - 10, 0, 600);
        }

        if (this.abilities.isFlying && this.isCurrentViewEntity()) {
            int j = 0;

            if (this.movementInput.sneaking) {
                --j;
            }

            if (this.movementInput.jump) {
                ++j;
            }

            if (j != 0) {
                this.setMotion(this.getMotion().add(0.0D, (double) ((float) j * this.abilities.getFlySpeed() * 3.0F), 0.0D));
            }
        }

        if (this.isRidingHorse()) {
            IJumpingMount ijumpingmount = (IJumpingMount) this.getRidingEntity();

            if (this.horseJumpPowerCounter < 0) {
                ++this.horseJumpPowerCounter;

                if (this.horseJumpPowerCounter == 0) {
                    this.horseJumpPower = 0.0F;
                }
            }

            if (flag && !this.movementInput.jump) {
                this.horseJumpPowerCounter = -10;
                ijumpingmount.setJumpPower(MathHelper.floor(this.getHorseJumpPower() * 100.0F));
                this.sendHorseJump();
            } else if (!flag && this.movementInput.jump) {
                this.horseJumpPowerCounter = 0;
                this.horseJumpPower = 0.0F;
            } else if (flag) {
                ++this.horseJumpPowerCounter;

                if (this.horseJumpPowerCounter < 10) {
                    this.horseJumpPower = (float) this.horseJumpPowerCounter * 0.1F;
                } else {
                    this.horseJumpPower = 0.8F + 2.0F / (float) (this.horseJumpPowerCounter - 9) * 0.1F;
                }
            }
        } else {
            this.horseJumpPower = 0.0F;
        }

        super.livingTick();

        if (this.onGround && this.abilities.isFlying && !this.mc.playerController.isSpectatorMode()) {
            this.abilities.isFlying = false;
            this.sendPlayerAbilities();
        }
    }

    private void handlePortalTeleportation() {
        this.prevTimeInPortal = this.timeInPortal;

        if (this.inPortal) {
            if (this.mc.currentScreen != null && !this.mc.currentScreen.isPauseScreen()) {
                if (this.mc.currentScreen instanceof ContainerScreen) {
                    this.closeScreen();
                }

                this.mc.displayGuiScreen((Screen) null);
            }

            if (this.timeInPortal == 0.0F) {
                this.mc.getSoundHandler().play(SimpleSound.ambientWithoutAttenuation(SoundEvents.BLOCK_PORTAL_TRIGGER, this.rand.nextFloat() * 0.4F + 0.8F, 0.25F));
            }

            this.timeInPortal += 0.0125F;

            if (this.timeInPortal >= 1.0F) {
                this.timeInPortal = 1.0F;
            }

            this.inPortal = false;
        } else if (this.isPotionActive(Effects.NAUSEA) && this.getActivePotionEffect(Effects.NAUSEA).getDuration() > 60) {
            this.timeInPortal += 0.006666667F;

            if (this.timeInPortal > 1.0F) {
                this.timeInPortal = 1.0F;
            }
        } else {
            if (this.timeInPortal > 0.0F) {
                this.timeInPortal -= 0.05F;
            }

            if (this.timeInPortal < 0.0F) {
                this.timeInPortal = 0.0F;
            }
        }

        this.decrementTimeUntilPortal();
    }

    /**
     * Handles updating while riding another entity
     */
    public void updateRidden() {
        super.updateRidden();
        this.rowingBoat = false;

        if (this.getRidingEntity() instanceof BoatEntity) {
            BoatEntity boatentity = (BoatEntity) this.getRidingEntity();
            boatentity.updateInputs(this.movementInput.leftKeyDown, this.movementInput.rightKeyDown, this.movementInput.forwardKeyDown, this.movementInput.backKeyDown);
            this.rowingBoat |= this.movementInput.leftKeyDown || this.movementInput.rightKeyDown || this.movementInput.forwardKeyDown || this.movementInput.backKeyDown;
        }
    }

    public boolean isRowingBoat() {
        return this.rowingBoat;
    }

    @Nullable

    /**
     * Removes the given potion effect from the active potion map and returns it. Does not call cleanup callbacks for
     * the end of the potion effect.
     */
    public EffectInstance removeActivePotionEffect(@Nullable Effect potioneffectin) {
        if (potioneffectin == Effects.NAUSEA) {
            this.prevTimeInPortal = 0.0F;
            this.timeInPortal = 0.0F;
        }

        return super.removeActivePotionEffect(potioneffectin);
    }

    public void move(MoverType typeIn, Vector3d pos) {
        double d0 = this.getPosX();
        double d1 = this.getPosZ();
        super.move(typeIn, pos);
        this.updateAutoJump((float) (this.getPosX() - d0), (float) (this.getPosZ() - d1));
    }

    public boolean isAutoJumpEnabled() {
        return this.autoJumpEnabled;
    }

    protected void updateAutoJump(float movementX, float movementZ) {
        if (this.canAutoJump()) {
            Vector3d vector3d = this.getPositionVec();
            Vector3d vector3d1 = vector3d.add((double) movementX, 0.0D, (double) movementZ);
            Vector3d vector3d2 = new Vector3d((double) movementX, 0.0D, (double) movementZ);
            float f = this.getAIMoveSpeed();
            float f1 = (float) vector3d2.lengthSquared();

            if (f1 <= 0.001F) {
                Vector2f vector2f = this.movementInput.getMoveVector();
                float f2 = f * vector2f.x;
                float f3 = f * vector2f.y;
                float f4 = MathHelper.sin(this.rotationYaw * ((float) Math.PI / 180F));
                float f5 = MathHelper.cos(this.rotationYaw * ((float) Math.PI / 180F));
                vector3d2 = new Vector3d((double) (f2 * f5 - f3 * f4), vector3d2.y, (double) (f3 * f5 + f2 * f4));
                f1 = (float) vector3d2.lengthSquared();

                if (f1 <= 0.001F) {
                    return;
                }
            }

            float f12 = MathHelper.fastInvSqrt(f1);
            Vector3d vector3d12 = vector3d2.scale((double) f12);
            Vector3d vector3d13 = this.getForward();
            float f13 = (float) (vector3d13.x * vector3d12.x + vector3d13.z * vector3d12.z);

            if (!(f13 < -0.15F)) {
                ISelectionContext iselectioncontext = ISelectionContext.forEntity(this);
                BlockPos blockpos = new BlockPos(this.getPosX(), this.getBoundingBox().maxY, this.getPosZ());
                BlockState blockstate = this.world.getBlockState(blockpos);

                if (blockstate.getCollisionShape(this.world, blockpos, iselectioncontext).isEmpty()) {
                    blockpos = blockpos.up();
                    BlockState blockstate1 = this.world.getBlockState(blockpos);

                    if (blockstate1.getCollisionShape(this.world, blockpos, iselectioncontext).isEmpty()) {
                        float f6 = 7.0F;
                        float f7 = 1.2F;

                        if (this.isPotionActive(Effects.JUMP_BOOST)) {
                            f7 += (float) (this.getActivePotionEffect(Effects.JUMP_BOOST).getAmplifier() + 1) * 0.75F;
                        }

                        float f8 = Math.max(f * 7.0F, 1.0F / f12);
                        Vector3d vector3d4 = vector3d1.add(vector3d12.scale((double) f8));
                        float f9 = this.getWidth();
                        float f10 = this.getHeight();
                        AxisAlignedBB axisalignedbb = (new AxisAlignedBB(vector3d, vector3d4.add(0.0D, (double) f10, 0.0D))).grow((double) f9, 0.0D, (double) f9);
                        Vector3d lvt_19_1_ = vector3d.add(0.0D, (double) 0.51F, 0.0D);
                        vector3d4 = vector3d4.add(0.0D, (double) 0.51F, 0.0D);
                        Vector3d vector3d5 = vector3d12.crossProduct(new Vector3d(0.0D, 1.0D, 0.0D));
                        Vector3d vector3d6 = vector3d5.scale((double) (f9 * 0.5F));
                        Vector3d vector3d7 = lvt_19_1_.subtract(vector3d6);
                        Vector3d vector3d8 = vector3d4.subtract(vector3d6);
                        Vector3d vector3d9 = lvt_19_1_.add(vector3d6);
                        Vector3d vector3d10 = vector3d4.add(vector3d6);
                        Iterator<AxisAlignedBB> iterator = this.world.func_234867_d_(this, axisalignedbb, (entity) ->
                        {
                            return true;
                        }).flatMap((shape) ->
                        {
                            return shape.toBoundingBoxList().stream();
                        }).iterator();
                        float f11 = Float.MIN_VALUE;

                        while (iterator.hasNext()) {
                            AxisAlignedBB axisalignedbb1 = iterator.next();

                            if (axisalignedbb1.intersects(vector3d7, vector3d8) || axisalignedbb1.intersects(vector3d9, vector3d10)) {
                                f11 = (float) axisalignedbb1.maxY;
                                Vector3d vector3d11 = axisalignedbb1.getCenter();
                                BlockPos blockpos1 = new BlockPos(vector3d11);

                                for (int i = 1; (float) i < f7; ++i) {
                                    BlockPos blockpos2 = blockpos1.up(i);
                                    BlockState blockstate2 = this.world.getBlockState(blockpos2);
                                    VoxelShape voxelshape;

                                    if (!(voxelshape = blockstate2.getCollisionShape(this.world, blockpos2, iselectioncontext)).isEmpty()) {
                                        f11 = (float) voxelshape.getEnd(Direction.Axis.Y) + (float) blockpos2.getY();

                                        if ((double) f11 - this.getPosY() > (double) f7) {
                                            return;
                                        }
                                    }

                                    if (i > 1) {
                                        blockpos = blockpos.up();
                                        BlockState blockstate3 = this.world.getBlockState(blockpos);

                                        if (!blockstate3.getCollisionShape(this.world, blockpos, iselectioncontext).isEmpty()) {
                                            return;
                                        }
                                    }
                                }

                                break;
                            }
                        }

                        if (f11 != Float.MIN_VALUE) {
                            float f14 = (float) ((double) f11 - this.getPosY());

                            if (!(f14 <= 0.5F) && !(f14 > f7)) {
                                this.autoJumpTime = 1;
                            }
                        }
                    }
                }
            }
        }
    }

    private boolean canAutoJump() {
        return this.isAutoJumpEnabled() && this.autoJumpTime <= 0 && this.onGround && !this.isStayingOnGroundSurface() && !this.isPassenger() && this.isMoving() && (double) this.getJumpFactor() >= 1.0D;
    }

    private boolean isMoving() {
        Vector2f vector2f = this.movementInput.getMoveVector();
        return vector2f.x != 0.0F || vector2f.y != 0.0F;
    }

    private boolean isUsingSwimmingAnimation() {
        double d0 = 0.8D;
        return this.canSwim() ? this.movementInput.isMovingForward() : (double) this.movementInput.moveForward >= 0.8D;
    }

    public float getWaterBrightness() {
        if (!this.areEyesInFluid(FluidTags.WATER)) {
            return 0.0F;
        } else {
            float f = 600.0F;
            float f1 = 100.0F;

            if ((float) this.counterInWater >= 600.0F) {
                return 1.0F;
            } else {
                float f2 = MathHelper.clamp((float) this.counterInWater / 100.0F, 0.0F, 1.0F);
                float f3 = (float) this.counterInWater < 100.0F ? 0.0F : MathHelper.clamp(((float) this.counterInWater - 100.0F) / 500.0F, 0.0F, 1.0F);
                return f2 * 0.6F + f3 * 0.39999998F;
            }
        }
    }

    public boolean canSwim() {
        return this.eyesInWaterPlayer;
    }

    protected boolean updateEyesInWaterPlayer() {
        boolean flag = this.eyesInWaterPlayer;
        boolean flag1 = super.updateEyesInWaterPlayer();

        if (this.isSpectator()) {
            return this.eyesInWaterPlayer;
        } else {
            if (!flag && flag1) {
                this.world.playSound(this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.AMBIENT_UNDERWATER_ENTER, SoundCategory.AMBIENT, 1.0F, 1.0F, false);
                this.mc.getSoundHandler().play(new UnderwaterAmbientSounds.UnderWaterSound(this));
            }

            if (flag && !flag1) {
                this.world.playSound(this.getPosX(), this.getPosY(), this.getPosZ(), SoundEvents.AMBIENT_UNDERWATER_EXIT, SoundCategory.AMBIENT, 1.0F, 1.0F, false);
            }

            return this.eyesInWaterPlayer;
        }
    }

    public Vector3d getLeashPosition(float partialTicks) {
        if (this.mc.gameSettings.getPointOfView().func_243192_a()) {
            float f = MathHelper.lerp(partialTicks * 0.5F, this.rotationYaw, this.prevRotationYaw) * ((float) Math.PI / 180F);
            float f1 = MathHelper.lerp(partialTicks * 0.5F, this.rotationPitch, this.prevRotationPitch) * ((float) Math.PI / 180F);
            double d0 = this.getPrimaryHand() == HandSide.RIGHT ? -1.0D : 1.0D;
            Vector3d vector3d = new Vector3d(0.39D * d0, -0.6D, 0.3D);
            return vector3d.rotatePitch(-f1).rotateYaw(-f).add(this.getEyePosition(partialTicks));
        } else {
            return super.getLeashPosition(partialTicks);
        }
    }

    public float getLastReportedPitch() {
        return lastReportedPitch;
    }
}

AbstractClientPlayerEntity:
package net.minecraft.client.entity.player;

import com.google.common.hash.Hashing;
import com.mojang.authlib.GameProfile;
import java.io.File;
import javax.annotation.Nullable;
import net.minecraft.client.Minecraft;
import net.minecraft.client.network.play.NetworkPlayerInfo;
import net.minecraft.client.renderer.texture.DownloadingTexture;
import net.minecraft.client.renderer.texture.Texture;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.resources.DefaultPlayerSkin;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.ai.attributes.Attributes;
import net.minecraft.entity.passive.ShoulderRidingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.BowItem;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.StringUtils;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.GameType;
import net.optifine.Config;
import net.optifine.player.CapeUtils;
import net.optifine.player.PlayerConfigurations;
import net.optifine.reflect.Reflector;
import wtf.expensive.util.ClientUtil;

public abstract class AbstractClientPlayerEntity extends PlayerEntity
{
    private NetworkPlayerInfo playerInfo;
    public float rotateElytraX;
    public float rotateElytraY;
    public float rotateElytraZ;
    public final ClientWorld worldClient;
    private ResourceLocation locationOfCape = null;
    private long reloadCapeTimeMs = 0L;
    private boolean elytraOfCape = false;
    private String nameClear = null;
    public ShoulderRidingEntity entityShoulderLeft;
    public ShoulderRidingEntity entityShoulderRight;
    public float capeRotateX;
    public float capeRotateY;
    public float capeRotateZ;
    private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");

    public AbstractClientPlayerEntity(ClientWorld world, GameProfile profile)
    {
        super(world, world.func_239140_u_(), world.func_243489_v(), profile);
        this.worldClient = world;
        this.nameClear = profile.getName();

        if (this.nameClear != null && !this.nameClear.isEmpty())
        {
            this.nameClear = StringUtils.stripControlCodes(this.nameClear);
        }

        CapeUtils.downloadCape(this);
        PlayerConfigurations.getPlayerConfiguration(this);
    }

    /**
     * Returns true if the player is in spectator mode.
     */
    public boolean isSpectator()
    {
        NetworkPlayerInfo networkplayerinfo = Minecraft.getInstance().getConnection().getPlayerInfo(this.getGameProfile().getId());
        return networkplayerinfo != null && networkplayerinfo.getGameType() == GameType.SPECTATOR;
    }

    public boolean isCreative()
    {
        NetworkPlayerInfo networkplayerinfo = Minecraft.getInstance().getConnection().getPlayerInfo(this.getGameProfile().getId());
        return networkplayerinfo != null && networkplayerinfo.getGameType() == GameType.CREATIVE;
    }

    /**
     * Checks if this instance of AbstractClientPlayer has any associated player data.
     */
    public boolean hasPlayerInfo()
    {
        return this.getPlayerInfo() != null;
    }

    @Nullable
    protected NetworkPlayerInfo getPlayerInfo()
    {
        if (this.playerInfo == null)
        {
            this.playerInfo = Minecraft.getInstance().getConnection().getPlayerInfo(this.getUniqueID());
        }

        return this.playerInfo;
    }

    /**
     * Returns true if the player has an associated skin.
     */
    public boolean hasSkin()
    {
        NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
        return networkplayerinfo != null && networkplayerinfo.hasLocationSkin();
    }

    /**
     * Returns the ResourceLocation associated with the player's skin
     */
    public ResourceLocation getLocationSkin()
    {
        NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();

        return networkplayerinfo == null ? DefaultPlayerSkin.getDefaultSkin(this.getUniqueID()) : networkplayerinfo.getLocationSkin();
    }

    @Nullable
    public ResourceLocation getLocationCape()
    {

        if (this instanceof ClientPlayerEntity && !ClientUtil.legitMode) {
            return new ResourceLocation("expensive/images/cape.png");
        }

        if (!Config.isShowCapes())
        {
            return null;
        }
        else
        {
            if (this.reloadCapeTimeMs != 0L && System.currentTimeMillis() > this.reloadCapeTimeMs)
            {
                CapeUtils.reloadCape(this);
                this.reloadCapeTimeMs = 0L;
            }

            if (this.locationOfCape != null)
            {
                return this.locationOfCape;
            }
            else
            {
                NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
                return networkplayerinfo == null ? null : networkplayerinfo.getLocationCape();
            }
        }
    }

    public boolean isPlayerInfoSet()
    {
        return this.getPlayerInfo() != null;
    }

    @Nullable

    /**
     * Gets the special Elytra texture for the player.
     */
    public ResourceLocation getLocationElytra()
    {
        NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
        return networkplayerinfo == null ? null : networkplayerinfo.getLocationElytra();
    }

    public static DownloadingTexture getDownloadImageSkin(ResourceLocation resourceLocationIn, String username)
    {
        TextureManager texturemanager = Minecraft.getInstance().getTextureManager();
        Texture texture = texturemanager.getTexture(resourceLocationIn);

        if (texture == null)
        {
            texture = new DownloadingTexture((File)null, String.format("https://minotar.net/avatar/%s/64.png", StringUtils.stripControlCodes(username)), DefaultPlayerSkin.getDefaultSkin(getOfflineUUID(username)), true, (Runnable)null);
            texturemanager.loadTexture(resourceLocationIn, texture);
        }

        return (DownloadingTexture)texture;
    }

    public static DownloadingTexture getDownloadImageSkin(String username)
    {
        TextureManager texturemanager = Minecraft.getInstance().getTextureManager();
        ResourceLocation res = getLocationSkin(username);
        Texture texture = texturemanager.getTexture(res);

        if (texture == null)
        {
            texture = new DownloadingTexture((File)null, String.format("https://minotar.net/avatar/%s/64.png", StringUtils.stripControlCodes(username)), DefaultPlayerSkin.getDefaultSkin(getOfflineUUID(username)), true, (Runnable)null);
            texturemanager.loadTexture(res, texture);
        }

        return (DownloadingTexture)texture;
    }

    /**
     * Returns true if the username has an associated skin.
     */
    public static ResourceLocation getLocationSkin(String username)
    {
        return new ResourceLocation("skins/" + Hashing.sha1().hashUnencodedChars(StringUtils.stripControlCodes(username)));
    }

    public String getSkinType()
    {
        NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
        return networkplayerinfo == null ? DefaultPlayerSkin.getSkinType(this.getUniqueID()) : networkplayerinfo.getSkinType();
    }

    public float getFovModifier()
    {
        float f = 1.0F;

        if (this.abilities.isFlying)
        {
            f *= 1.1F;
        }

        f = (float)((double)f * ((this.getAttributeValue(Attributes.MOVEMENT_SPEED) / (double)this.abilities.getWalkSpeed() + 1.0D) / 2.0D));

        if (this.abilities.getWalkSpeed() == 0.0F || Float.isNaN(f) || Float.isInfinite(f))
        {
            f = 1.0F;
        }

        if (this.isHandActive() && this.getActiveItemStack().getItem() instanceof BowItem)
        {
            int i = this.getItemInUseMaxCount();
            float f1 = (float)i / 20.0F;

            if (f1 > 1.0F)
            {
                f1 = 1.0F;
            }
            else
            {
                f1 = f1 * f1;
            }

            f *= 1.0F - f1 * 0.15F;
        }

        return Reflector.ForgeHooksClient_getOffsetFOV.exists() ? Reflector.callFloat(Reflector.ForgeHooksClient_getOffsetFOV, this, f) : MathHelper.lerp(Minecraft.getInstance().gameSettings.fovScaleEffect, 1.0F, f);
    }

    public String getNameClear()
    {
        return this.nameClear;
    }

    public ResourceLocation getLocationOfCape()
    {
        return this.locationOfCape;
    }

    public void setLocationOfCape(ResourceLocation p_setLocationOfCape_1_)
    {
        this.locationOfCape = p_setLocationOfCape_1_;
    }

    public boolean hasElytraCape()
    {
        ResourceLocation resourcelocation = this.getLocationCape();

        if (resourcelocation == null)
        {
            return false;
        }
        else
        {
            return resourcelocation == this.locationOfCape ? this.elytraOfCape : true;
        }
    }

    public void setElytraOfCape(boolean p_setElytraOfCape_1_)
    {
        this.elytraOfCape = p_setElytraOfCape_1_;
    }

    public boolean isElytraOfCape()
    {
        return this.elytraOfCape;
    }

    public long getReloadCapeTimeMs()
    {
        return this.reloadCapeTimeMs;
    }

    public void setReloadCapeTimeMs(long p_setReloadCapeTimeMs_1_)
    {
        this.reloadCapeTimeMs = p_setReloadCapeTimeMs_1_;
    }
}

Items:
package net.minecraft.item;

import net.minecraft.block.Block;
import net.minecraft.block.Blocks;
import net.minecraft.entity.EntityType;
import net.minecraft.entity.item.BoatEntity;
import net.minecraft.entity.item.minecart.AbstractMinecartEntity;
import net.minecraft.fluid.Fluids;
import net.minecraft.inventory.EquipmentSlotType;
import net.minecraft.tileentity.BannerPattern;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.SoundEvents;
import net.minecraft.util.registry.Registry;

public class Items
{
    public static final Item AIR = register(Blocks.AIR, new AirItem(Blocks.AIR, new Item.Properties()));
    public static final Item STONE = register(Blocks.STONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRANITE = register(Blocks.GRANITE, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_GRANITE = register(Blocks.POLISHED_GRANITE, ItemGroup.BUILDING_BLOCKS);
    public static final Item DIORITE = register(Blocks.DIORITE, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_DIORITE = register(Blocks.POLISHED_DIORITE, ItemGroup.BUILDING_BLOCKS);
    public static final Item ANDESITE = register(Blocks.ANDESITE, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_ANDESITE = register(Blocks.POLISHED_ANDESITE, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRASS_BLOCK = register(Blocks.GRASS_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item DIRT = register(Blocks.DIRT, ItemGroup.BUILDING_BLOCKS);
    public static final Item COARSE_DIRT = register(Blocks.COARSE_DIRT, ItemGroup.BUILDING_BLOCKS);
    public static final Item PODZOL = register(Blocks.PODZOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRIMSON_NYLIUM = register(Blocks.CRIMSON_NYLIUM, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_NYLIUM = register(Blocks.WARPED_NYLIUM, ItemGroup.BUILDING_BLOCKS);
    public static final Item COBBLESTONE = register(Blocks.COBBLESTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_PLANKS = register(Blocks.OAK_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SPRUCE_PLANKS = register(Blocks.SPRUCE_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BIRCH_PLANKS = register(Blocks.BIRCH_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item JUNGLE_PLANKS = register(Blocks.JUNGLE_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item ACACIA_PLANKS = register(Blocks.ACACIA_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_OAK_PLANKS = register(Blocks.DARK_OAK_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRIMSON_PLANKS = register(Blocks.CRIMSON_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_PLANKS = register(Blocks.WARPED_PLANKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_SAPLING = register(Blocks.OAK_SAPLING, ItemGroup.DECORATIONS);
    public static final Item SPRUCE_SAPLING = register(Blocks.SPRUCE_SAPLING, ItemGroup.DECORATIONS);
    public static final Item BIRCH_SAPLING = register(Blocks.BIRCH_SAPLING, ItemGroup.DECORATIONS);
    public static final Item JUNGLE_SAPLING = register(Blocks.JUNGLE_SAPLING, ItemGroup.DECORATIONS);
    public static final Item ACACIA_SAPLING = register(Blocks.ACACIA_SAPLING, ItemGroup.DECORATIONS);
    public static final Item DARK_OAK_SAPLING = register(Blocks.DARK_OAK_SAPLING, ItemGroup.DECORATIONS);
    public static final Item BEDROCK = register(Blocks.BEDROCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item SAND = register(Blocks.SAND, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_SAND = register(Blocks.RED_SAND, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRAVEL = register(Blocks.GRAVEL, ItemGroup.BUILDING_BLOCKS);
    public static final Item GOLD_ORE = register(Blocks.GOLD_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item IRON_ORE = register(Blocks.IRON_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item COAL_ORE = register(Blocks.COAL_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item NETHER_GOLD_ORE = register(Blocks.NETHER_GOLD_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_LOG = register(Blocks.OAK_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item SPRUCE_LOG = register(Blocks.SPRUCE_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item BIRCH_LOG = register(Blocks.BIRCH_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item JUNGLE_LOG = register(Blocks.JUNGLE_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item ACACIA_LOG = register(Blocks.ACACIA_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_OAK_LOG = register(Blocks.DARK_OAK_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRIMSON_STEM = register(Blocks.CRIMSON_STEM, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_STEM = register(Blocks.WARPED_STEM, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_OAK_LOG = register(Blocks.STRIPPED_OAK_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_SPRUCE_LOG = register(Blocks.STRIPPED_SPRUCE_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_BIRCH_LOG = register(Blocks.STRIPPED_BIRCH_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_JUNGLE_LOG = register(Blocks.STRIPPED_JUNGLE_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_ACACIA_LOG = register(Blocks.STRIPPED_ACACIA_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_DARK_OAK_LOG = register(Blocks.STRIPPED_DARK_OAK_LOG, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_CRIMSON_STEM = register(Blocks.STRIPPED_CRIMSON_STEM, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_WARPED_STEM = register(Blocks.STRIPPED_WARPED_STEM, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_OAK_WOOD = register(Blocks.STRIPPED_OAK_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_SPRUCE_WOOD = register(Blocks.STRIPPED_SPRUCE_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_BIRCH_WOOD = register(Blocks.STRIPPED_BIRCH_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_JUNGLE_WOOD = register(Blocks.STRIPPED_JUNGLE_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_ACACIA_WOOD = register(Blocks.STRIPPED_ACACIA_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_DARK_OAK_WOOD = register(Blocks.STRIPPED_DARK_OAK_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_CRIMSON_HYPHAE = register(Blocks.STRIPPED_CRIMSON_HYPHAE, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRIPPED_WARPED_HYPHAE = register(Blocks.STRIPPED_WARPED_HYPHAE, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_WOOD = register(Blocks.OAK_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item SPRUCE_WOOD = register(Blocks.SPRUCE_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item BIRCH_WOOD = register(Blocks.BIRCH_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item JUNGLE_WOOD = register(Blocks.JUNGLE_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item ACACIA_WOOD = register(Blocks.ACACIA_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_OAK_WOOD = register(Blocks.DARK_OAK_WOOD, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRIMSON_HYPHAE = register(Blocks.CRIMSON_HYPHAE, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_HYPHAE = register(Blocks.WARPED_HYPHAE, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_LEAVES = register(Blocks.OAK_LEAVES, ItemGroup.DECORATIONS);
    public static final Item SPRUCE_LEAVES = register(Blocks.SPRUCE_LEAVES, ItemGroup.DECORATIONS);
    public static final Item BIRCH_LEAVES = register(Blocks.BIRCH_LEAVES, ItemGroup.DECORATIONS);
    public static final Item JUNGLE_LEAVES = register(Blocks.JUNGLE_LEAVES, ItemGroup.DECORATIONS);
    public static final Item ACACIA_LEAVES = register(Blocks.ACACIA_LEAVES, ItemGroup.DECORATIONS);
    public static final Item DARK_OAK_LEAVES = register(Blocks.DARK_OAK_LEAVES, ItemGroup.DECORATIONS);
    public static final Item SPONGE = register(Blocks.SPONGE, ItemGroup.BUILDING_BLOCKS);
    public static final Item WET_SPONGE = register(Blocks.WET_SPONGE, ItemGroup.BUILDING_BLOCKS);
    public static final Item GLASS = register(Blocks.GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item LAPIS_ORE = register(Blocks.LAPIS_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item LAPIS_BLOCK = register(Blocks.LAPIS_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item DISPENSER = register(Blocks.DISPENSER, ItemGroup.REDSTONE);
    public static final Item SANDSTONE = register(Blocks.SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item CHISELED_SANDSTONE = register(Blocks.CHISELED_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item CUT_SANDSTONE = register(Blocks.CUT_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item NOTE_BLOCK = register(Blocks.NOTE_BLOCK, ItemGroup.REDSTONE);
    public static final Item POWERED_RAIL = register(Blocks.POWERED_RAIL, ItemGroup.TRANSPORTATION);
    public static final Item DETECTOR_RAIL = register(Blocks.DETECTOR_RAIL, ItemGroup.TRANSPORTATION);
    public static final Item STICKY_PISTON = register(Blocks.STICKY_PISTON, ItemGroup.REDSTONE);
    public static final Item COBWEB = register(Blocks.COBWEB, ItemGroup.DECORATIONS);
    public static final Item GRASS = register(Blocks.GRASS, ItemGroup.DECORATIONS);
    public static final Item FERN = register(Blocks.FERN, ItemGroup.DECORATIONS);
    public static final Item DEAD_BUSH = register(Blocks.DEAD_BUSH, ItemGroup.DECORATIONS);
    public static final Item SEAGRASS = register(Blocks.SEAGRASS, ItemGroup.DECORATIONS);
    public static final Item SEA_PICKLE = register(Blocks.SEA_PICKLE, ItemGroup.DECORATIONS);
    public static final Item PISTON = register(Blocks.PISTON, ItemGroup.REDSTONE);
    public static final Item WHITE_WOOL = register(Blocks.WHITE_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item ORANGE_WOOL = register(Blocks.ORANGE_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item MAGENTA_WOOL = register(Blocks.MAGENTA_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_BLUE_WOOL = register(Blocks.LIGHT_BLUE_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item YELLOW_WOOL = register(Blocks.YELLOW_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIME_WOOL = register(Blocks.LIME_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item PINK_WOOL = register(Blocks.PINK_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRAY_WOOL = register(Blocks.GRAY_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_GRAY_WOOL = register(Blocks.LIGHT_GRAY_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item CYAN_WOOL = register(Blocks.CYAN_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPLE_WOOL = register(Blocks.PURPLE_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLUE_WOOL = register(Blocks.BLUE_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item BROWN_WOOL = register(Blocks.BROWN_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item GREEN_WOOL = register(Blocks.GREEN_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_WOOL = register(Blocks.RED_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACK_WOOL = register(Blocks.BLACK_WOOL, ItemGroup.BUILDING_BLOCKS);
    public static final Item DANDELION = register(Blocks.DANDELION, ItemGroup.DECORATIONS);
    public static final Item POPPY = register(Blocks.POPPY, ItemGroup.DECORATIONS);
    public static final Item BLUE_ORCHID = register(Blocks.BLUE_ORCHID, ItemGroup.DECORATIONS);
    public static final Item ALLIUM = register(Blocks.ALLIUM, ItemGroup.DECORATIONS);
    public static final Item AZURE_BLUET = register(Blocks.AZURE_BLUET, ItemGroup.DECORATIONS);
    public static final Item RED_TULIP = register(Blocks.RED_TULIP, ItemGroup.DECORATIONS);
    public static final Item ORANGE_TULIP = register(Blocks.ORANGE_TULIP, ItemGroup.DECORATIONS);
    public static final Item WHITE_TULIP = register(Blocks.WHITE_TULIP, ItemGroup.DECORATIONS);
    public static final Item PINK_TULIP = register(Blocks.PINK_TULIP, ItemGroup.DECORATIONS);
    public static final Item OXEYE_DAISY = register(Blocks.OXEYE_DAISY, ItemGroup.DECORATIONS);
    public static final Item CORNFLOWER = register(Blocks.CORNFLOWER, ItemGroup.DECORATIONS);
    public static final Item LILY_OF_THE_VALLEY = register(Blocks.LILY_OF_THE_VALLEY, ItemGroup.DECORATIONS);
    public static final Item WITHER_ROSE = register(Blocks.WITHER_ROSE, ItemGroup.DECORATIONS);
    public static final Item BROWN_MUSHROOM = register(Blocks.BROWN_MUSHROOM, ItemGroup.DECORATIONS);
    public static final Item RED_MUSHROOM = register(Blocks.RED_MUSHROOM, ItemGroup.DECORATIONS);
    public static final Item CRIMSON_FUNGUS = register(Blocks.CRIMSON_FUNGUS, ItemGroup.DECORATIONS);
    public static final Item WARPED_FUNGUS = register(Blocks.WARPED_FUNGUS, ItemGroup.DECORATIONS);
    public static final Item CRIMSON_ROOTS = register(Blocks.CRIMSON_ROOTS, ItemGroup.DECORATIONS);
    public static final Item WARPED_ROOTS = register(Blocks.WARPED_ROOTS, ItemGroup.DECORATIONS);
    public static final Item NETHER_SPROUTS = register(Blocks.NETHER_SPROUTS, ItemGroup.DECORATIONS);
    public static final Item WEEPING_VINES = register(Blocks.WEEPING_VINES, ItemGroup.DECORATIONS);
    public static final Item TWISTING_VINES = register(Blocks.TWISTING_VINES, ItemGroup.DECORATIONS);
    public static final Item SUGAR_CANE = register(Blocks.SUGAR_CANE, ItemGroup.DECORATIONS);
    public static final Item KELP = register(Blocks.KELP, ItemGroup.DECORATIONS);
    public static final Item BAMBOO = register(Blocks.BAMBOO, ItemGroup.DECORATIONS);
    public static final Item GOLD_BLOCK = register(Blocks.GOLD_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item IRON_BLOCK = register(Blocks.IRON_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_SLAB = register(Blocks.OAK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SPRUCE_SLAB = register(Blocks.SPRUCE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item BIRCH_SLAB = register(Blocks.BIRCH_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item JUNGLE_SLAB = register(Blocks.JUNGLE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item ACACIA_SLAB = register(Blocks.ACACIA_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_OAK_SLAB = register(Blocks.DARK_OAK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRIMSON_SLAB = register(Blocks.CRIMSON_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_SLAB = register(Blocks.WARPED_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item STONE_SLAB = register(Blocks.STONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_STONE_SLAB = register(Blocks.SMOOTH_STONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SANDSTONE_SLAB = register(Blocks.SANDSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item CUT_SANDSTONE_SLAB = register(Blocks.CUT_SANDSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item PETRIFIED_OAK_SLAB = register(Blocks.PETRIFIED_OAK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item COBBLESTONE_SLAB = register(Blocks.COBBLESTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item BRICK_SLAB = register(Blocks.BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item STONE_BRICK_SLAB = register(Blocks.STONE_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item NETHER_BRICK_SLAB = register(Blocks.NETHER_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item QUARTZ_SLAB = register(Blocks.QUARTZ_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_SANDSTONE_SLAB = register(Blocks.RED_SANDSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item CUT_RED_SANDSTONE_SLAB = register(Blocks.CUT_RED_SANDSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPUR_SLAB = register(Blocks.PURPUR_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item PRISMARINE_SLAB = register(Blocks.PRISMARINE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item PRISMARINE_BRICK_SLAB = register(Blocks.PRISMARINE_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_PRISMARINE_SLAB = register(Blocks.DARK_PRISMARINE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_QUARTZ = register(Blocks.SMOOTH_QUARTZ, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_RED_SANDSTONE = register(Blocks.SMOOTH_RED_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_SANDSTONE = register(Blocks.SMOOTH_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_STONE = register(Blocks.SMOOTH_STONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item BRICKS = register(Blocks.BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item TNT = register(Blocks.TNT, ItemGroup.REDSTONE);
    public static final Item BOOKSHELF = register(Blocks.BOOKSHELF, ItemGroup.BUILDING_BLOCKS);
    public static final Item MOSSY_COBBLESTONE = register(Blocks.MOSSY_COBBLESTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item OBSIDIAN = register(Blocks.OBSIDIAN, ItemGroup.BUILDING_BLOCKS);
    public static final Item TORCH = register(new WallOrFloorItem(Blocks.TORCH, Blocks.WALL_TORCH, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item END_ROD = register(Blocks.END_ROD, ItemGroup.DECORATIONS);
    public static final Item CHORUS_PLANT = register(Blocks.CHORUS_PLANT, ItemGroup.DECORATIONS);
    public static final Item CHORUS_FLOWER = register(Blocks.CHORUS_FLOWER, ItemGroup.DECORATIONS);
    public static final Item PURPUR_BLOCK = register(Blocks.PURPUR_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPUR_PILLAR = register(Blocks.PURPUR_PILLAR, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPUR_STAIRS = register(Blocks.PURPUR_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SPAWNER = register(Blocks.SPAWNER);
    public static final Item OAK_STAIRS = register(Blocks.OAK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CHEST = register(Blocks.CHEST, ItemGroup.DECORATIONS);
    public static final Item DIAMOND_ORE = register(Blocks.DIAMOND_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item DIAMOND_BLOCK = register(Blocks.DIAMOND_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRAFTING_TABLE = register(Blocks.CRAFTING_TABLE, ItemGroup.DECORATIONS);
    public static final Item FARMLAND = register(Blocks.FARMLAND, ItemGroup.DECORATIONS);
    public static final Item FURNACE = register(Blocks.FURNACE, ItemGroup.DECORATIONS);
    public static final Item LADDER = register(Blocks.LADDER, ItemGroup.DECORATIONS);
    public static final Item RAIL = register(Blocks.RAIL, ItemGroup.TRANSPORTATION);
    public static final Item COBBLESTONE_STAIRS = register(Blocks.COBBLESTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item LEVER = register(Blocks.LEVER, ItemGroup.REDSTONE);
    public static final Item STONE_PRESSURE_PLATE = register(Blocks.STONE_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item OAK_PRESSURE_PLATE = register(Blocks.OAK_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item SPRUCE_PRESSURE_PLATE = register(Blocks.SPRUCE_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item BIRCH_PRESSURE_PLATE = register(Blocks.BIRCH_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item JUNGLE_PRESSURE_PLATE = register(Blocks.JUNGLE_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item ACACIA_PRESSURE_PLATE = register(Blocks.ACACIA_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item DARK_OAK_PRESSURE_PLATE = register(Blocks.DARK_OAK_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item CRIMSON_PRESSURE_PLATE = register(Blocks.CRIMSON_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item WARPED_PRESSURE_PLATE = register(Blocks.WARPED_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item POLISHED_BLACKSTONE_PRESSURE_PLATE = register(Blocks.POLISHED_BLACKSTONE_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item REDSTONE_ORE = register(Blocks.REDSTONE_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item REDSTONE_TORCH = register(new WallOrFloorItem(Blocks.REDSTONE_TORCH, Blocks.REDSTONE_WALL_TORCH, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item SNOW = register(Blocks.SNOW, ItemGroup.DECORATIONS);
    public static final Item ICE = register(Blocks.ICE, ItemGroup.BUILDING_BLOCKS);
    public static final Item SNOW_BLOCK = register(Blocks.SNOW_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item CACTUS = register(Blocks.CACTUS, ItemGroup.DECORATIONS);
    public static final Item CLAY = register(Blocks.CLAY, ItemGroup.BUILDING_BLOCKS);
    public static final Item JUKEBOX = register(Blocks.JUKEBOX, ItemGroup.DECORATIONS);
    public static final Item OAK_FENCE = register(Blocks.OAK_FENCE, ItemGroup.DECORATIONS);
    public static final Item SPRUCE_FENCE = register(Blocks.SPRUCE_FENCE, ItemGroup.DECORATIONS);
    public static final Item BIRCH_FENCE = register(Blocks.BIRCH_FENCE, ItemGroup.DECORATIONS);
    public static final Item JUNGLE_FENCE = register(Blocks.JUNGLE_FENCE, ItemGroup.DECORATIONS);
    public static final Item ACACIA_FENCE = register(Blocks.ACACIA_FENCE, ItemGroup.DECORATIONS);
    public static final Item DARK_OAK_FENCE = register(Blocks.DARK_OAK_FENCE, ItemGroup.DECORATIONS);
    public static final Item CRIMSON_FENCE = register(Blocks.CRIMSON_FENCE, ItemGroup.DECORATIONS);
    public static final Item WARPED_FENCE = register(Blocks.WARPED_FENCE, ItemGroup.DECORATIONS);
    public static final Item PUMPKIN = register(Blocks.PUMPKIN, ItemGroup.BUILDING_BLOCKS);
    public static final Item CARVED_PUMPKIN = register(Blocks.CARVED_PUMPKIN, ItemGroup.BUILDING_BLOCKS);
    public static final Item NETHERRACK = register(Blocks.NETHERRACK, ItemGroup.BUILDING_BLOCKS);
    public static final Item SOUL_SAND = register(Blocks.SOUL_SAND, ItemGroup.BUILDING_BLOCKS);
    public static final Item SOUL_SOIL = register(Blocks.SOUL_SOIL, ItemGroup.BUILDING_BLOCKS);
    public static final Item BASALT = register(Blocks.BASALT, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BASALT = register(Blocks.POLISHED_BASALT, ItemGroup.BUILDING_BLOCKS);
    public static final Item SOUL_TORCH = register(new WallOrFloorItem(Blocks.SOUL_TORCH, Blocks.SOUL_WALL_TORCH, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item GLOWSTONE = register(Blocks.GLOWSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item JACK_O_LANTERN = register(Blocks.JACK_O_LANTERN, ItemGroup.BUILDING_BLOCKS);
    public static final Item OAK_TRAPDOOR = register(Blocks.OAK_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item SPRUCE_TRAPDOOR = register(Blocks.SPRUCE_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item BIRCH_TRAPDOOR = register(Blocks.BIRCH_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item JUNGLE_TRAPDOOR = register(Blocks.JUNGLE_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item ACACIA_TRAPDOOR = register(Blocks.ACACIA_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item DARK_OAK_TRAPDOOR = register(Blocks.DARK_OAK_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item CRIMSON_TRAPDOOR = register(Blocks.CRIMSON_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item WARPED_TRAPDOOR = register(Blocks.WARPED_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item INFESTED_STONE = register(Blocks.INFESTED_STONE, ItemGroup.DECORATIONS);
    public static final Item INFESTED_COBBLESTONE = register(Blocks.INFESTED_COBBLESTONE, ItemGroup.DECORATIONS);
    public static final Item INFESTED_STONE_BRICKS = register(Blocks.INFESTED_STONE_BRICKS, ItemGroup.DECORATIONS);
    public static final Item INFESTED_MOSSY_STONE_BRICKS = register(Blocks.INFESTED_MOSSY_STONE_BRICKS, ItemGroup.DECORATIONS);
    public static final Item INFESTED_CRACKED_STONE_BRICKS = register(Blocks.INFESTED_CRACKED_STONE_BRICKS, ItemGroup.DECORATIONS);
    public static final Item INFESTED_CHISELED_STONE_BRICKS = register(Blocks.INFESTED_CHISELED_STONE_BRICKS, ItemGroup.DECORATIONS);
    public static final Item STONE_BRICKS = register(Blocks.STONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item MOSSY_STONE_BRICKS = register(Blocks.MOSSY_STONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRACKED_STONE_BRICKS = register(Blocks.CRACKED_STONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CHISELED_STONE_BRICKS = register(Blocks.CHISELED_STONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BROWN_MUSHROOM_BLOCK = register(Blocks.BROWN_MUSHROOM_BLOCK, ItemGroup.DECORATIONS);
    public static final Item RED_MUSHROOM_BLOCK = register(Blocks.RED_MUSHROOM_BLOCK, ItemGroup.DECORATIONS);
    public static final Item MUSHROOM_STEM = register(Blocks.MUSHROOM_STEM, ItemGroup.DECORATIONS);
    public static final Item IRON_BARS = register(Blocks.IRON_BARS, ItemGroup.DECORATIONS);
    public static final Item CHAIN = register(Blocks.CHAIN, ItemGroup.DECORATIONS);
    public static final Item GLASS_PANE = register(Blocks.GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item MELON = register(Blocks.MELON, ItemGroup.BUILDING_BLOCKS);
    public static final Item VINE = register(Blocks.VINE, ItemGroup.DECORATIONS);
    public static final Item OAK_FENCE_GATE = register(Blocks.OAK_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item SPRUCE_FENCE_GATE = register(Blocks.SPRUCE_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item BIRCH_FENCE_GATE = register(Blocks.BIRCH_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item JUNGLE_FENCE_GATE = register(Blocks.JUNGLE_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item ACACIA_FENCE_GATE = register(Blocks.ACACIA_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item DARK_OAK_FENCE_GATE = register(Blocks.DARK_OAK_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item CRIMSON_FENCE_GATE = register(Blocks.CRIMSON_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item WARPED_FENCE_GATE = register(Blocks.WARPED_FENCE_GATE, ItemGroup.REDSTONE);
    public static final Item BRICK_STAIRS = register(Blocks.BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item STONE_BRICK_STAIRS = register(Blocks.STONE_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item MYCELIUM = register(Blocks.MYCELIUM, ItemGroup.BUILDING_BLOCKS);
    public static final Item LILY_PAD = register(new LilyPadItem(Blocks.LILY_PAD, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item NETHER_BRICKS = register(Blocks.NETHER_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRACKED_NETHER_BRICKS = register(Blocks.CRACKED_NETHER_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CHISELED_NETHER_BRICKS = register(Blocks.CHISELED_NETHER_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item NETHER_BRICK_FENCE = register(Blocks.NETHER_BRICK_FENCE, ItemGroup.DECORATIONS);
    public static final Item NETHER_BRICK_STAIRS = register(Blocks.NETHER_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item ENCHANTING_TABLE = register(Blocks.ENCHANTING_TABLE, ItemGroup.DECORATIONS);
    public static final Item END_PORTAL_FRAME = register(Blocks.END_PORTAL_FRAME, ItemGroup.DECORATIONS);
    public static final Item END_STONE = register(Blocks.END_STONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item END_STONE_BRICKS = register(Blocks.END_STONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item DRAGON_EGG = register(new BlockItem(Blocks.DRAGON_EGG, (new Item.Properties()).rarity(Rarity.EPIC)));
    public static final Item REDSTONE_LAMP = register(Blocks.REDSTONE_LAMP, ItemGroup.REDSTONE);
    public static final Item SANDSTONE_STAIRS = register(Blocks.SANDSTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item EMERALD_ORE = register(Blocks.EMERALD_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item ENDER_CHEST = register(Blocks.ENDER_CHEST, ItemGroup.DECORATIONS);
    public static final Item TRIPWIRE_HOOK = register(Blocks.TRIPWIRE_HOOK, ItemGroup.REDSTONE);
    public static final Item EMERALD_BLOCK = register(Blocks.EMERALD_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item SPRUCE_STAIRS = register(Blocks.SPRUCE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BIRCH_STAIRS = register(Blocks.BIRCH_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item JUNGLE_STAIRS = register(Blocks.JUNGLE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRIMSON_STAIRS = register(Blocks.CRIMSON_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_STAIRS = register(Blocks.WARPED_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item COMMAND_BLOCK = register(new OperatorOnlyItem(Blocks.COMMAND_BLOCK, (new Item.Properties()).rarity(Rarity.EPIC)));
    public static final Item BEACON = register(new BlockItem(Blocks.BEACON, (new Item.Properties()).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item COBBLESTONE_WALL = register(Blocks.COBBLESTONE_WALL, ItemGroup.DECORATIONS);
    public static final Item MOSSY_COBBLESTONE_WALL = register(Blocks.MOSSY_COBBLESTONE_WALL, ItemGroup.DECORATIONS);
    public static final Item BRICK_WALL = register(Blocks.BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item PRISMARINE_WALL = register(Blocks.PRISMARINE_WALL, ItemGroup.DECORATIONS);
    public static final Item RED_SANDSTONE_WALL = register(Blocks.RED_SANDSTONE_WALL, ItemGroup.DECORATIONS);
    public static final Item MOSSY_STONE_BRICK_WALL = register(Blocks.MOSSY_STONE_BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item GRANITE_WALL = register(Blocks.GRANITE_WALL, ItemGroup.DECORATIONS);
    public static final Item STONE_BRICK_WALL = register(Blocks.STONE_BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item NETHER_BRICK_WALL = register(Blocks.NETHER_BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item ANDESITE_WALL = register(Blocks.ANDESITE_WALL, ItemGroup.DECORATIONS);
    public static final Item RED_NETHER_BRICK_WALL = register(Blocks.RED_NETHER_BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item SANDSTONE_WALL = register(Blocks.SANDSTONE_WALL, ItemGroup.DECORATIONS);
    public static final Item END_STONE_BRICK_WALL = register(Blocks.END_STONE_BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item DIORITE_WALL = register(Blocks.DIORITE_WALL, ItemGroup.DECORATIONS);
    public static final Item BLACKSTONE_WALL = register(Blocks.BLACKSTONE_WALL, ItemGroup.DECORATIONS);
    public static final Item POLISHED_BLACKSTONE_WALL = register(Blocks.POLISHED_BLACKSTONE_WALL, ItemGroup.DECORATIONS);
    public static final Item POLISHED_BLACKSTONE_BRICK_WALL = register(Blocks.POLISHED_BLACKSTONE_BRICK_WALL, ItemGroup.DECORATIONS);
    public static final Item STONE_BUTTON = register(Blocks.STONE_BUTTON, ItemGroup.REDSTONE);
    public static final Item OAK_BUTTON = register(Blocks.OAK_BUTTON, ItemGroup.REDSTONE);
    public static final Item SPRUCE_BUTTON = register(Blocks.SPRUCE_BUTTON, ItemGroup.REDSTONE);
    public static final Item BIRCH_BUTTON = register(Blocks.BIRCH_BUTTON, ItemGroup.REDSTONE);
    public static final Item JUNGLE_BUTTON = register(Blocks.JUNGLE_BUTTON, ItemGroup.REDSTONE);
    public static final Item ACACIA_BUTTON = register(Blocks.ACACIA_BUTTON, ItemGroup.REDSTONE);
    public static final Item DARK_OAK_BUTTON = register(Blocks.DARK_OAK_BUTTON, ItemGroup.REDSTONE);
    public static final Item CRIMSON_BUTTON = register(Blocks.CRIMSON_BUTTON, ItemGroup.REDSTONE);
    public static final Item WARPED_BUTTON = register(Blocks.WARPED_BUTTON, ItemGroup.REDSTONE);
    public static final Item POLISHED_BLACKSTONE_BUTTON = register(Blocks.POLISHED_BLACKSTONE_BUTTON, ItemGroup.REDSTONE);
    public static final Item ANVIL = register(Blocks.ANVIL, ItemGroup.DECORATIONS);
    public static final Item CHIPPED_ANVIL = register(Blocks.CHIPPED_ANVIL, ItemGroup.DECORATIONS);
    public static final Item DAMAGED_ANVIL = register(Blocks.DAMAGED_ANVIL, ItemGroup.DECORATIONS);
    public static final Item TRAPPED_CHEST = register(Blocks.TRAPPED_CHEST, ItemGroup.REDSTONE);
    public static final Item LIGHT_WEIGHTED_PRESSURE_PLATE = register(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item HEAVY_WEIGHTED_PRESSURE_PLATE = register(Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE, ItemGroup.REDSTONE);
    public static final Item DAYLIGHT_DETECTOR = register(Blocks.DAYLIGHT_DETECTOR, ItemGroup.REDSTONE);
    public static final Item REDSTONE_BLOCK = register(Blocks.REDSTONE_BLOCK, ItemGroup.REDSTONE);
    public static final Item NETHER_QUARTZ_ORE = register(Blocks.NETHER_QUARTZ_ORE, ItemGroup.BUILDING_BLOCKS);
    public static final Item HOPPER = register(Blocks.HOPPER, ItemGroup.REDSTONE);
    public static final Item CHISELED_QUARTZ_BLOCK = register(Blocks.CHISELED_QUARTZ_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item QUARTZ_BLOCK = register(Blocks.QUARTZ_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item QUARTZ_BRICKS = register(Blocks.QUARTZ_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item QUARTZ_PILLAR = register(Blocks.QUARTZ_PILLAR, ItemGroup.BUILDING_BLOCKS);
    public static final Item QUARTZ_STAIRS = register(Blocks.QUARTZ_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item ACTIVATOR_RAIL = register(Blocks.ACTIVATOR_RAIL, ItemGroup.TRANSPORTATION);
    public static final Item DROPPER = register(Blocks.DROPPER, ItemGroup.REDSTONE);
    public static final Item WHITE_TERRACOTTA = register(Blocks.WHITE_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item ORANGE_TERRACOTTA = register(Blocks.ORANGE_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item MAGENTA_TERRACOTTA = register(Blocks.MAGENTA_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_BLUE_TERRACOTTA = register(Blocks.LIGHT_BLUE_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item YELLOW_TERRACOTTA = register(Blocks.YELLOW_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIME_TERRACOTTA = register(Blocks.LIME_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item PINK_TERRACOTTA = register(Blocks.PINK_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRAY_TERRACOTTA = register(Blocks.GRAY_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_GRAY_TERRACOTTA = register(Blocks.LIGHT_GRAY_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item CYAN_TERRACOTTA = register(Blocks.CYAN_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPLE_TERRACOTTA = register(Blocks.PURPLE_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLUE_TERRACOTTA = register(Blocks.BLUE_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item BROWN_TERRACOTTA = register(Blocks.BROWN_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item GREEN_TERRACOTTA = register(Blocks.GREEN_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_TERRACOTTA = register(Blocks.RED_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACK_TERRACOTTA = register(Blocks.BLACK_TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item BARRIER = register(Blocks.BARRIER);
    public static final Item IRON_TRAPDOOR = register(Blocks.IRON_TRAPDOOR, ItemGroup.REDSTONE);
    public static final Item HAY_BLOCK = register(Blocks.HAY_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item WHITE_CARPET = register(Blocks.WHITE_CARPET, ItemGroup.DECORATIONS);
    public static final Item ORANGE_CARPET = register(Blocks.ORANGE_CARPET, ItemGroup.DECORATIONS);
    public static final Item MAGENTA_CARPET = register(Blocks.MAGENTA_CARPET, ItemGroup.DECORATIONS);
    public static final Item LIGHT_BLUE_CARPET = register(Blocks.LIGHT_BLUE_CARPET, ItemGroup.DECORATIONS);
    public static final Item YELLOW_CARPET = register(Blocks.YELLOW_CARPET, ItemGroup.DECORATIONS);
    public static final Item LIME_CARPET = register(Blocks.LIME_CARPET, ItemGroup.DECORATIONS);
    public static final Item PINK_CARPET = register(Blocks.PINK_CARPET, ItemGroup.DECORATIONS);
    public static final Item GRAY_CARPET = register(Blocks.GRAY_CARPET, ItemGroup.DECORATIONS);
    public static final Item LIGHT_GRAY_CARPET = register(Blocks.LIGHT_GRAY_CARPET, ItemGroup.DECORATIONS);
    public static final Item CYAN_CARPET = register(Blocks.CYAN_CARPET, ItemGroup.DECORATIONS);
    public static final Item PURPLE_CARPET = register(Blocks.PURPLE_CARPET, ItemGroup.DECORATIONS);
    public static final Item BLUE_CARPET = register(Blocks.BLUE_CARPET, ItemGroup.DECORATIONS);
    public static final Item BROWN_CARPET = register(Blocks.BROWN_CARPET, ItemGroup.DECORATIONS);
    public static final Item GREEN_CARPET = register(Blocks.GREEN_CARPET, ItemGroup.DECORATIONS);
    public static final Item RED_CARPET = register(Blocks.RED_CARPET, ItemGroup.DECORATIONS);
    public static final Item BLACK_CARPET = register(Blocks.BLACK_CARPET, ItemGroup.DECORATIONS);
    public static final Item TERRACOTTA = register(Blocks.TERRACOTTA, ItemGroup.BUILDING_BLOCKS);
    public static final Item COAL_BLOCK = register(Blocks.COAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item PACKED_ICE = register(Blocks.PACKED_ICE, ItemGroup.BUILDING_BLOCKS);
    public static final Item ACACIA_STAIRS = register(Blocks.ACACIA_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_OAK_STAIRS = register(Blocks.DARK_OAK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SLIME_BLOCK = register(Blocks.SLIME_BLOCK, ItemGroup.DECORATIONS);
    public static final Item GRASS_PATH = register(Blocks.GRASS_PATH, ItemGroup.DECORATIONS);
    public static final Item SUNFLOWER = register(new TallBlockItem(Blocks.SUNFLOWER, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item LILAC = register(new TallBlockItem(Blocks.LILAC, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item ROSE_BUSH = register(new TallBlockItem(Blocks.ROSE_BUSH, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item PEONY = register(new TallBlockItem(Blocks.PEONY, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item TALL_GRASS = register(new TallBlockItem(Blocks.TALL_GRASS, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item LARGE_FERN = register(new TallBlockItem(Blocks.LARGE_FERN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item WHITE_STAINED_GLASS = register(Blocks.WHITE_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item ORANGE_STAINED_GLASS = register(Blocks.ORANGE_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item MAGENTA_STAINED_GLASS = register(Blocks.MAGENTA_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_BLUE_STAINED_GLASS = register(Blocks.LIGHT_BLUE_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item YELLOW_STAINED_GLASS = register(Blocks.YELLOW_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIME_STAINED_GLASS = register(Blocks.LIME_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item PINK_STAINED_GLASS = register(Blocks.PINK_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRAY_STAINED_GLASS = register(Blocks.GRAY_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_GRAY_STAINED_GLASS = register(Blocks.LIGHT_GRAY_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CYAN_STAINED_GLASS = register(Blocks.CYAN_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPLE_STAINED_GLASS = register(Blocks.PURPLE_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLUE_STAINED_GLASS = register(Blocks.BLUE_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BROWN_STAINED_GLASS = register(Blocks.BROWN_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item GREEN_STAINED_GLASS = register(Blocks.GREEN_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_STAINED_GLASS = register(Blocks.RED_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACK_STAINED_GLASS = register(Blocks.BLACK_STAINED_GLASS, ItemGroup.BUILDING_BLOCKS);
    public static final Item WHITE_STAINED_GLASS_PANE = register(Blocks.WHITE_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item ORANGE_STAINED_GLASS_PANE = register(Blocks.ORANGE_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item MAGENTA_STAINED_GLASS_PANE = register(Blocks.MAGENTA_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item LIGHT_BLUE_STAINED_GLASS_PANE = register(Blocks.LIGHT_BLUE_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item YELLOW_STAINED_GLASS_PANE = register(Blocks.YELLOW_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item LIME_STAINED_GLASS_PANE = register(Blocks.LIME_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item PINK_STAINED_GLASS_PANE = register(Blocks.PINK_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item GRAY_STAINED_GLASS_PANE = register(Blocks.GRAY_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item LIGHT_GRAY_STAINED_GLASS_PANE = register(Blocks.LIGHT_GRAY_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item CYAN_STAINED_GLASS_PANE = register(Blocks.CYAN_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item PURPLE_STAINED_GLASS_PANE = register(Blocks.PURPLE_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item BLUE_STAINED_GLASS_PANE = register(Blocks.BLUE_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item BROWN_STAINED_GLASS_PANE = register(Blocks.BROWN_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item GREEN_STAINED_GLASS_PANE = register(Blocks.GREEN_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item RED_STAINED_GLASS_PANE = register(Blocks.RED_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item BLACK_STAINED_GLASS_PANE = register(Blocks.BLACK_STAINED_GLASS_PANE, ItemGroup.DECORATIONS);
    public static final Item PRISMARINE = register(Blocks.PRISMARINE, ItemGroup.BUILDING_BLOCKS);
    public static final Item PRISMARINE_BRICKS = register(Blocks.PRISMARINE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_PRISMARINE = register(Blocks.DARK_PRISMARINE, ItemGroup.BUILDING_BLOCKS);
    public static final Item PRISMARINE_STAIRS = register(Blocks.PRISMARINE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item PRISMARINE_BRICK_STAIRS = register(Blocks.PRISMARINE_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item DARK_PRISMARINE_STAIRS = register(Blocks.DARK_PRISMARINE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SEA_LANTERN = register(Blocks.SEA_LANTERN, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_SANDSTONE = register(Blocks.RED_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item CHISELED_RED_SANDSTONE = register(Blocks.CHISELED_RED_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item CUT_RED_SANDSTONE = register(Blocks.CUT_RED_SANDSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_SANDSTONE_STAIRS = register(Blocks.RED_SANDSTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item REPEATING_COMMAND_BLOCK = register(new OperatorOnlyItem(Blocks.REPEATING_COMMAND_BLOCK, (new Item.Properties()).rarity(Rarity.EPIC)));
    public static final Item CHAIN_COMMAND_BLOCK = register(new OperatorOnlyItem(Blocks.CHAIN_COMMAND_BLOCK, (new Item.Properties()).rarity(Rarity.EPIC)));
    public static final Item MAGMA_BLOCK = register(Blocks.MAGMA_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item NETHER_WART_BLOCK = register(Blocks.NETHER_WART_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item WARPED_WART_BLOCK = register(Blocks.WARPED_WART_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_NETHER_BRICKS = register(Blocks.RED_NETHER_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item BONE_BLOCK = register(Blocks.BONE_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item STRUCTURE_VOID = register(Blocks.STRUCTURE_VOID);
    public static final Item OBSERVER = register(Blocks.OBSERVER, ItemGroup.REDSTONE);
    public static final Item SHULKER_BOX = register(new BlockItem(Blocks.SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item WHITE_SHULKER_BOX = register(new BlockItem(Blocks.WHITE_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item ORANGE_SHULKER_BOX = register(new BlockItem(Blocks.ORANGE_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item MAGENTA_SHULKER_BOX = register(new BlockItem(Blocks.MAGENTA_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item LIGHT_BLUE_SHULKER_BOX = register(new BlockItem(Blocks.LIGHT_BLUE_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item YELLOW_SHULKER_BOX = register(new BlockItem(Blocks.YELLOW_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item LIME_SHULKER_BOX = register(new BlockItem(Blocks.LIME_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item PINK_SHULKER_BOX = register(new BlockItem(Blocks.PINK_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item GRAY_SHULKER_BOX = register(new BlockItem(Blocks.GRAY_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item LIGHT_GRAY_SHULKER_BOX = register(new BlockItem(Blocks.LIGHT_GRAY_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item CYAN_SHULKER_BOX = register(new BlockItem(Blocks.CYAN_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item PURPLE_SHULKER_BOX = register(new BlockItem(Blocks.PURPLE_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item BLUE_SHULKER_BOX = register(new BlockItem(Blocks.BLUE_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item BROWN_SHULKER_BOX = register(new BlockItem(Blocks.BROWN_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item GREEN_SHULKER_BOX = register(new BlockItem(Blocks.GREEN_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item RED_SHULKER_BOX = register(new BlockItem(Blocks.RED_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item BLACK_SHULKER_BOX = register(new BlockItem(Blocks.BLACK_SHULKER_BOX, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item WHITE_GLAZED_TERRACOTTA = register(Blocks.WHITE_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item ORANGE_GLAZED_TERRACOTTA = register(Blocks.ORANGE_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item MAGENTA_GLAZED_TERRACOTTA = register(Blocks.MAGENTA_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item LIGHT_BLUE_GLAZED_TERRACOTTA = register(Blocks.LIGHT_BLUE_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item YELLOW_GLAZED_TERRACOTTA = register(Blocks.YELLOW_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item LIME_GLAZED_TERRACOTTA = register(Blocks.LIME_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item PINK_GLAZED_TERRACOTTA = register(Blocks.PINK_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item GRAY_GLAZED_TERRACOTTA = register(Blocks.GRAY_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item LIGHT_GRAY_GLAZED_TERRACOTTA = register(Blocks.LIGHT_GRAY_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item CYAN_GLAZED_TERRACOTTA = register(Blocks.CYAN_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item PURPLE_GLAZED_TERRACOTTA = register(Blocks.PURPLE_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item BLUE_GLAZED_TERRACOTTA = register(Blocks.BLUE_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item BROWN_GLAZED_TERRACOTTA = register(Blocks.BROWN_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item GREEN_GLAZED_TERRACOTTA = register(Blocks.GREEN_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item RED_GLAZED_TERRACOTTA = register(Blocks.RED_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item BLACK_GLAZED_TERRACOTTA = register(Blocks.BLACK_GLAZED_TERRACOTTA, ItemGroup.DECORATIONS);
    public static final Item WHITE_CONCRETE = register(Blocks.WHITE_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item ORANGE_CONCRETE = register(Blocks.ORANGE_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item MAGENTA_CONCRETE = register(Blocks.MAGENTA_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_BLUE_CONCRETE = register(Blocks.LIGHT_BLUE_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item YELLOW_CONCRETE = register(Blocks.YELLOW_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIME_CONCRETE = register(Blocks.LIME_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item PINK_CONCRETE = register(Blocks.PINK_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRAY_CONCRETE = register(Blocks.GRAY_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_GRAY_CONCRETE = register(Blocks.LIGHT_GRAY_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item CYAN_CONCRETE = register(Blocks.CYAN_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPLE_CONCRETE = register(Blocks.PURPLE_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLUE_CONCRETE = register(Blocks.BLUE_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item BROWN_CONCRETE = register(Blocks.BROWN_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item GREEN_CONCRETE = register(Blocks.GREEN_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_CONCRETE = register(Blocks.RED_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACK_CONCRETE = register(Blocks.BLACK_CONCRETE, ItemGroup.BUILDING_BLOCKS);
    public static final Item WHITE_CONCRETE_POWDER = register(Blocks.WHITE_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item ORANGE_CONCRETE_POWDER = register(Blocks.ORANGE_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item MAGENTA_CONCRETE_POWDER = register(Blocks.MAGENTA_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_BLUE_CONCRETE_POWDER = register(Blocks.LIGHT_BLUE_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item YELLOW_CONCRETE_POWDER = register(Blocks.YELLOW_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIME_CONCRETE_POWDER = register(Blocks.LIME_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item PINK_CONCRETE_POWDER = register(Blocks.PINK_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRAY_CONCRETE_POWDER = register(Blocks.GRAY_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item LIGHT_GRAY_CONCRETE_POWDER = register(Blocks.LIGHT_GRAY_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item CYAN_CONCRETE_POWDER = register(Blocks.CYAN_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item PURPLE_CONCRETE_POWDER = register(Blocks.PURPLE_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLUE_CONCRETE_POWDER = register(Blocks.BLUE_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item BROWN_CONCRETE_POWDER = register(Blocks.BROWN_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item GREEN_CONCRETE_POWDER = register(Blocks.GREEN_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_CONCRETE_POWDER = register(Blocks.RED_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACK_CONCRETE_POWDER = register(Blocks.BLACK_CONCRETE_POWDER, ItemGroup.BUILDING_BLOCKS);
    public static final Item TURTLE_EGG = register(Blocks.TURTLE_EGG, ItemGroup.MISC);
    public static final Item DEAD_TUBE_CORAL_BLOCK = register(Blocks.DEAD_TUBE_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item DEAD_BRAIN_CORAL_BLOCK = register(Blocks.DEAD_BRAIN_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item DEAD_BUBBLE_CORAL_BLOCK = register(Blocks.DEAD_BUBBLE_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item DEAD_FIRE_CORAL_BLOCK = register(Blocks.DEAD_FIRE_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item DEAD_HORN_CORAL_BLOCK = register(Blocks.DEAD_HORN_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item TUBE_CORAL_BLOCK = register(Blocks.TUBE_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item BRAIN_CORAL_BLOCK = register(Blocks.BRAIN_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item BUBBLE_CORAL_BLOCK = register(Blocks.BUBBLE_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item FIRE_CORAL_BLOCK = register(Blocks.FIRE_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item HORN_CORAL_BLOCK = register(Blocks.HORN_CORAL_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item TUBE_CORAL = register(Blocks.TUBE_CORAL, ItemGroup.DECORATIONS);
    public static final Item BRAIN_CORAL = register(Blocks.BRAIN_CORAL, ItemGroup.DECORATIONS);
    public static final Item BUBBLE_CORAL = register(Blocks.BUBBLE_CORAL, ItemGroup.DECORATIONS);
    public static final Item FIRE_CORAL = register(Blocks.FIRE_CORAL, ItemGroup.DECORATIONS);
    public static final Item HORN_CORAL = register(Blocks.HORN_CORAL, ItemGroup.DECORATIONS);
    public static final Item DEAD_BRAIN_CORAL = register(Blocks.DEAD_BRAIN_CORAL, ItemGroup.DECORATIONS);
    public static final Item DEAD_BUBBLE_CORAL = register(Blocks.DEAD_BUBBLE_CORAL, ItemGroup.DECORATIONS);
    public static final Item DEAD_FIRE_CORAL = register(Blocks.DEAD_FIRE_CORAL, ItemGroup.DECORATIONS);
    public static final Item DEAD_HORN_CORAL = register(Blocks.DEAD_HORN_CORAL, ItemGroup.DECORATIONS);
    public static final Item DEAD_TUBE_CORAL = register(Blocks.DEAD_TUBE_CORAL, ItemGroup.DECORATIONS);
    public static final Item TUBE_CORAL_FAN = register(new WallOrFloorItem(Blocks.TUBE_CORAL_FAN, Blocks.TUBE_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item BRAIN_CORAL_FAN = register(new WallOrFloorItem(Blocks.BRAIN_CORAL_FAN, Blocks.BRAIN_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item BUBBLE_CORAL_FAN = register(new WallOrFloorItem(Blocks.BUBBLE_CORAL_FAN, Blocks.BUBBLE_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item FIRE_CORAL_FAN = register(new WallOrFloorItem(Blocks.FIRE_CORAL_FAN, Blocks.FIRE_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item HORN_CORAL_FAN = register(new WallOrFloorItem(Blocks.HORN_CORAL_FAN, Blocks.HORN_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item DEAD_TUBE_CORAL_FAN = register(new WallOrFloorItem(Blocks.DEAD_TUBE_CORAL_FAN, Blocks.DEAD_TUBE_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item DEAD_BRAIN_CORAL_FAN = register(new WallOrFloorItem(Blocks.DEAD_BRAIN_CORAL_FAN, Blocks.DEAD_BRAIN_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item DEAD_BUBBLE_CORAL_FAN = register(new WallOrFloorItem(Blocks.DEAD_BUBBLE_CORAL_FAN, Blocks.DEAD_BUBBLE_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item DEAD_FIRE_CORAL_FAN = register(new WallOrFloorItem(Blocks.DEAD_FIRE_CORAL_FAN, Blocks.DEAD_FIRE_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item DEAD_HORN_CORAL_FAN = register(new WallOrFloorItem(Blocks.DEAD_HORN_CORAL_FAN, Blocks.DEAD_HORN_CORAL_WALL_FAN, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item BLUE_ICE = register(Blocks.BLUE_ICE, ItemGroup.BUILDING_BLOCKS);
    public static final Item CONDUIT = register(new BlockItem(Blocks.CONDUIT, (new Item.Properties()).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item POLISHED_GRANITE_STAIRS = register(Blocks.POLISHED_GRANITE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_RED_SANDSTONE_STAIRS = register(Blocks.SMOOTH_RED_SANDSTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item MOSSY_STONE_BRICK_STAIRS = register(Blocks.MOSSY_STONE_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_DIORITE_STAIRS = register(Blocks.POLISHED_DIORITE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item MOSSY_COBBLESTONE_STAIRS = register(Blocks.MOSSY_COBBLESTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item END_STONE_BRICK_STAIRS = register(Blocks.END_STONE_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item STONE_STAIRS = register(Blocks.STONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_SANDSTONE_STAIRS = register(Blocks.SMOOTH_SANDSTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_QUARTZ_STAIRS = register(Blocks.SMOOTH_QUARTZ_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRANITE_STAIRS = register(Blocks.GRANITE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item ANDESITE_STAIRS = register(Blocks.ANDESITE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_NETHER_BRICK_STAIRS = register(Blocks.RED_NETHER_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_ANDESITE_STAIRS = register(Blocks.POLISHED_ANDESITE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item DIORITE_STAIRS = register(Blocks.DIORITE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_GRANITE_SLAB = register(Blocks.POLISHED_GRANITE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_RED_SANDSTONE_SLAB = register(Blocks.SMOOTH_RED_SANDSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item MOSSY_STONE_BRICK_SLAB = register(Blocks.MOSSY_STONE_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_DIORITE_SLAB = register(Blocks.POLISHED_DIORITE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item MOSSY_COBBLESTONE_SLAB = register(Blocks.MOSSY_COBBLESTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item END_STONE_BRICK_SLAB = register(Blocks.END_STONE_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_SANDSTONE_SLAB = register(Blocks.SMOOTH_SANDSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SMOOTH_QUARTZ_SLAB = register(Blocks.SMOOTH_QUARTZ_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item GRANITE_SLAB = register(Blocks.GRANITE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item ANDESITE_SLAB = register(Blocks.ANDESITE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item RED_NETHER_BRICK_SLAB = register(Blocks.RED_NETHER_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_ANDESITE_SLAB = register(Blocks.POLISHED_ANDESITE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item DIORITE_SLAB = register(Blocks.DIORITE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item SCAFFOLDING = register(new ScaffoldingItem(Blocks.SCAFFOLDING, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item IRON_DOOR = register(new TallBlockItem(Blocks.IRON_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item OAK_DOOR = register(new TallBlockItem(Blocks.OAK_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item SPRUCE_DOOR = register(new TallBlockItem(Blocks.SPRUCE_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item BIRCH_DOOR = register(new TallBlockItem(Blocks.BIRCH_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item JUNGLE_DOOR = register(new TallBlockItem(Blocks.JUNGLE_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item ACACIA_DOOR = register(new TallBlockItem(Blocks.ACACIA_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item DARK_OAK_DOOR = register(new TallBlockItem(Blocks.DARK_OAK_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item CRIMSON_DOOR = register(new TallBlockItem(Blocks.CRIMSON_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item WARPED_DOOR = register(new TallBlockItem(Blocks.WARPED_DOOR, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item REPEATER = register(Blocks.REPEATER, ItemGroup.REDSTONE);
    public static final Item COMPARATOR = register(Blocks.COMPARATOR, ItemGroup.REDSTONE);
    public static final Item STRUCTURE_BLOCK = register(new OperatorOnlyItem(Blocks.STRUCTURE_BLOCK, (new Item.Properties()).rarity(Rarity.EPIC)));
    public static final Item JIGSAW = register(new OperatorOnlyItem(Blocks.JIGSAW, (new Item.Properties()).rarity(Rarity.EPIC)));
    public static final Item TURTLE_HELMET = register("turtle_helmet", new ArmorItem(ArmorMaterial.TURTLE, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item SCUTE = register("scute", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item FLINT_AND_STEEL = register("flint_and_steel", new FlintAndSteelItem((new Item.Properties()).maxDamage(64).group(ItemGroup.TOOLS)));
    public static final Item APPLE = register("apple", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.APPLE)));
    public static final Item BOW = register("bow", new BowItem((new Item.Properties()).maxDamage(384).group(ItemGroup.COMBAT)));
    public static final Item ARROW = register("arrow", new ArrowItem((new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item COAL = register("coal", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item CHARCOAL = register("charcoal", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item DIAMOND = register("diamond", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item IRON_INGOT = register("iron_ingot", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item GOLD_INGOT = register("gold_ingot", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item NETHERITE_INGOT = register("netherite_ingot", new Item((new Item.Properties()).group(ItemGroup.MATERIALS).isImmuneToFire()));
    public static final Item NETHERITE_SCRAP = register("netherite_scrap", new Item((new Item.Properties()).group(ItemGroup.MATERIALS).isImmuneToFire()));
    public static final Item WOODEN_SWORD = register("wooden_sword", new SwordItem(ItemTier.WOOD, 3, -2.4F, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item WOODEN_SHOVEL = register("wooden_shovel", new ShovelItem(ItemTier.WOOD, 1.5F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item WOODEN_PICKAXE = register("wooden_pickaxe", new PickaxeItem(ItemTier.WOOD, 1, -2.8F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item WOODEN_AXE = register("wooden_axe", new AxeItem(ItemTier.WOOD, 6.0F, -3.2F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item WOODEN_HOE = register("wooden_hoe", new HoeItem(ItemTier.WOOD, 0, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item STONE_SWORD = register("stone_sword", new SwordItem(ItemTier.STONE, 3, -2.4F, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item STONE_SHOVEL = register("stone_shovel", new ShovelItem(ItemTier.STONE, 1.5F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item STONE_PICKAXE = register("stone_pickaxe", new PickaxeItem(ItemTier.STONE, 1, -2.8F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item STONE_AXE = register("stone_axe", new AxeItem(ItemTier.STONE, 7.0F, -3.2F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item STONE_HOE = register("stone_hoe", new HoeItem(ItemTier.STONE, -1, -2.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item GOLDEN_SWORD = register("golden_sword", new SwordItem(ItemTier.GOLD, 3, -2.4F, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item GOLDEN_SHOVEL = register("golden_shovel", new ShovelItem(ItemTier.GOLD, 1.5F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item GOLDEN_PICKAXE = register("golden_pickaxe", new PickaxeItem(ItemTier.GOLD, 1, -2.8F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item GOLDEN_AXE = register("golden_axe", new AxeItem(ItemTier.GOLD, 6.0F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item GOLDEN_HOE = register("golden_hoe", new HoeItem(ItemTier.GOLD, 0, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item IRON_SWORD = register("iron_sword", new SwordItem(ItemTier.IRON, 3, -2.4F, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item IRON_SHOVEL = register("iron_shovel", new ShovelItem(ItemTier.IRON, 1.5F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item IRON_PICKAXE = register("iron_pickaxe", new PickaxeItem(ItemTier.IRON, 1, -2.8F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item IRON_AXE = register("iron_axe", new AxeItem(ItemTier.IRON, 6.0F, -3.1F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item IRON_HOE = register("iron_hoe", new HoeItem(ItemTier.IRON, -2, -1.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item DIAMOND_SWORD = register("diamond_sword", new SwordItem(ItemTier.DIAMOND, 3, -2.4F, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item DIAMOND_SHOVEL = register("diamond_shovel", new ShovelItem(ItemTier.DIAMOND, 1.5F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item DIAMOND_PICKAXE = register("diamond_pickaxe", new PickaxeItem(ItemTier.DIAMOND, 1, -2.8F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item DIAMOND_AXE = register("diamond_axe", new AxeItem(ItemTier.DIAMOND, 5.0F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item DIAMOND_HOE = register("diamond_hoe", new HoeItem(ItemTier.DIAMOND, -3, 0.0F, (new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item NETHERITE_SWORD = register("netherite_sword", new SwordItem(ItemTier.NETHERITE, 3, -2.4F, (new Item.Properties()).group(ItemGroup.COMBAT).isImmuneToFire()));
    public static final Item NETHERITE_SHOVEL = register("netherite_shovel", new ShovelItem(ItemTier.NETHERITE, 1.5F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS).isImmuneToFire()));
    public static final Item NETHERITE_PICKAXE = register("netherite_pickaxe", new PickaxeItem(ItemTier.NETHERITE, 1, -2.8F, (new Item.Properties()).group(ItemGroup.TOOLS).isImmuneToFire()));
    public static final Item NETHERITE_AXE = register("netherite_axe", new AxeItem(ItemTier.NETHERITE, 5.0F, -3.0F, (new Item.Properties()).group(ItemGroup.TOOLS).isImmuneToFire()));
    public static final Item NETHERITE_HOE = register("netherite_hoe", new HoeItem(ItemTier.NETHERITE, -4, 0.0F, (new Item.Properties()).group(ItemGroup.TOOLS).isImmuneToFire()));
    public static final Item STICK = register("stick", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BOWL = register("bowl", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item MUSHROOM_STEW = register("mushroom_stew", new SoupItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.FOOD).food(Foods.MUSHROOM_STEW)));
    public static final Item STRING = register("string", new BlockNamedItem(Blocks.TRIPWIRE, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item FEATHER = register("feather", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item GUNPOWDER = register("gunpowder", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item WHEAT_SEEDS = register("wheat_seeds", new BlockNamedItem(Blocks.WHEAT, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item WHEAT = register("wheat", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BREAD = register("bread", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.BREAD)));
    public static final Item LEATHER_HELMET = register("leather_helmet", new DyeableArmorItem(ArmorMaterial.LEATHER, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item LEATHER_CHESTPLATE = register("leather_chestplate", new DyeableArmorItem(ArmorMaterial.LEATHER, EquipmentSlotType.CHEST, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item LEATHER_LEGGINGS = register("leather_leggings", new DyeableArmorItem(ArmorMaterial.LEATHER, EquipmentSlotType.LEGS, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item LEATHER_BOOTS = register("leather_boots", new DyeableArmorItem(ArmorMaterial.LEATHER, EquipmentSlotType.FEET, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item CHAINMAIL_HELMET = register("chainmail_helmet", new ArmorItem(ArmorMaterial.CHAIN, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item CHAINMAIL_CHESTPLATE = register("chainmail_chestplate", new ArmorItem(ArmorMaterial.CHAIN, EquipmentSlotType.CHEST, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item CHAINMAIL_LEGGINGS = register("chainmail_leggings", new ArmorItem(ArmorMaterial.CHAIN, EquipmentSlotType.LEGS, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item CHAINMAIL_BOOTS = register("chainmail_boots", new ArmorItem(ArmorMaterial.CHAIN, EquipmentSlotType.FEET, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item IRON_HELMET = register("iron_helmet", new ArmorItem(ArmorMaterial.IRON, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item IRON_CHESTPLATE = register("iron_chestplate", new ArmorItem(ArmorMaterial.IRON, EquipmentSlotType.CHEST, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item IRON_LEGGINGS = register("iron_leggings", new ArmorItem(ArmorMaterial.IRON, EquipmentSlotType.LEGS, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item IRON_BOOTS = register("iron_boots", new ArmorItem(ArmorMaterial.IRON, EquipmentSlotType.FEET, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item DIAMOND_HELMET = register("diamond_helmet", new ArmorItem(ArmorMaterial.DIAMOND, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item DIAMOND_CHESTPLATE = register("diamond_chestplate", new ArmorItem(ArmorMaterial.DIAMOND, EquipmentSlotType.CHEST, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item DIAMOND_LEGGINGS = register("diamond_leggings", new ArmorItem(ArmorMaterial.DIAMOND, EquipmentSlotType.LEGS, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item DIAMOND_BOOTS = register("diamond_boots", new ArmorItem(ArmorMaterial.DIAMOND, EquipmentSlotType.FEET, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item GOLDEN_HELMET = register("golden_helmet", new ArmorItem(ArmorMaterial.GOLD, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item GOLDEN_CHESTPLATE = register("golden_chestplate", new ArmorItem(ArmorMaterial.GOLD, EquipmentSlotType.CHEST, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item GOLDEN_LEGGINGS = register("golden_leggings", new ArmorItem(ArmorMaterial.GOLD, EquipmentSlotType.LEGS, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item GOLDEN_BOOTS = register("golden_boots", new ArmorItem(ArmorMaterial.GOLD, EquipmentSlotType.FEET, (new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item NETHERITE_HELMET = register("netherite_helmet", new ArmorItem(ArmorMaterial.NETHERITE, EquipmentSlotType.HEAD, (new Item.Properties()).group(ItemGroup.COMBAT).isImmuneToFire()));
    public static final Item NETHERITE_CHESTPLATE = register("netherite_chestplate", new ArmorItem(ArmorMaterial.NETHERITE, EquipmentSlotType.CHEST, (new Item.Properties()).group(ItemGroup.COMBAT).isImmuneToFire()));
    public static final Item NETHERITE_LEGGINGS = register("netherite_leggings", new ArmorItem(ArmorMaterial.NETHERITE, EquipmentSlotType.LEGS, (new Item.Properties()).group(ItemGroup.COMBAT).isImmuneToFire()));
    public static final Item NETHERITE_BOOTS = register("netherite_boots", new ArmorItem(ArmorMaterial.NETHERITE, EquipmentSlotType.FEET, (new Item.Properties()).group(ItemGroup.COMBAT).isImmuneToFire()));
    public static final Item FLINT = register("flint", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item PORKCHOP = register("porkchop", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.PORKCHOP)));
    public static final Item COOKED_PORKCHOP = register("cooked_porkchop", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_PORKCHOP)));
    public static final Item PAINTING = register("painting", new HangingEntityItem(EntityType.PAINTING, (new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item GOLDEN_APPLE = register("golden_apple", new Item((new Item.Properties()).group(ItemGroup.FOOD).rarity(Rarity.RARE).food(Foods.GOLDEN_APPLE)));
    public static final Item ENCHANTED_GOLDEN_APPLE = register("enchanted_golden_apple", new EnchantedGoldenAppleItem((new Item.Properties()).group(ItemGroup.FOOD).rarity(Rarity.EPIC).food(Foods.ENCHANTED_GOLDEN_APPLE)));
    public static final Item OAK_SIGN = register("oak_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.OAK_SIGN, Blocks.OAK_WALL_SIGN));
    public static final Item SPRUCE_SIGN = register("spruce_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.SPRUCE_SIGN, Blocks.SPRUCE_WALL_SIGN));
    public static final Item BIRCH_SIGN = register("birch_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.BIRCH_SIGN, Blocks.BIRCH_WALL_SIGN));
    public static final Item JUNGLE_SIGN = register("jungle_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.JUNGLE_SIGN, Blocks.JUNGLE_WALL_SIGN));
    public static final Item ACACIA_SIGN = register("acacia_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.ACACIA_SIGN, Blocks.ACACIA_WALL_SIGN));
    public static final Item DARK_OAK_SIGN = register("dark_oak_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.DARK_OAK_SIGN, Blocks.DARK_OAK_WALL_SIGN));
    public static final Item CRIMSON_SIGN = register("crimson_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.CRIMSON_SIGN, Blocks.CRIMSON_WALL_SIGN));
    public static final Item WARPED_SIGN = register("warped_sign", new SignItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS), Blocks.WARPED_SIGN, Blocks.WARPED_WALL_SIGN));
    public static final Item BUCKET = register("bucket", new BucketItem(Fluids.EMPTY, (new Item.Properties()).maxStackSize(16).group(ItemGroup.MISC)));
    public static final Item WATER_BUCKET = register("water_bucket", new BucketItem(Fluids.WATER, (new Item.Properties()).containerItem(BUCKET).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item LAVA_BUCKET = register("lava_bucket", new BucketItem(Fluids.LAVA, (new Item.Properties()).containerItem(BUCKET).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item MINECART = register("minecart", new MinecartItem(AbstractMinecartEntity.Type.RIDEABLE, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item SADDLE = register("saddle", new SaddleItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item REDSTONE = register("redstone", new BlockNamedItem(Blocks.REDSTONE_WIRE, (new Item.Properties()).group(ItemGroup.REDSTONE)));
    public static final Item SNOWBALL = register("snowball", new SnowballItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.MISC)));
    public static final Item OAK_BOAT = register("oak_boat", new BoatItem(BoatEntity.Type.OAK, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item LEATHER = register("leather", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item MILK_BUCKET = register("milk_bucket", new MilkBucketItem((new Item.Properties()).containerItem(BUCKET).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item PUFFERFISH_BUCKET = register("pufferfish_bucket", new FishBucketItem(EntityType.PUFFERFISH, Fluids.WATER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item SALMON_BUCKET = register("salmon_bucket", new FishBucketItem(EntityType.SALMON, Fluids.WATER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item COD_BUCKET = register("cod_bucket", new FishBucketItem(EntityType.COD, Fluids.WATER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item TROPICAL_FISH_BUCKET = register("tropical_fish_bucket", new FishBucketItem(EntityType.TROPICAL_FISH, Fluids.WATER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item BRICK = register("brick", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item CLAY_BALL = register("clay_ball", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item DRIED_KELP_BLOCK = register(Blocks.DRIED_KELP_BLOCK, ItemGroup.BUILDING_BLOCKS);
    public static final Item PAPER = register("paper", new Item((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item BOOK = register("book", new BookItem((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SLIME_BALL = register("slime_ball", new Item((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item CHEST_MINECART = register("chest_minecart", new MinecartItem(AbstractMinecartEntity.Type.CHEST, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item FURNACE_MINECART = register("furnace_minecart", new MinecartItem(AbstractMinecartEntity.Type.FURNACE, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item EGG = register("egg", new EggItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.MATERIALS)));
    public static final Item COMPASS = register("compass", new CompassItem((new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item FISHING_ROD = register("fishing_rod", new FishingRodItem((new Item.Properties()).maxDamage(64).group(ItemGroup.TOOLS)));
    public static final Item CLOCK = register("clock", new Item((new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item GLOWSTONE_DUST = register("glowstone_dust", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item COD = register("cod", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COD)));
    public static final Item SALMON = register("salmon", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.SALMON)));
    public static final Item TROPICAL_FISH = register("tropical_fish", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.TROPICAL_FISH)));
    public static final Item PUFFERFISH = register("pufferfish", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.PUFFERFISH)));
    public static final Item COOKED_COD = register("cooked_cod", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_COD)));
    public static final Item COOKED_SALMON = register("cooked_salmon", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_SALMON)));
    public static final Item INK_SAC = register("ink_sac", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item COCOA_BEANS = register("cocoa_beans", new BlockNamedItem(Blocks.COCOA, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item LAPIS_LAZULI = register("lapis_lazuli", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item WHITE_DYE = register("white_dye", new DyeItem(DyeColor.WHITE, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item ORANGE_DYE = register("orange_dye", new DyeItem(DyeColor.ORANGE, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item MAGENTA_DYE = register("magenta_dye", new DyeItem(DyeColor.MAGENTA, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item LIGHT_BLUE_DYE = register("light_blue_dye", new DyeItem(DyeColor.LIGHT_BLUE, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item YELLOW_DYE = register("yellow_dye", new DyeItem(DyeColor.YELLOW, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item LIME_DYE = register("lime_dye", new DyeItem(DyeColor.LIME, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item PINK_DYE = register("pink_dye", new DyeItem(DyeColor.PINK, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item GRAY_DYE = register("gray_dye", new DyeItem(DyeColor.GRAY, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item LIGHT_GRAY_DYE = register("light_gray_dye", new DyeItem(DyeColor.LIGHT_GRAY, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item CYAN_DYE = register("cyan_dye", new DyeItem(DyeColor.CYAN, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item PURPLE_DYE = register("purple_dye", new DyeItem(DyeColor.PURPLE, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BLUE_DYE = register("blue_dye", new DyeItem(DyeColor.BLUE, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BROWN_DYE = register("brown_dye", new DyeItem(DyeColor.BROWN, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item GREEN_DYE = register("green_dye", new DyeItem(DyeColor.GREEN, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item RED_DYE = register("red_dye", new DyeItem(DyeColor.RED, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BLACK_DYE = register("black_dye", new DyeItem(DyeColor.BLACK, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BONE_MEAL = register("bone_meal", new BoneMealItem((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BONE = register("bone", new Item((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SUGAR = register("sugar", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item CAKE = register(new BlockItem(Blocks.CAKE, (new Item.Properties()).maxStackSize(1).group(ItemGroup.FOOD)));
    public static final Item WHITE_BED = register(new BedItem(Blocks.WHITE_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item ORANGE_BED = register(new BedItem(Blocks.ORANGE_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item MAGENTA_BED = register(new BedItem(Blocks.MAGENTA_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item LIGHT_BLUE_BED = register(new BedItem(Blocks.LIGHT_BLUE_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item YELLOW_BED = register(new BedItem(Blocks.YELLOW_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item LIME_BED = register(new BedItem(Blocks.LIME_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item PINK_BED = register(new BedItem(Blocks.PINK_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item GRAY_BED = register(new BedItem(Blocks.GRAY_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item LIGHT_GRAY_BED = register(new BedItem(Blocks.LIGHT_GRAY_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item CYAN_BED = register(new BedItem(Blocks.CYAN_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item PURPLE_BED = register(new BedItem(Blocks.PURPLE_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item BLUE_BED = register(new BedItem(Blocks.BLUE_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item BROWN_BED = register(new BedItem(Blocks.BROWN_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item GREEN_BED = register(new BedItem(Blocks.GREEN_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item RED_BED = register(new BedItem(Blocks.RED_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item BLACK_BED = register(new BedItem(Blocks.BLACK_BED, (new Item.Properties()).maxStackSize(1).group(ItemGroup.DECORATIONS)));
    public static final Item COOKIE = register("cookie", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKIE)));
    public static final Item FILLED_MAP = register("filled_map", new FilledMapItem(new Item.Properties()));
    public static final Item SHEARS = register("shears", new ShearsItem((new Item.Properties()).maxDamage(238).group(ItemGroup.TOOLS)));
    public static final Item MELON_SLICE = register("melon_slice", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.MELON_SLICE)));
    public static final Item DRIED_KELP = register("dried_kelp", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.DRIED_KELP)));
    public static final Item PUMPKIN_SEEDS = register("pumpkin_seeds", new BlockNamedItem(Blocks.PUMPKIN_STEM, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item MELON_SEEDS = register("melon_seeds", new BlockNamedItem(Blocks.MELON_STEM, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BEEF = register("beef", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.BEEF)));
    public static final Item COOKED_BEEF = register("cooked_beef", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_BEEF)));
    public static final Item CHICKEN = register("chicken", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.CHICKEN)));
    public static final Item COOKED_CHICKEN = register("cooked_chicken", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_CHICKEN)));
    public static final Item ROTTEN_FLESH = register("rotten_flesh", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.ROTTEN_FLESH)));
    public static final Item ENDER_PEARL = register("ender_pearl", new EnderPearlItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.MISC)));
    public static final Item BLAZE_ROD = register("blaze_rod", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item GHAST_TEAR = register("ghast_tear", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item GOLD_NUGGET = register("gold_nugget", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item NETHER_WART = register("nether_wart", new BlockNamedItem(Blocks.NETHER_WART, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item POTION = register("potion", new PotionItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.BREWING)));
    public static final Item GLASS_BOTTLE = register("glass_bottle", new GlassBottleItem((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item SPIDER_EYE = register("spider_eye", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.SPIDER_EYE)));
    public static final Item FERMENTED_SPIDER_EYE = register("fermented_spider_eye", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item BLAZE_POWDER = register("blaze_powder", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item MAGMA_CREAM = register("magma_cream", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item BREWING_STAND = register(Blocks.BREWING_STAND, ItemGroup.BREWING);
    public static final Item CAULDRON = register(Blocks.CAULDRON, ItemGroup.BREWING);
    public static final Item ENDER_EYE = register("ender_eye", new EnderEyeItem((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item GLISTERING_MELON_SLICE = register("glistering_melon_slice", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item BAT_SPAWN_EGG = register("bat_spawn_egg", new SpawnEggItem(EntityType.BAT, 4996656, 986895, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item BEE_SPAWN_EGG = register("bee_spawn_egg", new SpawnEggItem(EntityType.BEE, 15582019, 4400155, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item BLAZE_SPAWN_EGG = register("blaze_spawn_egg", new SpawnEggItem(EntityType.BLAZE, 16167425, 16775294, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item CAT_SPAWN_EGG = register("cat_spawn_egg", new SpawnEggItem(EntityType.CAT, 15714446, 9794134, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item CAVE_SPIDER_SPAWN_EGG = register("cave_spider_spawn_egg", new SpawnEggItem(EntityType.CAVE_SPIDER, 803406, 11013646, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item CHICKEN_SPAWN_EGG = register("chicken_spawn_egg", new SpawnEggItem(EntityType.CHICKEN, 10592673, 16711680, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item COD_SPAWN_EGG = register("cod_spawn_egg", new SpawnEggItem(EntityType.COD, 12691306, 15058059, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item COW_SPAWN_EGG = register("cow_spawn_egg", new SpawnEggItem(EntityType.COW, 4470310, 10592673, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item CREEPER_SPAWN_EGG = register("creeper_spawn_egg", new SpawnEggItem(EntityType.CREEPER, 894731, 0, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item DOLPHIN_SPAWN_EGG = register("dolphin_spawn_egg", new SpawnEggItem(EntityType.DOLPHIN, 2243405, 16382457, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item DONKEY_SPAWN_EGG = register("donkey_spawn_egg", new SpawnEggItem(EntityType.DONKEY, 5457209, 8811878, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item DROWNED_SPAWN_EGG = register("drowned_spawn_egg", new SpawnEggItem(EntityType.DROWNED, 9433559, 7969893, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ELDER_GUARDIAN_SPAWN_EGG = register("elder_guardian_spawn_egg", new SpawnEggItem(EntityType.ELDER_GUARDIAN, 13552826, 7632531, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ENDERMAN_SPAWN_EGG = register("enderman_spawn_egg", new SpawnEggItem(EntityType.ENDERMAN, 1447446, 0, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ENDERMITE_SPAWN_EGG = register("endermite_spawn_egg", new SpawnEggItem(EntityType.ENDERMITE, 1447446, 7237230, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item EVOKER_SPAWN_EGG = register("evoker_spawn_egg", new SpawnEggItem(EntityType.EVOKER, 9804699, 1973274, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item FOX_SPAWN_EGG = register("fox_spawn_egg", new SpawnEggItem(EntityType.FOX, 14005919, 13396256, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item GHAST_SPAWN_EGG = register("ghast_spawn_egg", new SpawnEggItem(EntityType.GHAST, 16382457, 12369084, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item GUARDIAN_SPAWN_EGG = register("guardian_spawn_egg", new SpawnEggItem(EntityType.GUARDIAN, 5931634, 15826224, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item HOGLIN_SPAWN_EGG = register("hoglin_spawn_egg", new SpawnEggItem(EntityType.HOGLIN, 13004373, 6251620, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item HORSE_SPAWN_EGG = register("horse_spawn_egg", new SpawnEggItem(EntityType.HORSE, 12623485, 15656192, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item HUSK_SPAWN_EGG = register("husk_spawn_egg", new SpawnEggItem(EntityType.HUSK, 7958625, 15125652, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item LLAMA_SPAWN_EGG = register("llama_spawn_egg", new SpawnEggItem(EntityType.LLAMA, 12623485, 10051392, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item MAGMA_CUBE_SPAWN_EGG = register("magma_cube_spawn_egg", new SpawnEggItem(EntityType.MAGMA_CUBE, 3407872, 16579584, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item MOOSHROOM_SPAWN_EGG = register("mooshroom_spawn_egg", new SpawnEggItem(EntityType.MOOSHROOM, 10489616, 12040119, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item MULE_SPAWN_EGG = register("mule_spawn_egg", new SpawnEggItem(EntityType.MULE, 1769984, 5321501, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item OCELOT_SPAWN_EGG = register("ocelot_spawn_egg", new SpawnEggItem(EntityType.OCELOT, 15720061, 5653556, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PANDA_SPAWN_EGG = register("panda_spawn_egg", new SpawnEggItem(EntityType.PANDA, 15198183, 1776418, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PARROT_SPAWN_EGG = register("parrot_spawn_egg", new SpawnEggItem(EntityType.PARROT, 894731, 16711680, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PHANTOM_SPAWN_EGG = register("phantom_spawn_egg", new SpawnEggItem(EntityType.PHANTOM, 4411786, 8978176, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PIG_SPAWN_EGG = register("pig_spawn_egg", new SpawnEggItem(EntityType.PIG, 15771042, 14377823, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PIGLIN_SPAWN_EGG = register("piglin_spawn_egg", new SpawnEggItem(EntityType.PIGLIN, 10051392, 16380836, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item field_242399_ol = register("piglin_brute_spawn_egg", new SpawnEggItem(EntityType.field_242287_aj, 5843472, 16380836, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PILLAGER_SPAWN_EGG = register("pillager_spawn_egg", new SpawnEggItem(EntityType.PILLAGER, 5451574, 9804699, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item POLAR_BEAR_SPAWN_EGG = register("polar_bear_spawn_egg", new SpawnEggItem(EntityType.POLAR_BEAR, 15921906, 9803152, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item PUFFERFISH_SPAWN_EGG = register("pufferfish_spawn_egg", new SpawnEggItem(EntityType.PUFFERFISH, 16167425, 3654642, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item RABBIT_SPAWN_EGG = register("rabbit_spawn_egg", new SpawnEggItem(EntityType.RABBIT, 10051392, 7555121, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item RAVAGER_SPAWN_EGG = register("ravager_spawn_egg", new SpawnEggItem(EntityType.RAVAGER, 7697520, 5984329, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SALMON_SPAWN_EGG = register("salmon_spawn_egg", new SpawnEggItem(EntityType.SALMON, 10489616, 951412, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SHEEP_SPAWN_EGG = register("sheep_spawn_egg", new SpawnEggItem(EntityType.SHEEP, 15198183, 16758197, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SHULKER_SPAWN_EGG = register("shulker_spawn_egg", new SpawnEggItem(EntityType.SHULKER, 9725844, 5060690, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SILVERFISH_SPAWN_EGG = register("silverfish_spawn_egg", new SpawnEggItem(EntityType.SILVERFISH, 7237230, 3158064, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SKELETON_SPAWN_EGG = register("skeleton_spawn_egg", new SpawnEggItem(EntityType.SKELETON, 12698049, 4802889, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SKELETON_HORSE_SPAWN_EGG = register("skeleton_horse_spawn_egg", new SpawnEggItem(EntityType.SKELETON_HORSE, 6842447, 15066584, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SLIME_SPAWN_EGG = register("slime_spawn_egg", new SpawnEggItem(EntityType.SLIME, 5349438, 8306542, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SPIDER_SPAWN_EGG = register("spider_spawn_egg", new SpawnEggItem(EntityType.SPIDER, 3419431, 11013646, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item SQUID_SPAWN_EGG = register("squid_spawn_egg", new SpawnEggItem(EntityType.SQUID, 2243405, 7375001, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item STRAY_SPAWN_EGG = register("stray_spawn_egg", new SpawnEggItem(EntityType.STRAY, 6387319, 14543594, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item STRIDER_SPAWN_EGG = register("strider_spawn_egg", new SpawnEggItem(EntityType.STRIDER, 10236982, 5065037, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item TRADER_LLAMA_SPAWN_EGG = register("trader_llama_spawn_egg", new SpawnEggItem(EntityType.TRADER_LLAMA, 15377456, 4547222, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item TROPICAL_FISH_SPAWN_EGG = register("tropical_fish_spawn_egg", new SpawnEggItem(EntityType.TROPICAL_FISH, 15690005, 16775663, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item TURTLE_SPAWN_EGG = register("turtle_spawn_egg", new SpawnEggItem(EntityType.TURTLE, 15198183, 44975, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item VEX_SPAWN_EGG = register("vex_spawn_egg", new SpawnEggItem(EntityType.VEX, 8032420, 15265265, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item VILLAGER_SPAWN_EGG = register("villager_spawn_egg", new SpawnEggItem(EntityType.VILLAGER, 5651507, 12422002, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item VINDICATOR_SPAWN_EGG = register("vindicator_spawn_egg", new SpawnEggItem(EntityType.VINDICATOR, 9804699, 2580065, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item WANDERING_TRADER_SPAWN_EGG = register("wandering_trader_spawn_egg", new SpawnEggItem(EntityType.WANDERING_TRADER, 4547222, 15377456, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item WITCH_SPAWN_EGG = register("witch_spawn_egg", new SpawnEggItem(EntityType.WITCH, 3407872, 5349438, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item WITHER_SKELETON_SPAWN_EGG = register("wither_skeleton_spawn_egg", new SpawnEggItem(EntityType.WITHER_SKELETON, 1315860, 4672845, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item WOLF_SPAWN_EGG = register("wolf_spawn_egg", new SpawnEggItem(EntityType.WOLF, 14144467, 13545366, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ZOGLIN_SPAWN_EGG = register("zoglin_spawn_egg", new SpawnEggItem(EntityType.ZOGLIN, 13004373, 15132390, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ZOMBIE_SPAWN_EGG = register("zombie_spawn_egg", new SpawnEggItem(EntityType.ZOMBIE, 44975, 7969893, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ZOMBIE_HORSE_SPAWN_EGG = register("zombie_horse_spawn_egg", new SpawnEggItem(EntityType.ZOMBIE_HORSE, 3232308, 9945732, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ZOMBIE_VILLAGER_SPAWN_EGG = register("zombie_villager_spawn_egg", new SpawnEggItem(EntityType.ZOMBIE_VILLAGER, 5651507, 7969893, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ZOMBIFIED_PIGLIN_SPAWN_EGG = register("zombified_piglin_spawn_egg", new SpawnEggItem(EntityType.ZOMBIFIED_PIGLIN, 15373203, 5009705, (new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item EXPERIENCE_BOTTLE = register("experience_bottle", new ExperienceBottleItem((new Item.Properties()).group(ItemGroup.MISC).rarity(Rarity.UNCOMMON)));
    public static final Item FIRE_CHARGE = register("fire_charge", new FireChargeItem((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item WRITABLE_BOOK = register("writable_book", new WritableBookItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item WRITTEN_BOOK = register("written_book", new WrittenBookItem((new Item.Properties()).maxStackSize(16)));
    public static final Item EMERALD = register("emerald", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item ITEM_FRAME = register("item_frame", new ItemFrameItem((new Item.Properties()).group(ItemGroup.DECORATIONS)));
    public static final Item FLOWER_POT = register(Blocks.FLOWER_POT, ItemGroup.DECORATIONS);
    public static final Item CARROT = register("carrot", new BlockNamedItem(Blocks.CARROTS, (new Item.Properties()).group(ItemGroup.FOOD).food(Foods.CARROT)));
    public static final Item POTATO = register("potato", new BlockNamedItem(Blocks.POTATOES, (new Item.Properties()).group(ItemGroup.FOOD).food(Foods.POTATO)));
    public static final Item BAKED_POTATO = register("baked_potato", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.BAKED_POTATO)));
    public static final Item POISONOUS_POTATO = register("poisonous_potato", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.POISONOUS_POTATO)));
    public static final Item MAP = register("map", new MapItem((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item GOLDEN_CARROT = register("golden_carrot", new Item((new Item.Properties()).group(ItemGroup.BREWING).food(Foods.GOLDEN_CARROT)));
    public static final Item SKELETON_SKULL = register(new WallOrFloorItem(Blocks.SKELETON_SKULL, Blocks.SKELETON_WALL_SKULL, (new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.UNCOMMON)));
    public static final Item WITHER_SKELETON_SKULL = register(new WallOrFloorItem(Blocks.WITHER_SKELETON_SKULL, Blocks.WITHER_SKELETON_WALL_SKULL, (new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.UNCOMMON)));
    public static final Item PLAYER_HEAD = register(new SkullItem(Blocks.PLAYER_HEAD, Blocks.PLAYER_WALL_HEAD, (new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.UNCOMMON)));
    public static final Item ZOMBIE_HEAD = register(new WallOrFloorItem(Blocks.ZOMBIE_HEAD, Blocks.ZOMBIE_WALL_HEAD, (new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.UNCOMMON)));
    public static final Item CREEPER_HEAD = register(new WallOrFloorItem(Blocks.CREEPER_HEAD, Blocks.CREEPER_WALL_HEAD, (new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.UNCOMMON)));
    public static final Item DRAGON_HEAD = register(new WallOrFloorItem(Blocks.DRAGON_HEAD, Blocks.DRAGON_WALL_HEAD, (new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.UNCOMMON)));
    public static final Item CARROT_ON_A_STICK = register("carrot_on_a_stick", new OnAStickItem<>((new Item.Properties()).maxDamage(25).group(ItemGroup.TRANSPORTATION), EntityType.PIG, 7));
    public static final Item WARPED_FUNGUS_ON_A_STICK = register("warped_fungus_on_a_stick", new OnAStickItem<>((new Item.Properties()).maxDamage(100).group(ItemGroup.TRANSPORTATION), EntityType.STRIDER, 1));
    public static final Item NETHER_STAR = register("nether_star", new SimpleFoiledItem((new Item.Properties()).group(ItemGroup.MATERIALS).rarity(Rarity.UNCOMMON)));
    public static final Item PUMPKIN_PIE = register("pumpkin_pie", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.PUMPKIN_PIE)));
    public static final Item FIREWORK_ROCKET = register("firework_rocket", new FireworkRocketItem((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item FIREWORK_STAR = register("firework_star", new FireworkStarItem((new Item.Properties()).group(ItemGroup.MISC)));
    public static final Item ENCHANTED_BOOK = register("enchanted_book", new EnchantedBookItem((new Item.Properties()).maxStackSize(1).rarity(Rarity.UNCOMMON)));
    public static final Item NETHER_BRICK = register("nether_brick", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item QUARTZ = register("quartz", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item TNT_MINECART = register("tnt_minecart", new MinecartItem(AbstractMinecartEntity.Type.TNT, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item HOPPER_MINECART = register("hopper_minecart", new MinecartItem(AbstractMinecartEntity.Type.HOPPER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item PRISMARINE_SHARD = register("prismarine_shard", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item PRISMARINE_CRYSTALS = register("prismarine_crystals", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item RABBIT = register("rabbit", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.RABBIT)));
    public static final Item COOKED_RABBIT = register("cooked_rabbit", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_RABBIT)));
    public static final Item RABBIT_STEW = register("rabbit_stew", new SoupItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.FOOD).food(Foods.RABBIT_STEW)));
    public static final Item RABBIT_FOOT = register("rabbit_foot", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item RABBIT_HIDE = register("rabbit_hide", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item ARMOR_STAND = register("armor_stand", new ArmorStandItem((new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item IRON_HORSE_ARMOR = register("iron_horse_armor", new HorseArmorItem(5, "iron", (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item GOLDEN_HORSE_ARMOR = register("golden_horse_armor", new HorseArmorItem(7, "gold", (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item DIAMOND_HORSE_ARMOR = register("diamond_horse_armor", new HorseArmorItem(11, "diamond", (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item LEATHER_HORSE_ARMOR = register("leather_horse_armor", new DyeableHorseArmorItem(3, "leather", (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item LEAD = register("lead", new LeadItem((new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item NAME_TAG = register("name_tag", new NameTagItem((new Item.Properties()).group(ItemGroup.TOOLS)));
    public static final Item COMMAND_BLOCK_MINECART = register("command_block_minecart", new MinecartItem(AbstractMinecartEntity.Type.COMMAND_BLOCK, (new Item.Properties()).maxStackSize(1)));
    public static final Item MUTTON = register("mutton", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.MUTTON)));
    public static final Item COOKED_MUTTON = register("cooked_mutton", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.COOKED_MUTTON)));
    public static final Item WHITE_BANNER = register("white_banner", new BannerItem(Blocks.WHITE_BANNER, Blocks.WHITE_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item ORANGE_BANNER = register("orange_banner", new BannerItem(Blocks.ORANGE_BANNER, Blocks.ORANGE_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item MAGENTA_BANNER = register("magenta_banner", new BannerItem(Blocks.MAGENTA_BANNER, Blocks.MAGENTA_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item LIGHT_BLUE_BANNER = register("light_blue_banner", new BannerItem(Blocks.LIGHT_BLUE_BANNER, Blocks.LIGHT_BLUE_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item YELLOW_BANNER = register("yellow_banner", new BannerItem(Blocks.YELLOW_BANNER, Blocks.YELLOW_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item LIME_BANNER = register("lime_banner", new BannerItem(Blocks.LIME_BANNER, Blocks.LIME_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item PINK_BANNER = register("pink_banner", new BannerItem(Blocks.PINK_BANNER, Blocks.PINK_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item GRAY_BANNER = register("gray_banner", new BannerItem(Blocks.GRAY_BANNER, Blocks.GRAY_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item LIGHT_GRAY_BANNER = register("light_gray_banner", new BannerItem(Blocks.LIGHT_GRAY_BANNER, Blocks.LIGHT_GRAY_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item CYAN_BANNER = register("cyan_banner", new BannerItem(Blocks.CYAN_BANNER, Blocks.CYAN_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item PURPLE_BANNER = register("purple_banner", new BannerItem(Blocks.PURPLE_BANNER, Blocks.PURPLE_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item BLUE_BANNER = register("blue_banner", new BannerItem(Blocks.BLUE_BANNER, Blocks.BLUE_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item BROWN_BANNER = register("brown_banner", new BannerItem(Blocks.BROWN_BANNER, Blocks.BROWN_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item GREEN_BANNER = register("green_banner", new BannerItem(Blocks.GREEN_BANNER, Blocks.GREEN_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item RED_BANNER = register("red_banner", new BannerItem(Blocks.RED_BANNER, Blocks.RED_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item BLACK_BANNER = register("black_banner", new BannerItem(Blocks.BLACK_BANNER, Blocks.BLACK_WALL_BANNER, (new Item.Properties()).maxStackSize(16).group(ItemGroup.DECORATIONS)));
    public static final Item END_CRYSTAL = register("end_crystal", new EnderCrystalItem((new Item.Properties()).group(ItemGroup.DECORATIONS).rarity(Rarity.RARE)));
    public static final Item CHORUS_FRUIT = register("chorus_fruit", new ChorusFruitItem((new Item.Properties()).group(ItemGroup.MATERIALS).food(Foods.CHORUS_FRUIT)));
    public static final Item POPPED_CHORUS_FRUIT = register("popped_chorus_fruit", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BEETROOT = register("beetroot", new Item((new Item.Properties()).group(ItemGroup.FOOD).food(Foods.BEETROOT)));
    public static final Item BEETROOT_SEEDS = register("beetroot_seeds", new BlockNamedItem(Blocks.BEETROOTS, (new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BEETROOT_SOUP = register("beetroot_soup", new SoupItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.FOOD).food(Foods.BEETROOT_SOUP)));
    public static final Item DRAGON_BREATH = register("dragon_breath", new Item((new Item.Properties()).containerItem(GLASS_BOTTLE).group(ItemGroup.BREWING).rarity(Rarity.UNCOMMON)));
    public static final Item SPLASH_POTION = register("splash_potion", new SplashPotionItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.BREWING)));
    public static final Item SPECTRAL_ARROW = register("spectral_arrow", new SpectralArrowItem((new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item TIPPED_ARROW = register("tipped_arrow", new TippedArrowItem((new Item.Properties()).group(ItemGroup.COMBAT)));
    public static final Item LINGERING_POTION = register("lingering_potion", new LingeringPotionItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.BREWING)));
    public static final Item SHIELD = register("shield", new ShieldItem((new Item.Properties()).maxDamage(336).group(ItemGroup.COMBAT)));
    public static final Item ELYTRA = register("elytra", new ElytraItem((new Item.Properties()).maxDamage(432).group(ItemGroup.TRANSPORTATION).rarity(Rarity.UNCOMMON)));
    public static final Item SPRUCE_BOAT = register("spruce_boat", new BoatItem(BoatEntity.Type.SPRUCE, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item BIRCH_BOAT = register("birch_boat", new BoatItem(BoatEntity.Type.BIRCH, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item JUNGLE_BOAT = register("jungle_boat", new BoatItem(BoatEntity.Type.JUNGLE, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item ACACIA_BOAT = register("acacia_boat", new BoatItem(BoatEntity.Type.ACACIA, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item DARK_OAK_BOAT = register("dark_oak_boat", new BoatItem(BoatEntity.Type.DARK_OAK, (new Item.Properties()).maxStackSize(1).group(ItemGroup.TRANSPORTATION)));
    public static final Item TOTEM_OF_UNDYING = register("totem_of_undying", new Item((new Item.Properties()).maxStackSize(1).group(ItemGroup.COMBAT).rarity(Rarity.UNCOMMON)));
    public static final Item SHULKER_SHELL = register("shulker_shell", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item IRON_NUGGET = register("iron_nugget", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item KNOWLEDGE_BOOK = register("knowledge_book", new KnowledgeBookItem((new Item.Properties()).maxStackSize(1)));
    public static final Item DEBUG_STICK = register("debug_stick", new DebugStickItem((new Item.Properties()).maxStackSize(1)));
    public static final Item MUSIC_DISC_13 = register("music_disc_13", new MusicDiscItem(1, SoundEvents.MUSIC_DISC_13, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_CAT = register("music_disc_cat", new MusicDiscItem(2, SoundEvents.MUSIC_DISC_CAT, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_BLOCKS = register("music_disc_blocks", new MusicDiscItem(3, SoundEvents.MUSIC_DISC_BLOCKS, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_CHIRP = register("music_disc_chirp", new MusicDiscItem(4, SoundEvents.MUSIC_DISC_CHIRP, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_FAR = register("music_disc_far", new MusicDiscItem(5, SoundEvents.MUSIC_DISC_FAR, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_MALL = register("music_disc_mall", new MusicDiscItem(6, SoundEvents.MUSIC_DISC_MALL, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_MELLOHI = register("music_disc_mellohi", new MusicDiscItem(7, SoundEvents.MUSIC_DISC_MELLOHI, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_STAL = register("music_disc_stal", new MusicDiscItem(8, SoundEvents.MUSIC_DISC_STAL, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_STRAD = register("music_disc_strad", new MusicDiscItem(9, SoundEvents.MUSIC_DISC_STRAD, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_WARD = register("music_disc_ward", new MusicDiscItem(10, SoundEvents.MUSIC_DISC_WARD, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_11 = register("music_disc_11", new MusicDiscItem(11, SoundEvents.MUSIC_DISC_11, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_WAIT = register("music_disc_wait", new MusicDiscItem(12, SoundEvents.MUSIC_DISC_WAIT, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item MUSIC_DISC_PIGSTEP = register("music_disc_pigstep", new MusicDiscItem(13, SoundEvents.MUSIC_DISC_PIGSTEP, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.RARE)));
    public static final Item TRIDENT = register("trident", new TridentItem((new Item.Properties()).maxDamage(250).group(ItemGroup.COMBAT)));
    public static final Item PHANTOM_MEMBRANE = register("phantom_membrane", new Item((new Item.Properties()).group(ItemGroup.BREWING)));
    public static final Item NAUTILUS_SHELL = register("nautilus_shell", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item HEART_OF_THE_SEA = register("heart_of_the_sea", new Item((new Item.Properties()).group(ItemGroup.MATERIALS).rarity(Rarity.UNCOMMON)));
    public static final Item CROSSBOW = register("crossbow", new CrossbowItem((new Item.Properties()).maxStackSize(1).group(ItemGroup.COMBAT).maxDamage(326)));
    public static final Item SUSPICIOUS_STEW = register("suspicious_stew", new SuspiciousStewItem((new Item.Properties()).maxStackSize(1).food(Foods.SUSPICIOUS_STEW)));
    public static final Item LOOM = register(Blocks.LOOM, ItemGroup.DECORATIONS);
    public static final Item FLOWER_BANNER_PATTERN = register("flower_banner_pattern", new BannerPatternItem(BannerPattern.FLOWER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item CREEPER_BANNER_PATTERN = register("creeper_banner_pattern", new BannerPatternItem(BannerPattern.CREEPER, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.UNCOMMON)));
    public static final Item SKULL_BANNER_PATTERN = register("skull_banner_pattern", new BannerPatternItem(BannerPattern.SKULL, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.UNCOMMON)));
    public static final Item MOJANG_BANNER_PATTERN = register("mojang_banner_pattern", new BannerPatternItem(BannerPattern.MOJANG, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC).rarity(Rarity.EPIC)));
    public static final Item GLOBE_BANNER_PATTERN = register("globe_banner_pattern", new BannerPatternItem(BannerPattern.GLOBE, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item PIGLIN_BANNER_PATTERN = register("piglin_banner_pattern", new BannerPatternItem(BannerPattern.PIGLIN, (new Item.Properties()).maxStackSize(1).group(ItemGroup.MISC)));
    public static final Item COMPOSTER = register(Blocks.COMPOSTER, ItemGroup.DECORATIONS);
    public static final Item BARREL = register(Blocks.BARREL, ItemGroup.DECORATIONS);
    public static final Item SMOKER = register(Blocks.SMOKER, ItemGroup.DECORATIONS);
    public static final Item BLAST_FURNACE = register(Blocks.BLAST_FURNACE, ItemGroup.DECORATIONS);
    public static final Item CARTOGRAPHY_TABLE = register(Blocks.CARTOGRAPHY_TABLE, ItemGroup.DECORATIONS);
    public static final Item FLETCHING_TABLE = register(Blocks.FLETCHING_TABLE, ItemGroup.DECORATIONS);
    public static final Item GRINDSTONE = register(Blocks.GRINDSTONE, ItemGroup.DECORATIONS);
    public static final Item LECTERN = register(Blocks.LECTERN, ItemGroup.REDSTONE);
    public static final Item SMITHING_TABLE = register(Blocks.SMITHING_TABLE, ItemGroup.DECORATIONS);
    public static final Item STONECUTTER = register(Blocks.STONECUTTER, ItemGroup.DECORATIONS);
    public static final Item BELL = register(Blocks.BELL, ItemGroup.DECORATIONS);
    public static final Item LANTERN = register(Blocks.LANTERN, ItemGroup.DECORATIONS);
    public static final Item SOUL_LANTERN = register(Blocks.SOUL_LANTERN, ItemGroup.DECORATIONS);
    public static final Item SWEET_BERRIES = register("sweet_berries", new BlockNamedItem(Blocks.SWEET_BERRY_BUSH, (new Item.Properties()).group(ItemGroup.FOOD).food(Foods.SWEET_BERRIES)));
    public static final Item CAMPFIRE = register(Blocks.CAMPFIRE, ItemGroup.DECORATIONS);
    public static final Item SOUL_CAMPFIRE = register(Blocks.SOUL_CAMPFIRE, ItemGroup.DECORATIONS);
    public static final Item SHROOMLIGHT = register(Blocks.SHROOMLIGHT, ItemGroup.DECORATIONS);
    public static final Item HONEYCOMB = register("honeycomb", new Item((new Item.Properties()).group(ItemGroup.MATERIALS)));
    public static final Item BEE_NEST = register(Blocks.BEE_NEST, ItemGroup.DECORATIONS);
    public static final Item BEEHIVE = register(Blocks.BEEHIVE, ItemGroup.DECORATIONS);
    public static final Item HONEY_BOTTLE = register("honey_bottle", new HoneyBottleItem((new Item.Properties()).containerItem(GLASS_BOTTLE).food(Foods.HONEY).group(ItemGroup.FOOD).maxStackSize(16)));
    public static final Item HONEY_BLOCK = register(Blocks.HONEY_BLOCK, ItemGroup.DECORATIONS);
    public static final Item HONEYCOMB_BLOCK = register(Blocks.HONEYCOMB_BLOCK, ItemGroup.DECORATIONS);
    public static final Item LODESTONE = register(Blocks.LODESTONE, ItemGroup.DECORATIONS);
    public static final Item NETHERITE_BRICKS = register(new BlockItem(Blocks.NETHERITE_BLOCK, (new Item.Properties()).group(ItemGroup.BUILDING_BLOCKS).isImmuneToFire()));
    public static final Item ANCIENT_DEBRIS = register(new BlockItem(Blocks.ANCIENT_DEBRIS, (new Item.Properties()).group(ItemGroup.BUILDING_BLOCKS).isImmuneToFire()));
    public static final Item TARGET = register(Blocks.TARGET, ItemGroup.REDSTONE);
    public static final Item CRYING_OBSIDIAN = register(Blocks.CRYING_OBSIDIAN, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACKSTONE = register(Blocks.BLACKSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACKSTONE_SLAB = register(Blocks.BLACKSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item BLACKSTONE_STAIRS = register(Blocks.BLACKSTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item GILDED_BLACKSTONE = register(Blocks.GILDED_BLACKSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BLACKSTONE = register(Blocks.POLISHED_BLACKSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BLACKSTONE_SLAB = register(Blocks.POLISHED_BLACKSTONE_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BLACKSTONE_STAIRS = register(Blocks.POLISHED_BLACKSTONE_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CHISELED_POLISHED_BLACKSTONE = register(Blocks.CHISELED_POLISHED_BLACKSTONE, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BLACKSTONE_BRICKS = register(Blocks.POLISHED_BLACKSTONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BLACKSTONE_BRICK_SLAB = register(Blocks.POLISHED_BLACKSTONE_BRICK_SLAB, ItemGroup.BUILDING_BLOCKS);
    public static final Item POLISHED_BLACKSTONE_BRICK_STAIRS = register(Blocks.POLISHED_BLACKSTONE_BRICK_STAIRS, ItemGroup.BUILDING_BLOCKS);
    public static final Item CRACKED_POLISHED_BLACKSTONE_BRICKS = register(Blocks.CRACKED_POLISHED_BLACKSTONE_BRICKS, ItemGroup.BUILDING_BLOCKS);
    public static final Item RESPAWN_ANCHOR = register(Blocks.RESPAWN_ANCHOR, ItemGroup.DECORATIONS);

    private static Item register(Block blockIn)
    {
        return register(new BlockItem(blockIn, new Item.Properties()));
    }

    private static Item register(Block blockIn, ItemGroup itemGroupIn)
    {
        return register(new BlockItem(blockIn, (new Item.Properties()).group(itemGroupIn)));
    }

    private static Item register(BlockItem blockItemIn)
    {
        return register(blockItemIn.getBlock(), blockItemIn);
    }

    protected static Item register(Block blockIn, Item itemIn)
    {
        return register(Registry.BLOCK.getKey(blockIn), itemIn);
    }

    private static Item register(String key, Item itemIn)
    {
        return register(new ResourceLocation(key), itemIn);
    }

    private static Item register(ResourceLocation key, Item itemIn)
    {
        if (itemIn instanceof BlockItem)
        {
            ((BlockItem)itemIn).addToBlockToItemMap(Item.BLOCK_TO_ITEM, itemIn);
        }

        return Registry.register(Registry.ITEM, key, itemIn);
    }
}

Event:
package arctic.tech.events;

public class Event {

    public boolean isCancel;

    public boolean isCancel() {
        return isCancel;
    }

    public void setCancel(boolean cancel) {
        this.isCancel = cancel;
    }
}

EventManager:
package arctic.tech.events;

import net.minecraft.client.Minecraft;
import arctic.tech.managment.Managment;
import arctic.tech.modules.Function;
import arctic.tech.util.ClientUtil;

public class EventManager {

    /**
     * Вызывает событие и передает его всем активным модулям для обработки.
     *
     * @param event событие для вызова.
     */
    public static void call(final Event event) {
        if (Minecraft.getInstance().player == null || Minecraft.getInstance().world == null) {
            return;
        }

        if (event.isCancel()) {
            return;
        }

        // Перебор всех активных модулей и вызов события
        if (!ClientUtil.legitMode) {
            callEvent(event);
        }
    }

    /**
     * Вызывает указанное событие и передает его всем активным модулям для обработки.
     *
     * @param event событие для вызова.
     */
    private static void callEvent(Event event) {
        for (final Function module : Managment.FUNCTION_MANAGER.getFunctions()) {
            if (!module.isState())
                continue;

            module.onEvent(event);
        }
    }
}

EventDestoyBlock:
package arctic.tech.events.impl.game;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 01.07.2023
 */
public class EventDestroyBlock extends Event {
}

EventKey:
package arctic.tech.events.impl.game;

import arctic.tech.events.Event;

public class EventKey extends Event {

    public int key;

    public EventKey(int key) {
        this.key = key;
    }
}

EventMouseTick:
package arctic.tech.events.impl.game;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventMouseTick extends Event {

    private int button;
}

EventPacket:
package arctic.tech.events.impl.packet;

import arctic.tech.events.Event;
import net.minecraft.network.IPacket;

public class EventPacket extends Event {

    private IPacket packet;

    private final PacketType packetType;

    public EventPacket(IPacket packet, PacketType packetType) {
        this.packet = packet;
        this.packetType = packetType;
    }

    public IPacket getPacket() {
        return packet;
    }

    public void setPacket(IPacket packet) {
        this.packet = packet;
    }

    public boolean isReceivePacket() {
        return this.packetType == PacketType.RECEIVE;
    }

    public boolean isSendPacket() {
        return this.packetType == PacketType.SEND;
    }

    public enum PacketType {
        SEND, RECEIVE
    }
}

EventAction:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventAction extends Event {
    private boolean sprintState;
}

EventCalculateCooldown:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.minecraft.item.Item;

/**
 * @author dedinside
 * @since 09.06.2023
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class EventCalculateCooldown extends Event {

    public Item itemStack;
    public float cooldown;

    public EventCalculateCooldown(Item item) {
        this.itemStack = item;
    }
}

EventCloseWindow:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventCloseWindow extends Event {
}

EventEatGoldenApple:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 09.06.2023
 */
public class EventEatGoldenApple extends Event {
}

EventDamage:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 22.07.2023
 */
public class EventDamage extends Event {
    private final DamageType damageType;

    public EventDamage(DamageType damageType) {
        this.damageType = damageType;
    }

    public DamageType getDamageType() {
        return this.damageType;
    }

    public enum DamageType {
        FALL,
        ARROW,
        ENDER_PEARL;
    }
}

EventInput:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class EventInput extends Event {
    private float forward, strafe;
    private boolean jump, sneak;
    private double sneakSlowDownMultiplier;



}

EventInteractEntity:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.minecraft.entity.Entity;

/**
 * @author dedinside
 * @since 24.06.2023
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventInteractEntity extends Event {
    private Entity entity;

}

EventJump:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 08.06.2023
 */
public class EventJump extends Event {
}

EventLivingTick:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventLivingTick extends Event {

    public boolean isCrouch;
}

EventLiquidSolid:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import net.minecraft.block.FlowingFluidBlock;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.shapes.VoxelShape;
import net.minecraft.util.math.shapes.VoxelShapes;


/**
 * @author dedinside
 * @since 09.06.2023
 */
public class EventLiquidSolid extends Event {
    private final FlowingFluidBlock blockLiquid;
    private final BlockPos pos;
    private VoxelShape collision;

    public EventLiquidSolid(FlowingFluidBlock blockLiquid, BlockPos pos) {
        this.blockLiquid = blockLiquid;
        this.pos = pos;
        this.collision = VoxelShapes.empty();
    }

    public FlowingFluidBlock getBlock() {
        return blockLiquid;
    }

    public BlockPos getPos() {
        return pos;
    }

    public VoxelShape getCollision() {
        return collision;
    }

    public void setCollision(VoxelShape collision) {
        this.collision = collision;
    }
}

EventLivingUpdate:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 19.06.2023
 */
public class EventLivingUpdate extends Event {
}

EventModelRender:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import net.minecraft.client.renderer.entity.PlayerRenderer;

public class EventModelRender extends Event {

    public PlayerRenderer renderer;
    private Runnable entityRenderer;

    public EventModelRender(PlayerRenderer renderer, Runnable entityRenderer) {
        this.renderer = renderer;
        this.entityRenderer = entityRenderer;
    }

    public void render() {
        entityRenderer.run();
    }

}

EventMotion:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;

import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventMotion extends Event {
    private double x, y, z;
    private float yaw, pitch;
    private boolean onGround;
}

EventMove:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.vector.Vector3d;

public class EventMove extends Event {
    public Vector3d from, to, motion;
    private boolean toGround;
    private AxisAlignedBB aabbFrom;
    public boolean ignoreHorizontal, ignoreVertical, collidedHorizontal, collidedVertical;

    public EventMove(Vector3d from, Vector3d to, Vector3d motion,boolean toGround,
                     boolean isCollidedHorizontal, boolean isCollidedVertical, AxisAlignedBB aabbFrom) {
        this.from = from;
        this.to = to;
        this.motion = motion;
        this.toGround = toGround;
        this.collidedHorizontal = isCollidedHorizontal;
        this.collidedVertical = isCollidedVertical;
        this.aabbFrom = aabbFrom;
    }

    public void setIgnoreHorizontalCollision() {
        this.ignoreHorizontal = true;
    }

    public void setIgnoreVerticalCollision() {
        this.ignoreVertical = true;
    }

    public boolean isIgnoreHorizontal() {
        return this.ignoreHorizontal;
    }

    public AxisAlignedBB getAABBFrom() {
        return this.aabbFrom;
    }

    public boolean isIgnoreVertical() {
        return this.ignoreVertical;
    }

    public boolean isCollidedHorizontal() {
        return this.collidedHorizontal;
    }

    public boolean isCollidedVertical() {
        return this.collidedVertical;
    }

    public boolean toGround() {
        return this.toGround;
    }

    public Vector3d from() {
        return this.from;
    }

    public Vector3d to() {
        return this.to;
    }

    public Vector3d motion() {
        return this.motion;
    }

}

EventNoSlow:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 07.06.2023
 */
public class EventNoSlow extends Event {
}

EventObsidianPlace:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.minecraft.block.Block;
import net.minecraft.util.math.BlockPos;

/**
 * @author dedinside
 * @since 07.06.2023
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventObsidianPlace extends Event {

    private final Block block;
    private final BlockPos pos;

}

EventOverlaysRender:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * @author dedinside
 * @since 09.06.2023
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventOverlaysRender extends Event {

    private final OverlayType overlayType;

    public enum OverlayType {
        FIRE_OVERLAY, BOSS_LINE, SCOREBOARD, TITLES, TOTEM, FOG
    }
}

EventPlaceAnchorByPlayer:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.minecraft.block.Block;
import net.minecraft.util.math.BlockPos;

/**
 * @author dedinside
 * @since 06.06.2023
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventPlaceAnchorByPlayer extends Event {

    private final Block block;
    private final BlockPos pos;

}

EventRotation:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventRotation extends Event {

    public float yaw,pitch;

    public EventRotation(float yaw, float pitch) {
        this.yaw = yaw;
        this.pitch = pitch;
    }

}

EventPostMove:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventPostMove extends Event {
    private double horizontalMove;
}

EventStep:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventStep extends Event {

    public float stepHeight;

    public EventStep(float stepHeight) {
        this.stepHeight = stepHeight;
    }

}

EventStrafe:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventStrafe extends Event {

    public float yaw;

    public EventStrafe(float yaw) {
        this.yaw = yaw;
    }

}

EventTeleport:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.minecraft.network.play.client.CPlayerPacket;

/**
 * @author dedinside
 * @since 16.06.2023
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
public class EventTeleport extends Event {

    private CPlayerPacket response;

    public double posX, posY, posZ;
    public float yaw, pitch;

}

EventTravel:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventTravel extends Event {

    public float speed;

    public EventTravel(float speed) {
        this.speed = speed;
    }

}

EventUpdate:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventUpdate extends Event {
}

EventWindowClick:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;
import net.minecraft.inventory.container.ClickType;

public class EventWindowClick extends Event {
    private final int windowId;
    private final int slot;
    private final int button;
    private final ClickType clickType;
    private final ClickStage clickStage;

    public EventWindowClick(ClickStage clickStage, int windowId, int slot, int button, ClickType clickType) {
        this.clickStage = clickStage;
        this.windowId = windowId;
        this.slot = slot;
        this.button = button;
        this.clickType = clickType;
    }


    public int getWindowId() {
        return this.windowId;
    }

    public int getSlot() {
        return this.slot;
    }

    public int getButton() {
        return this.button;
    }

    public ClickType getClickType() {
        return this.clickType;
    }

    public ClickStage getClickStage() {
        return this.clickStage;
    }

    public enum ClickStage {
        PRE, POST
    }
}

EventWorldChange:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

public class EventWorldChange extends Event {
}

StartFallFlyingEvent:
package arctic.tech.events.impl.player;

import arctic.tech.events.Event;

/**
 * @author dedinside
 * @since 11.06.2023
 */
public class StartFallFlyingEvent extends Event {
}

EventRender:
package arctic.tech.events.impl.render;


import arctic.tech.events.Event;
import com.mojang.blaze3d.matrix.MatrixStack;
import net.minecraft.client.MainWindow;
import net.minecraft.util.math.vector.Matrix4f;

public class EventRender extends Event {
    public float partialTicks;
    public MainWindow scaledResolution;
    public Type type;
    public MatrixStack matrixStack;
    public Matrix4f matrix;


    public EventRender(float partialTicks, MatrixStack stack, MainWindow scaledResolution, Type type,Matrix4f matrix) {
        this.partialTicks = partialTicks;
        this.scaledResolution = scaledResolution;
        this.matrixStack = stack;
        this.type = type;
        this.matrix = matrix;
    }

    public boolean isRender3D() {
        return this.type == Type.RENDER3D;
    }

    public boolean isRender2D() {
        return this.type == Type.RENDER2D;
    }

    public enum Type {
        RENDER3D, RENDER2D
    }
}

InventoryUtil:
package arctic.tech.util.world;

import arctic.tech.events.impl.player.EventWindowClick;
import arctic.tech.util.IMinecraft;
import net.minecraft.inventory.container.ClickType;
import net.minecraft.item.*;
import net.minecraft.network.play.client.CEntityActionPacket;

public class InventoryUtil implements IMinecraft {

    public static int getHotBarSlot(Item input) {
        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() == input) {
                return i;
            }
        }
        return -1;
    }
    public static int getFireWorks() {
        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() instanceof FireworkRocketItem) {
                return i;
            }
        }
        return -1;
    }

    public static int getTrident() {
        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() instanceof TridentItem) {
                return i;
            }
        }
        return -1;
    }

    public static int getItem(Item item, boolean hotbar) {
        for (int i = 0; i < (hotbar ? 9 : 45); ++i) {
            if (mc.player.inventory.getStackInSlot(i).getItem() == item) {
                return i;
            }
        }
        return -1;
    }

    public static int getSlotInHotBar(Item item) {
        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() == item) {
                return i;
            }
        }
        return -1;
    }

    public static int getItemSlot(Item input) {
        for (ItemStack stack : mc.player.getArmorInventoryList()) {
            if (stack.getItem() == input) {
                return -2;
            }
        }
        int slot = -1;
        for (int i = 0; i < 36; i++) {
            ItemStack s = mc.player.inventory.getStackInSlot(i);
            if (s.getItem() == input) {
                slot = i;
                break;
            }
        }
        if (slot < 9 && slot != -1) {
            slot = slot + 36;
        }
        return slot;
    }

    public static int getItemSlot(ItemStack input) {
        for (ItemStack stack : mc.player.getArmorInventoryList()) {
            if (stack == input) {
                return -2;
            }
        }
        int slot = -1;
        for (int i = 0; i < 36; i++) {
            ItemStack s = mc.player.inventory.getStackInSlot(i);
            if (s == input) {
                slot = i;
                break;
            }
        }
        if (slot < 9 && slot != -1) {
            slot = slot + 36;
        }
        return slot;
    }
    public static void handleItemTransfer() {
        int emptySlot;

        if (mc.player.inventory.getItemStack().getItem() != Items.AIR && (emptySlot = findEmptySlot(false)) != -1) {
            mc.playerController.windowClick(0, emptySlot, 0, ClickType.PICKUP, mc.player);
        }

        mc.player.closeScreen();
    }
    public static void handleClick(EventWindowClick windowClick) {

        boolean isSneaking = mc.player.isSneaking();
        if (windowClick.getClickStage() == EventWindowClick.ClickStage.PRE) {
            mc.player.setSprinting(false);
            if (!isSneaking) return;
            mc.player.connection.sendPacket(new CEntityActionPacket(mc.player, CEntityActionPacket.Action.RELEASE_SHIFT_KEY));
        }
        if (windowClick.getClickStage() == EventWindowClick.ClickStage.POST) {
            if (!isSneaking) return;
            mc.player.connection.sendPacket(new CEntityActionPacket(mc.player, CEntityActionPacket.Action.PRESS_SHIFT_KEY));
        }
    }
    public static int findEmptySlot(boolean isStartingFromZero) {
        int start = isStartingFromZero ? 0 : 9;
        int end = isStartingFromZero ? 9 : 45;

        for (int i = start; i < end; ++i) {
            if (!mc.player.inventory.getStackInSlot(i).isEmpty()) {
                continue;
            }

            return i;
        }

        return -1;
    }
    public static void moveItem(int from, int to, boolean air) {

        if (from == to) return;
        pickupItem(from, 0);
        pickupItem(to, 0);
        if (air)
            pickupItem(from, 0);
    }

    public static void pickupItem(int slot, int button) {
        mc.playerController.windowClick(0, slot, button, ClickType.PICKUP, mc.player);
    }

    public static void dropItem(int slot) {
        mc.playerController.windowClick(0, slot, 0, ClickType.THROW, mc.player);
    }

    public static int getAxe(boolean hotBar) {
        int startSlot = hotBar ? 0 : 9;
        int endSlot = hotBar ? 9 : 36;

        for (int i = startSlot; i < endSlot; i++) {
            ItemStack itemStack = mc.player.inventory.getStackInSlot(i);
            if (itemStack.getItem() instanceof AxeItem) {
                return i;
            }
        }

        return -1;
    }

    public static int getPearls() {
        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() instanceof EnderPearlItem) {
                return i;
            }
        }
        return -1;
    }
}

TimerUtil:
package arctic.tech.util.misc;

public class TimerUtil {
    public long lastMS = System.currentTimeMillis();


    public void reset() {
        lastMS = System.currentTimeMillis();
    }

    public boolean hasTimeElapsed(long time, boolean reset) {
        if (System.currentTimeMillis() - lastMS > time) {
            if (reset) reset();
            return true;
        }

        return false;
    }

    public long getLastMS() {
        return this.lastMS;
    }

    public void setLastMC() {
        lastMS = System.currentTimeMillis();
    }

    public boolean hasTimeElapsed(long time) {
        return System.currentTimeMillis() - lastMS > time;
    }

    public long getTime() {
        return System.currentTimeMillis() - lastMS;
    }

    public void setTime(long time) {
        lastMS = time;
    }
}

IMinecraft:
package arctic.tech.util;

import net.minecraft.client.MainWindow;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;

import java.util.ArrayList;
import java.util.List;

public interface IMinecraft {

    Tessellator tessellator = Tessellator.getInstance();
    BufferBuilder buffer = tessellator.getBuffer();
    Minecraft mc = Minecraft.getInstance();
    MainWindow sr = mc.getMainWindow();
    FontRenderer fr = mc.fontRenderer;

    List<Runnable> glow = new ArrayList<>();

    static void update() {
        glow.clear();
    }

    default void setGlow(Runnable runnable) {
        glow.add(runnable);
    }


}

WorldUtil:
package arctic.tech.util.world;

import arctic.tech.util.IMinecraft;
import net.minecraft.block.*;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class WorldUtil implements IMinecraft {

    public static class TotemUtil {
        public static BlockPos getBlock(float distance, Block block) {
            return getSphere(getPlayerPosLocal(), distance, 6, false, true, 0)
                    .stream()
                    .filter(position -> mc.world.getBlockState(position).getBlock() == block)
                    .min(Comparator.comparing(blockPos -> getDistanceOfEntityToBlock(mc.player, blockPos)))
                    .orElse(null);
        }

        public static BlockPos getBlock(float distance) {
            return getSphere(getPlayerPosLocal(), distance, 6, false, true, 0)
                    .stream()
                    .filter(position -> mc.world.getBlockState(position).getBlock() != net.minecraft.block.Blocks.AIR)
                    .min(Comparator.comparing(blockPos -> getDistanceOfEntityToBlock(mc.player, blockPos)))
                    .orElse(null);
        }

        public static BlockPos getBlockFlat(int distance) {

            BlockPos vec = getPlayerPosLocal().add(0,-1,0);

            for (int x = vec.getX() - distance; x <= vec.getX() + distance; x++) {
                for (int z = vec.getX() - distance; z <= vec.getZ() + distance; z++) {
                    if (mc.world.getBlockState(new BlockPos(x, vec.getY(), z)).getBlock() != net.minecraft.block.Blocks.AIR) {
                        return new BlockPos(x, vec.getY(), z);
                    }
                }
            }
            return vec;
        }

        public static List<BlockPos> getSphere(final BlockPos blockPos, final float n, final int n2, final boolean b,
                                               final boolean b2, final int n3) {
            final ArrayList<BlockPos> list = new ArrayList<BlockPos>();
            final int x = blockPos.getX();
            final int y = blockPos.getY();
            final int z = blockPos.getZ();
            for (int n4 = x - (int) n; n4 <= x + n; ++n4) {
                for (int n5 = z - (int) n; n5 <= z + n; ++n5) {
                    for (int n6 = b2 ? (y - (int) n) : y; n6 < (b2 ? (y + n) : ((float) (y + n2))); ++n6) {
                        final double n7 = (x - n4) * (x - n4) + (z - n5) * (z - n5) + (b2 ? ((y - n6) * (y - n6)) : 0);
                        if (n7 < n * n && (!b || n7 >= (n - 1.0f) * (n - 1.0f))) {
                            list.add(new BlockPos(n4, n6 + n3, n5));
                        }
                    }
                }
            }
            return list;
        }

        public static BlockPos getPlayerPosLocal() {
            if (mc.player == null) {
                return BlockPos.ZERO;
            }
            return new BlockPos(Math.floor(mc.player.getPosX()), Math.floor(mc.player.getPosY()), Math.floor(mc.player.getPosZ()));
        }

        public static double getDistanceOfEntityToBlock(final Entity entity, final BlockPos blockPos) {
            return getDistance(entity.getPosX(), entity.getPosY(), entity.getPosZ(), blockPos.getX(), blockPos.getY(), blockPos.getZ());
        }


        public static double getDistance(final double n, final double n2, final double n3, final double n4,
                                         final double n5, final double n6) {
            final double n7 = n - n4;
            final double n8 = n2 - n5;
            final double n9 = n3 - n6;
            return MathHelper.sqrt(n7 * n7 + n8 * n8 + n9 * n9);
        }
    }

    public static class Blocks {
        public static ArrayList<BlockPos> getAllInBox(BlockPos from, BlockPos to) {
            ArrayList<BlockPos> blocks = new ArrayList<BlockPos>();
            BlockPos min = new BlockPos(Math.min(from.getX(), to.getX()), Math.min(from.getY(), to.getY()), Math.min(from.getZ(), to.getZ()));
            BlockPos max = new BlockPos(Math.max(from.getX(), to.getX()), Math.max(from.getY(), to.getY()), Math.max(from.getZ(), to.getZ()));
            for (int x = min.getX(); x <= max.getX(); ++x) {
                for (int y = min.getY(); y <= max.getY(); ++y) {
                    for (int z = min.getZ(); z <= max.getZ(); ++z) {
                        blocks.add(new BlockPos(x, y, z));
                    }
                }
            }
            return blocks;
        }

        public static CopyOnWriteArrayList<BlockPos> getAllInBoxA(BlockPos from, BlockPos to) {
            CopyOnWriteArrayList<BlockPos> blocks = new CopyOnWriteArrayList<BlockPos>();
            BlockPos min = new BlockPos(Math.min(from.getX(), to.getX()), Math.min(from.getY(), to.getY()), Math.min(from.getZ(), to.getZ()));
            BlockPos max = new BlockPos(Math.max(from.getX(), to.getX()), Math.max(from.getY(), to.getY()), Math.max(from.getZ(), to.getZ()));
            for (int x = min.getX(); x <= max.getX(); ++x) {
                for (int y = min.getY(); y <= max.getY(); ++y) {
                    for (int z = min.getZ(); z <= max.getZ(); ++z) {
                        if (mc.world.getBlockState(new BlockPos(x, y, z)).getBlock() == net.minecraft.block.Blocks.AIR) continue;
                            blocks.add(new BlockPos(x, y, z));
                    }
                }
            }
            return blocks;
        }

    }
}

PotionUtil:
package arctic.tech.util.world;

import arctic.tech.util.IMinecraft;
import net.minecraft.block.AirBlock;
import net.minecraft.client.Minecraft;
import net.minecraft.network.play.client.CPlayerTryUseItemPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;

/**
 * @author dedinside
 * @since 07.06.2023
 */
public class PotionUtil implements IMinecraft {
    public static boolean isChangingItem;
    private boolean isItemChangeRequested;
    private int previousSlot = -1;


    public static boolean isBlockAirBelowPlayer(float distance) {
        if (Minecraft.getInstance().player == null) {
            return false;
        }
        BlockPos blockPos = new BlockPos(
                mc.player.getPosX(),
                mc.player.getPosY() - (double) distance,
                mc.player.getPosZ()
        );
        return mc.world.getBlockState(blockPos).getBlock() instanceof AirBlock;
    }

    public void changeItemSlot(boolean resetAfter) {
        if (this.isItemChangeRequested && this.previousSlot != -1) {
            isChangingItem = true;
            mc.player.inventory.currentItem = this.previousSlot;
            if (resetAfter) {
                this.isItemChangeRequested = false;
                this.previousSlot = -1;
                isChangingItem = false;
            }
        }
    }

    public void setPreviousSlot(int slot) {
        this.previousSlot = slot;
    }


    public static void useItem(Hand hand) {
        mc.player.connection.sendPacket(new CPlayerTryUseItemPacket(hand));
        mc.gameRenderer.itemRenderer.resetEquippedProgress(hand);
    }

    public static int calculateHorizontalDistance(long x1, long z1) {
        float deltaX = (float) (mc.player.getPosX() - (double) x1);
        float deltaZ = (float) (mc.player.getPosZ() - (double) z1);
        return (int) MathHelper.sqrt(deltaX * deltaX + deltaZ * deltaZ);
    }

    public static int calculateDistance(long x1, long y1, long z1) {
        float deltaX = (float) (mc.player.getPosX() - (double) x1);
        float deltaY = (float) (mc.player.getPosY() - (double) y1);
        float deltaZ = (float) (mc.player.getPosZ() - (double) z1);
        return (int) MathHelper.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
    }

    public static double calculateDistance(double x1, double y1, double z1, double x2, double y2, double z2) {
        double deltaX = x1 - x2;
        double deltaY = y1 - y2;
        double deltaZ = z1 - z2;
        return MathHelper.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
    }
}

MoveUtil:
package arctic.tech.util.movement;

import arctic.tech.events.impl.player.EventInput;
import arctic.tech.events.impl.player.EventMove;
import arctic.tech.util.FreeCamera;
import arctic.tech.util.IMinecraft;
import net.minecraft.client.entity.player.ClientPlayerEntity;
import net.minecraft.potion.Effects;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;

public class MoveUtil implements IMinecraft {

    public static boolean isMoving() {
        return mc.player.movementInput.moveStrafe != 0.0 || mc.player.movementInput.moveForward != 0.0;
    }
    public static float adjustFloatValue(float value) {
        int ticksExisted = mc.player.ticksExisted;
        return ticksExisted % 2 == 0 ? value - 1.0E-4f : value;
    }
    public static double direction(float rotationYaw, final double moveForward, final double moveStrafing) {
        if (moveForward < 0F) rotationYaw += 180F;

        float forward = 1F;

        if (moveForward < 0F) forward = -0.5F;
        else if (moveForward > 0F) forward = 0.5F;

        if (moveStrafing > 0F) rotationYaw -= 90F * forward;
        if (moveStrafing < 0F) rotationYaw += 90F * forward;

        return Math.toRadians(rotationYaw);
    }

    public static double direction() {
        float rotationYaw = mc.player.rotationYaw;

        if (mc.player.moveForward < 0) {
            rotationYaw += 180;
        }

        float forward = 1;

        if (mc.player.moveForward < 0) {
            forward = -0.5F;
        } else if (mc.player.moveForward > 0) {
            forward = 0.5F;
        }

        if (mc.player.moveStrafing > 0) {
            rotationYaw -= 90 * forward;
        }

        if (mc.player.moveStrafing < 0) {
            rotationYaw += 90 * forward;
        }

        return Math.toRadians(rotationYaw);
    }

    public static void fixMovement(final EventInput event, float yaw) {
        final float forward = event.getForward();
        final float strafe = event.getStrafe();

        final double angle = MathHelper.wrapDegrees(Math.toDegrees(MoveUtil.direction(mc.player.isElytraFlying() ? yaw : mc.player.rotationYaw, forward, strafe)));

        if (forward == 0 && strafe == 0) {
            return;
        }

        float closestForward = 0, closestStrafe = 0, closestDifference = Float.MAX_VALUE;

        for (float predictedForward = -1F; predictedForward <= 1F; predictedForward += 1F) {
            for (float predictedStrafe = -1F; predictedStrafe <= 1F; predictedStrafe += 1F) {
                if (predictedStrafe == 0 && predictedForward == 0) continue;

                final double predictedAngle = MathHelper.wrapDegrees(Math.toDegrees(MoveUtil.direction(yaw, predictedForward, predictedStrafe)));
                final double difference = Math.abs(angle - predictedAngle);

                if (difference < closestDifference) {
                    closestDifference = (float) difference;
                    closestForward = predictedForward;
                    closestStrafe = predictedStrafe;
                }
            }
        }

        event.setForward(closestForward);
        event.setStrafe(closestStrafe);
    }

    public static float getDirection() {
        float rotationYaw = mc.player.rotationYaw;

        float strafeFactor = 0f;

        if (mc.player.movementInput.moveForward > 0)
            strafeFactor = 1;
        if (mc.player.movementInput.moveForward < 0)
            strafeFactor = -1;

        if (strafeFactor == 0) {
            rotationYaw = mc.player.movementInput.moveStrafe > 0 ? -90 : 90;
        } else {
            rotationYaw = mc.player.movementInput.moveStrafe > 0 ? -(45 * strafeFactor) : 45 * strafeFactor;
        }

        if (strafeFactor < 0)
            rotationYaw -= 180;

        return (float) Math.toRadians(rotationYaw);
    }

    public static float getMotion() {
        return (float) Math.sqrt(mc.player.motion.x * mc.player.motion.x + mc.player.motion.z * mc.player.motion.z);
    }

    public static void setMotion(final double motion) {
        double forward = mc.player.movementInput.moveForward;
        double strafe = mc.player.movementInput.moveStrafe;
        float yaw = mc.player.rotationYaw;
        if (forward == 0 && strafe == 0) {
            mc.player.motion.x = 0;
            mc.player.motion.z = 0;
        } else {
            if (forward != 0) {
                if (strafe > 0) {
                    yaw += (float) (forward > 0 ? -45 : 45);
                } else if (strafe < 0) {
                    yaw += (float) (forward > 0 ? 45 : -45);
                }
                strafe = 0;
                if (forward > 0) {
                    forward = 1;
                } else if (forward < 0) {
                    forward = -1;
                }
            }
            mc.player.motion.x = forward * motion * MathHelper.cos(Math.toRadians(yaw + 90.0f))
                    + strafe * motion * MathHelper.sin(Math.toRadians(yaw + 90.0f));
            mc.player.motion.z = forward * motion * MathHelper.sin(Math.toRadians(yaw + 90.0f))
                    - strafe * motion * MathHelper.cos(Math.toRadians(yaw + 90.0f));
        }
    }

    public static void setMotion(final double motion, FreeCamera player) {
        double forward = player.movementInput.moveForward;
        double strafe = player.movementInput.moveStrafe;
        float yaw = player.rotationYaw;
        if (forward == 0 && strafe == 0) {
            player.motion.x = 0;
            player.motion.z = 0;
        } else {
            if (forward != 0) {
                if (strafe > 0) {
                    yaw += (float) (forward > 0 ? -45 : 45);
                } else if (strafe < 0) {
                    yaw += (float) (forward > 0 ? 45 : -45);
                }
                strafe = 0;
                if (forward > 0) {
                    forward = 1;
                } else if (forward < 0) {
                    forward = -1;
                }
            }
            player.motion.x = forward * motion * MathHelper.cos(Math.toRadians(yaw + 90.0f))
                    + strafe * motion * MathHelper.sin(Math.toRadians(yaw + 90.0f));
            player.motion.z = forward * motion * MathHelper.sin(Math.toRadians(yaw + 90.0f))
                    - strafe * motion * MathHelper.cos(Math.toRadians(yaw + 90.0f));
        }
    }

    public static class MoveEvent {
        public static void setMoveMotion(final EventMove move, final double motion) {
            double forward = mc.player.movementInput.moveForward;
            double strafe = mc.player.movementInput.moveStrafe;
            float yaw = mc.player.rotationYaw;
            if (forward == 0 && strafe == 0) {
                move.motion().x = 0;
                move.motion().z = 0;
            } else {
                if (forward != 0) {
                    if (strafe > 0) {
                        yaw += (float) (forward > 0 ? -45 : 45);
                    } else if (strafe < 0) {
                        yaw += (float) (forward > 0 ? 45 : -45);
                    }
                    strafe = 0;
                    if (forward > 0) {
                        forward = 1;
                    } else if (forward < 0) {
                        forward = -1;
                    }
                }
                move.motion().x = forward * motion * MathHelper.cos(Math.toRadians(yaw + 90.0f))
                        + strafe * motion * MathHelper.sin(Math.toRadians(yaw + 90.0f));
                move.motion().z = forward * motion * MathHelper.sin(Math.toRadians(yaw + 90.0f))
                        - strafe * motion * MathHelper.cos(Math.toRadians(yaw + 90.0f));
            }
        }
    }

    public static class StrafeMovement {
        public static double oldSpeed, contextFriction;
        public static boolean needSwap;
        public static boolean needSprintState;
        public static int counter, noSlowTicks;

        public static double    calculateSpeed(final EventMove move, boolean damageBoost, boolean hasTime, float damageSpeed) {

            final boolean fromGround = mc.player.isOnGround();
            final boolean toGround = move.toGround();
            final boolean jump = move.motion().y > 0;
            final float speedAttributes = getAIMoveSpeed(mc.player);
            final float frictionFactor = getFrictionFactor(mc.player, move);
            float n6 = mc.player.isPotionActive(Effects.JUMP_BOOST) && mc.player.isHandActive() ? 0.88f : 0.91F;

            if (fromGround) {
                n6 = frictionFactor;
            }
            final float n7 = 0.16277136f / (n6 * n6 * n6);
            float n8;
            if (fromGround) {
                n8 = speedAttributes * n7;
                if (jump) {
                    n8 += 0.2f;
                }
            } else {
                n8 = (damageBoost && hasTime && mc.gameSettings.keyBindJump.isKeyDown() ? damageSpeed : 0.0255f);
            }
            boolean noslow = false;
            double max2 = oldSpeed + n8;
            double max = 0.0;
            if (mc.player.isHandActive() && !jump) {
                double n10 = oldSpeed + n8 * 0.25;
                double motionY2 = move.motion().y;
                if (motionY2 != 0.0 && Math.abs(motionY2) < 0.08) {
                    n10 += 0.055;
                }
                if (max2 > (max = Math.max(0.043, n10))) {
                    noslow = true;
                    ++noSlowTicks;
                } else {
                    noSlowTicks = Math.max(noSlowTicks - 1, 0);
                }
            } else {
                noSlowTicks = 0;
            }
            if (noSlowTicks > 3) {
                max2 = max - (mc.player.isPotionActive(Effects.JUMP_BOOST) && mc.player.isHandActive() ? 0.3 : 0.019);
            } else {
                max2 = Math.max(noslow ? 0 : 0.25, max2) - (counter++ % 2 == 0 ? 0.001 : 0.002);
            }
            contextFriction = n6;
            if (!toGround && !fromGround) {
                needSwap = true;
            }
            if (!fromGround && !toGround) {
                needSprintState = !mc.player.serverSprintState;
            }
            if (toGround && fromGround) {
                needSprintState = false;
            }
            return max2;
        }

        public static void postMove(final double horizontal) {
            oldSpeed = horizontal * contextFriction;
        }

        public static float getAIMoveSpeed(final ClientPlayerEntity contextPlayer) {
            boolean prevSprinting = contextPlayer.isSprinting();
            contextPlayer.setSprinting(false);
            float speed = contextPlayer.getAIMoveSpeed() * 1.3f;
            contextPlayer.setSprinting(prevSprinting);
            return speed;
        }


        private static float getFrictionFactor(final ClientPlayerEntity contextPlayer, final EventMove move) {
            BlockPos.Mutable blockpos$mutable = new BlockPos.Mutable();
            blockpos$mutable.setPos(move.from().x, move.getAABBFrom().minY - 1.0D, move.from().z);

            return contextPlayer.world.getBlockState(blockpos$mutable).getBlock().slipperiness * 0.91F;
        }
    }
}

RayTraceUtil:
package arctic.tech.util.math;

import arctic.tech.util.IMinecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.projectile.ProjectileHelper;
import net.minecraft.util.Direction;
import net.minecraft.util.math.*;
import net.minecraft.util.math.vector.Vector3d;
import net.minecraft.world.World;

import java.util.Optional;
import java.util.function.Predicate;

public class RayTraceUtil implements IMinecraft {


    /**
     * Майнкрафт метод :/
     * Получает сущность на которую направлена ротация
     *
     * @param target   цель, с которой осуществляется взаимодействие
     * @param yaw      горизонтальный угол обзора
     * @param pitch    вертикальный угол обзора
     * @param distance максимальное расстояние
     * @return сущность, на которую направлена ротация, или null, если такой сущности нет
     */
    public static Entity getMouseOver(Entity target,
                                      float yaw,
                                      float pitch,
                                      double distance) {
        RayTraceResult objectMouseOver;
        Entity entity = mc.getRenderViewEntity();

        if (entity != null && mc.world != null) {
            objectMouseOver = null;
            boolean flag = distance > 3;

            Vector3d startVec = entity.getEyePosition(1);
            Vector3d directionVec = getVectorForRotation(pitch, yaw);
            Vector3d endVec = startVec.add(
                    directionVec.x * distance,
                    directionVec.y * distance,
                    directionVec.z * distance
            );

            AxisAlignedBB axisalignedbb = target.getBoundingBox().grow(target.getCollisionBorderSize());

            EntityRayTraceResult entityraytraceresult = rayTraceEntities(entity,
                    startVec,
                    endVec,
                    axisalignedbb,
                    (p_lambda$getMouseOver$0_0_) ->
                            !p_lambda$getMouseOver$0_0_.isSpectator()
                                    && p_lambda$getMouseOver$0_0_.canBeCollidedWith(), distance
            );

            if (entityraytraceresult != null) {
                if (flag && startVec.distanceTo(startVec) > distance) {
                    objectMouseOver = BlockRayTraceResult.createMiss(startVec, null, new BlockPos(startVec));
                }
                if ((distance < distance || objectMouseOver == null)) {
                    objectMouseOver = entityraytraceresult;
                }
            }
            if (objectMouseOver == null) {
                return null;
            }
            try {
                return ((EntityRayTraceResult) objectMouseOver).getEntity();
            } catch (ClassCastException e) {
                return null;
            }
        }
        return null;
    }

    /**
     * Тоже майнкрафт метод :/
     * Выполняет трассировку луча между сущностями
     *
     * @param shooter     сущность, инициировавшая трассировку
     * @param startVec    начальная точка трассировки
     * @param endVec      конечная точка трассировки
     * @param boundingBox ограничивающий параллелепипед для поиска сущностей
     * @param filter      предикат для фильтрации сущностей
     * @param distance    максимальное расстояние трассировки
     * @return результат трассировки луча между сущностями или null, если сущностей не найдено
     */
    public static EntityRayTraceResult rayTraceEntities(Entity shooter,
                                                        Vector3d startVec,
                                                        Vector3d endVec,
                                                        AxisAlignedBB boundingBox,
                                                        Predicate<Entity> filter,
                                                        double distance) {
        World world = shooter.world;
        double closestDistance = distance;
        Entity entity = null;
        Vector3d closestHitVec = null;

        for (Entity entity1 : world.getEntitiesInAABBexcluding(shooter, boundingBox, filter)) {
            AxisAlignedBB axisalignedbb = entity1.getBoundingBox().grow((double) entity1.getCollisionBorderSize());
            Optional<Vector3d> optional = axisalignedbb.rayTrace(startVec, endVec);

            if (axisalignedbb.contains(startVec)) {
                if (closestDistance >= 0.0D) {
                    entity = entity1;
                    closestHitVec = startVec;
                    closestDistance = 0.0D;
                }
            } else if (optional.isPresent()) {
                Vector3d vector3d1 = optional.get();
                double d3 = startVec.distanceTo(optional.get());

                if (d3 < closestDistance || closestDistance == 0.0D) {
                    boolean flag1 = false;

                    if (!flag1 && entity1.getLowestRidingEntity() == shooter.getLowestRidingEntity()) {
                        if (closestDistance == 0.0D) {
                            entity = entity1;
                            closestHitVec = vector3d1;
                        }
                    } else {
                        entity = entity1;
                        closestHitVec = vector3d1;
                        closestDistance = d3;
                    }
                }
            }
        }

        return entity == null ? null : new EntityRayTraceResult(entity, closestHitVec);
    }

    /**
     * Выполняет трассировку луча и возвращает результат.
     *
     * @param rayTraceDistance дальность трассировки луча
     * @param yaw              горизонтальный угол обзора
     * @param pitch            вертикальный угол обзора
     * @param entity           сущность, для которой выполняется трассировка луча
     * @return результат трассировки луча в игровом мире
     */
    public static RayTraceResult rayTrace(double rayTraceDistance,
                                          float yaw,
                                          float pitch,
                                          Entity entity) {
        Vector3d startVec = mc.player.getEyePosition(1.0F);
        Vector3d directionVec = getVectorForRotation(pitch, yaw);
        Vector3d endVec = startVec.add(
                directionVec.x * rayTraceDistance,
                directionVec.y * rayTraceDistance,
                directionVec.z * rayTraceDistance
        );

        return mc.world.rayTraceBlocks(new RayTraceContext(
                startVec,
                endVec,
                RayTraceContext.BlockMode.OUTLINE,
                RayTraceContext.FluidMode.NONE,
                entity)
        );
    }


    public static RayTraceResult rayTraceResult(double rayTraceDistance,
                                                float yaw,
                                                float pitch,
                                                Entity entity) {

        RayTraceResult object = null;

        if (entity != null && mc.world != null) {
            float partialTicks = mc.getRenderPartialTicks();
            double distance = rayTraceDistance;
            object = rayTrace(rayTraceDistance, yaw, pitch, entity);
            Vector3d vector3d = entity.getEyePosition(partialTicks);
            boolean flag = false;
            double d1 = distance;

            if (mc.playerController.extendedReach()) {
                d1 = 6.0D;
                distance = d1;
            } else {
                if (distance > 3.0D) {
                    flag = true;
                }

                distance = distance;
            }

            d1 = d1 * d1;

            if (object != null) {
                d1 = object.getHitVec().squareDistanceTo(vector3d);
            }

            Vector3d vector3d1 = getVectorForRotation(pitch, yaw);
            Vector3d vector3d2 = vector3d.add(vector3d1.x * distance, vector3d1.y * distance, vector3d1.z * distance);
            float f = 1.0F;
            AxisAlignedBB axisalignedbb = entity.getBoundingBox().expand(vector3d1.scale(distance)).grow(1.0D, 1.0D, 1.0D);
            EntityRayTraceResult entityraytraceresult = ProjectileHelper.rayTraceEntities(entity, vector3d, vector3d2, axisalignedbb, (p_lambda$getMouseOver$0_0_) ->
            {
                return !p_lambda$getMouseOver$0_0_.isSpectator() && p_lambda$getMouseOver$0_0_.canBeCollidedWith();
            }, d1);

            if (entityraytraceresult != null) {
                Entity entity1 = entityraytraceresult.getEntity();
                Vector3d vector3d3 = entityraytraceresult.getHitVec();
                double d2 = vector3d.squareDistanceTo(vector3d3);

                if (flag && d2 > 9.0D) {
                    object = BlockRayTraceResult.createMiss(vector3d3, Direction.getFacingFromVector(vector3d1.x, vector3d1.y, vector3d1.z), new BlockPos(vector3d3));
                } else if (d2 < d1 || object == null) {
                    object = entityraytraceresult;
                }
            }
        }
        return object;
    }


    public static boolean rayTraceWithBlock(double rayTraceDistance,
                                            float yaw,
                                            float pitch,
                                            Entity entity, Entity target) {

        RayTraceResult object = null;

        if (entity != null && mc.world != null) {
            float partialTicks = mc.getRenderPartialTicks();
            double distance = rayTraceDistance;
            object = rayTrace(rayTraceDistance, yaw, pitch, entity);
            Vector3d vector3d = entity.getEyePosition(partialTicks);
            boolean flag = false;
            double d1 = distance;

            if (mc.playerController.extendedReach()) {
                d1 = 6.0D;
                distance = d1;
            } else {
                if (distance > 3.0D) {
                    flag = true;
                }

                distance = distance;
            }

            d1 = d1 * d1;

            if (object != null) {
                d1 = object.getHitVec().squareDistanceTo(vector3d);
            }

            Vector3d vector3d1 = getVectorForRotation(pitch, yaw);
            Vector3d vector3d2 = vector3d.add(vector3d1.x * distance, vector3d1.y * distance, vector3d1.z * distance);
            float f = 1.0F;
            AxisAlignedBB axisalignedbb = entity.getBoundingBox().expand(vector3d1.scale(distance)).grow(1.0D, 1.0D, 1.0D);
            EntityRayTraceResult entityraytraceresult = ProjectileHelper.rayTraceEntities(entity, vector3d, vector3d2, axisalignedbb, (p_lambda$getMouseOver$0_0_) ->
            {
                return !p_lambda$getMouseOver$0_0_.isSpectator() && p_lambda$getMouseOver$0_0_.canBeCollidedWith();
            }, d1);

            if (entityraytraceresult != null) {
                Entity entity1 = entityraytraceresult.getEntity();
                Vector3d vector3d3 = entityraytraceresult.getHitVec();
                double d2 = vector3d.squareDistanceTo(vector3d3);

                if (flag && d2 > 9.0D) {
                    object = BlockRayTraceResult.createMiss(vector3d3, Direction.getFacingFromVector(vector3d1.x, vector3d1.y, vector3d1.z), new BlockPos(vector3d3));
                } else if (d2 < d1 || object == null) {
                    object = entityraytraceresult;
                }
            }
        }
        if (object instanceof EntityRayTraceResult) {
            if (((EntityRayTraceResult) object).getEntity().getEntityId() == target.getEntityId()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Возвращает вектор направления в зависимости от заданных углов поворота.
     *
     * @param pitch вертикальный угол поворота
     * @param yaw   горизонтальный угол поворота
     * @return вектор направления
     */
    public static Vector3d getVectorForRotation(float pitch, float yaw) {
        float yawRadians = -yaw * ((float) Math.PI / 180) - (float) Math.PI;
        float pitchRadians = -pitch * ((float) Math.PI / 180);

        float cosYaw = MathHelper.cos(yawRadians);
        float sinYaw = MathHelper.sin(yawRadians);
        float cosPitch = -MathHelper.cos(pitchRadians);
        float sinPitch = MathHelper.sin(pitchRadians);

        return new Vector3d(sinYaw * cosPitch, sinPitch, cosYaw * cosPitch);
    }

}

PlayerPositionTracker:
package arctic.tech.util.math;

import arctic.tech.util.IMinecraft;
import arctic.tech.util.glu.GLU;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.vector.Vector2f;
import net.minecraft.util.math.vector.Vector3d;
import org.joml.Vector4d;
import org.lwjgl.opengl.GL11;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import static baritone.utils.IRenderer.renderManager;
import static net.minecraft.client.renderer.WorldRenderer.frustum;

/**
 * @author dedinside
 * @since 01.07.2023
 */
public class PlayerPositionTracker implements IMinecraft {
    private final static IntBuffer viewport;
    private final static FloatBuffer modelview;
    private final static FloatBuffer projection;
    private final static FloatBuffer vector;

    static {
        viewport = GLAllocation.createDirectIntBuffer(16);
        modelview = GLAllocation.createDirectFloatBuffer(16);
        projection = GLAllocation.createDirectFloatBuffer(16);
        vector = GLAllocation.createDirectFloatBuffer(4);
    }


    public static boolean isInView(Entity ent) {
        assert mc.getRenderViewEntity() != null;
        frustum.setCameraPosition(mc.getRenderManager().info.getProjectedView().x, mc.getRenderManager().info.getProjectedView().y,mc.getRenderManager().info.getProjectedView().z);
        return frustum.isBoundingBoxInFrustum(ent.getBoundingBox()) || ent.ignoreFrustumCheck;
    }

    public static boolean isInView(Vector3d ent) {
        assert mc.getRenderViewEntity() != null;
        frustum.setCameraPosition(mc.getRenderManager().info.getProjectedView().x, mc.getRenderManager().info.getProjectedView().y,mc.getRenderManager().info.getProjectedView().z);
        return frustum.isBoundingBoxInFrustum(new AxisAlignedBB(ent.add(-0.5,-0.5, -0.5), ent.add(0.5,0.5, 0.5)));
    }

    public static Vector4d updatePlayerPositions(Entity player, float partialTicks) {
        Vector3d projection = mc.getRenderManager().info.getProjectedView();
        double x = MathUtil.interpolate(player.getPosX(), player.lastTickPosX, partialTicks);
        double y = MathUtil.interpolate(player.getPosY(), player.lastTickPosY, partialTicks);
        double z = MathUtil.interpolate(player.getPosZ(), player.lastTickPosZ, partialTicks);

        Vector3d size = new Vector3d(
                player.getBoundingBox().maxX - player.getBoundingBox().minX,
                player.getBoundingBox().maxY - player.getBoundingBox().minY,
                player.getBoundingBox().maxZ - player.getBoundingBox().minZ
        );

        AxisAlignedBB aabb = new AxisAlignedBB(x - size.x / 2f, y, z - size.z / 2f, x + size.x / 2f, y +size.y, z + size.z /2f);

        Vector4d position = null;

        for (int i = 0; i < 8; i++) {
            Vector3d vector = new Vector3d(
                    i % 2 == 0 ? aabb.minX : aabb.maxX,
                    (i / 2) % 2 == 0 ? aabb.minY : aabb.maxY,
                    (i / 4) % 2 == 0 ? aabb.minZ : aabb.maxZ);

            vector = project2D(vector.x - projection.x, vector.y - projection.y, vector.z - projection.z);

            if (vector != null && vector.z >= 0.0 && vector.z < 1.0) {
                if (position == null) {
                    position = new Vector4d(vector.x, vector.y, vector.z, 1.0f);
                } else {
                    position.x = Math.min(vector.x, position.x);
                    position.y = Math.min(vector.y, position.y);
                    position.z = Math.max(vector.x, position.z);
                    position.w = Math.max(vector.y, position.w);
                }
            }
        }

        return position;
    }



    private static final Vector2f entityPos = new Vector2f(Float.MAX_VALUE, Float.MAX_VALUE);

    public static Vector2f getPositionsOn2D(Vector3d pos) {
        float x = (float) (pos.x - renderManager.renderPosX());
        float y = (float) (pos.y - renderManager.renderPosY());
        float z = (float) (pos.z - renderManager.renderPosZ());


        Vector3d vector3f = project2D(x, y, z);
        if (vector3f.z >= 0.0 && vector3f.z < 1.0) {
            return new Vector2f((float) vector3f.x, (float) vector3f.y);
        }

        return new Vector2f(Float.MAX_VALUE, Float.MAX_VALUE);
    }

    private static Vector3d project2D(final double x,
                                      final double y,
                                      final double z) {
        GL11.glGetFloatv(2982, modelview);
        GL11.glGetFloatv(2983, projection);
        GL11.glGetIntegerv(2978, viewport);
        if (GLU.gluProject((float) x, (float) y, (float) z, modelview, projection, viewport, vector)) {
            return new Vector3d(vector.get(0) / 2, (mc.getMainWindow().getHeight() - vector.get(1)) / 2, vector.get(2));
        }
        return null;
    }

}

MathUtil:
package arctic.tech.util.math;

import arctic.tech.util.IMinecraft;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.MainWindow;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.vector.Vector2f;
import net.minecraft.util.math.vector.Vector3d;

import java.math.BigDecimal;
import java.math.RoundingMode;

public class MathUtil implements IMinecraft {

    public static BigDecimal round(float f, int times) {
        BigDecimal bd = new BigDecimal(Float.toString(f));
        bd = bd.setScale(times, RoundingMode.HALF_UP);
        return bd;
    }

    public static double round(double num, double increment) {
        double v = (double) Math.round(num / increment) * increment;
        BigDecimal bd = new BigDecimal(v);
        bd = bd.setScale(2, RoundingMode.HALF_UP);
        return bd.doubleValue();
    }

    public static int calc(final int value) {
        MainWindow mainWindow = mc.getMainWindow();
        return (int) (value * mainWindow.getGuiScaleFactor() / 2);
    }
    public static float calc(final float value) {
        MainWindow mainWindow = mc.getMainWindow();
        return (float) (value * mainWindow.getGuiScaleFactor() / 2);
    }
    public static double calc(final double value) {
        MainWindow mainWindow = mc.getMainWindow();
        return value * mainWindow.getGuiScaleFactor() / 2;
    }

    public static void scaleElements(float xCenter, float yCenter, float scale, Runnable runnable) {
        RenderSystem.pushMatrix();
        RenderSystem.translatef(xCenter, yCenter, 0);
        RenderSystem.scalef(scale, scale, 1);
        RenderSystem.translatef(-xCenter, -yCenter, 0);
        runnable.run();
        RenderSystem.popMatrix();


    }

    public static void scaleElements(float xCenter, float yCenter, float scaleX, float scaleY, float scaleZ, Runnable runnable) {
        RenderSystem.pushMatrix();
        RenderSystem.translatef(xCenter, yCenter, 0);
        RenderSystem.scalef(scaleX, scaleY, scaleZ);
        RenderSystem.translatef(-xCenter, -yCenter, 0);
        runnable.run();
        RenderSystem.popMatrix();
    }

    public static float calculateXPosition(float x, float width) {
        return x - width / 2f;
    }

    public static float calculateYPosition(float y, float height) {
        return y - height / 2;
    }

    public static float calculateDelta(float a, float b) {
        return a - b;
    }

    public static Vector2f rotationToEntity(Entity target) {
        Vector3d vector3d = target.getPositionVec().subtract(Minecraft.getInstance().player.getPositionVec());
        double magnitude = Math.hypot(vector3d.x, vector3d.z);
        return new Vector2f(
                (float) Math.toDegrees(Math.atan2(vector3d.z, vector3d.x)) - 90.0F,
                (float) (-Math.toDegrees(Math.atan2(vector3d.y, magnitude)))
        );
    }

    public static Vector2f rotationToBlock(BlockPos target) {
        return rotationToVec(Vector3d.copyCentered(target));
    }

    public static Vector2f rotationToVec(Vector3d target) {
        Vector3d vector3d = target.subtract(Minecraft.getInstance().player.getPositionVec());
        double magnitude = Math.hypot(vector3d.getX(), vector3d.getZ());
        return new Vector2f(
                (float) Math.toDegrees(Math.atan2(vector3d.getZ(), vector3d.getX())) - 90.0F,
                (float) (-Math.toDegrees(Math.atan2(vector3d.getY(), magnitude)))
        );
    }

    public static double interpolate(double current, double old, double scale) {
        return old + (current - old) * scale;
    }

}

Animation:
package arctic.tech.util.animations;


import arctic.tech.util.misc.TimerUtil;

/**
 * This animation superclass was made by Foggy and advanced by cedo
 *
 * @author Foggy
 * @author cedo
 * @since 7/21/2020 (yes 2020)
 * @since 7/29/2021
 */
public abstract class Animation {

    public TimerUtil timerUtil = new TimerUtil();
    protected int duration;
    protected double endPoint;
    protected Direction direction;

    public Animation(int ms, double endPoint) {
        this.duration = ms;
        this.endPoint = endPoint;
        this.direction = Direction.FORWARDS;
    }


    public Animation(int ms, double endPoint, Direction direction) {
        this.duration = ms; //Time in milliseconds of how long you want the animation to take.
        this.endPoint = endPoint; //The desired distance for the animated object to go.
        this.direction = direction; //Direction in which the graph is going. If backwards, will start from endPoint and go to 0.
    }

    public boolean finished(Direction direction) {
        return isDone() && this.direction.equals(direction);
    }

    public double getLinearOutput() {
        return 1 - ((timerUtil.getTime() / (double) duration) * endPoint);
    }

    public double getEndPoint() {
        return endPoint;
    }

    public void setEndPoint(double endPoint) {
        this.endPoint = endPoint;
    }

    public void reset() {
        timerUtil.reset();
    }

    public boolean isDone() {
        return timerUtil.hasTimeElapsed(duration);
    }

    public void changeDirection() {
        setDirection(direction.opposite());
    }

    public Direction getDirection() {
        return direction;
    }

    public void setDirection(Direction direction) {
        if (this.direction != direction) {
            this.direction = direction;
            timerUtil.setTime(System.currentTimeMillis() - (duration - Math.min(duration, timerUtil.getTime())));
        }
    }

    public void setDuration(int duration) {
        this.duration = duration;
    }

    protected boolean correctOutput() {
        return false;
    }

    public double getOutput() {
        if (direction == Direction.FORWARDS) {
            if (isDone())
                return endPoint;
            return (getEquation(timerUtil.getTime()) * endPoint);
        } else {
            if (isDone()) return 0;
            if (correctOutput()) {
                double revTime = Math.min(duration, Math.max(0, duration - timerUtil.getTime()));
                return getEquation(revTime) * endPoint;
            } else return (1 - getEquation(timerUtil.getTime())) * endPoint;
        }
    }


    //This is where the animation equation should go, for example, a logistic function. Output should range from 0 - 1.
    //This will take the timer's time as an input, x.
    protected abstract double getEquation(double x);

}

Direction:
package arctic.tech.util.animations;

public enum Direction {
    FORWARDS,
    BACKWARDS;

    public Direction opposite() {
        if (this == Direction.FORWARDS) {
            return Direction.BACKWARDS;
        } else return Direction.FORWARDS;
    }

}

DecelerateAnimation:
package arctic.tech.util.animations.impl;


import arctic.tech.util.animations.Animation;
import arctic.tech.util.animations.Direction;

public class DecelerateAnimation extends Animation {

    public DecelerateAnimation(int ms, double endPoint) {
        super(ms, endPoint);
    }

    public DecelerateAnimation(int ms, double endPoint, Direction direction) {
        super(ms, endPoint, direction);
    }

    protected double getEquation(double x) {
        double x1 = x / duration;
        return 1 - ((x1 - 1) * (x1 - 1));
    }
}

EaseBackIn
package arctic.tech.util.animations.impl;

import arctic.tech.util.animations.Animation;
import arctic.tech.util.animations.Direction;

public class EaseBackIn extends Animation {
    private final float easeAmount;

    public EaseBackIn(int ms, double endPoint, float easeAmount) {
        super(ms, endPoint);
        this.easeAmount = easeAmount;
    }

    public EaseBackIn(int ms, double endPoint, float easeAmount, Direction direction) {
        super(ms, endPoint, direction);
        this.easeAmount = easeAmount;
    }

    @Override
    protected boolean correctOutput() {
        return true;
    }

    @Override
    protected double getEquation(double x) {
        double x1 = x / duration;
        float shrink = easeAmount + 1;
        return Math.max(0, 1 + shrink * Math.pow(x1 - 1, 3) + easeAmount * Math.pow(x1 - 1, 2));
    }

}

EaseOutQuad:
package arctic.tech.util.animations.impl;

import arctic.tech.util.animations.Animation;
import arctic.tech.util.animations.Direction;

public class EaseInOutQuad extends Animation {

    public EaseInOutQuad(int ms, double endPoint) {
        super(ms, endPoint);
    }

    public EaseInOutQuad(int ms, double endPoint, Direction direction) {
        super(ms, endPoint, direction);
    }

    protected double getEquation(double x1) {
        double x = x1 / duration;
        return x < 0.5 ? 2 * Math.pow(x, 2) : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }

}

ElasticAnimation:
package arctic.tech.util.animations.impl;

import arctic.tech.util.animations.Animation;
import arctic.tech.util.animations.Direction;
import net.minecraft.util.math.MathHelper;

public class ElasticAnimation extends Animation {

    float easeAmount;
    float smooth;
    boolean reallyElastic;

    public ElasticAnimation(int ms, double endPoint, float elasticity, float smooth, boolean moreElasticity) {
        super(ms, endPoint);
        this.easeAmount = elasticity;
        this.smooth = smooth;
        this.reallyElastic = moreElasticity;
    }

    public ElasticAnimation(int ms, double endPoint, float elasticity, float smooth, boolean moreElasticity, Direction direction) {
        super(ms, endPoint, direction);
        this.easeAmount = elasticity;
        this.smooth = smooth;
        this.reallyElastic = moreElasticity;
    }

    @Override
    protected double getEquation(double x) {
        double x1 = Math.pow(x / duration, smooth); //Used to force input to range from 0 - 1
        double elasticity = easeAmount * .1f;
        return Math.pow(2, -10 * (reallyElastic ? Math.sqrt(x1) : x1)) * MathHelper.sin((x1 - (elasticity / 4)) * ((2 * Math.PI) / elasticity)) + 1;
    }
}

SmoothStepAnimation:
package arctic.tech.util.animations.impl;

import arctic.tech.util.animations.Animation;
import arctic.tech.util.animations.Direction;

public class SmoothStepAnimation extends Animation {

    public SmoothStepAnimation(int ms, double endPoint) {
        super(ms, endPoint);
    }

    public SmoothStepAnimation(int ms, double endPoint, Direction direction) {
        super(ms, endPoint, direction);
    }

    protected double getEquation(double x) {
        double x1 = x / (double) duration; //Used to force input to range from 0 - 1
        return -2 * Math.pow(x1, 3) + (3 * Math.pow(x1, 2));
    }

}

BindSetting:
package arctic.tech.modules.settings.imp;

import arctic.tech.modules.settings.Setting;
import lombok.Getter;
import lombok.Setter;

import java.util.function.Supplier;

@Getter
@Setter
public class BindSetting extends Setting {

    private int key;

    public BindSetting(String name, int defaultKey) {
        super(name);
        key = defaultKey;
    }
    public BindSetting setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }

    @Override
    public SettingType getType() {
        return SettingType.BIND_SETTING;
    }
}

BooleanOption:
package arctic.tech.modules.settings.imp;


import arctic.tech.modules.settings.Setting;

import java.util.function.Supplier;

public class BooleanOption extends Setting {
    private boolean value;
    private String desc;
    public float anim;

    public BooleanOption(String name, boolean value) {
        super(name);
        this.value = value;
    }

    public BooleanOption(String name, String desc, boolean value) {
        super(name);
        this.value = value;
        this.desc = desc;
    }

    public String getDesc() {
        return desc;
    }

    public boolean get() {
        return value;
    }

    public void toggle() {
        value = !value;
    }

    public void set(boolean value) {
        this.value = value;
    }

    public BooleanOption setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }


    @Override
    public SettingType getType() {
        return SettingType.BOOLEAN_OPTION;
    }
}

ButtonSetting:
package arctic.tech.modules.settings.imp;

import arctic.tech.modules.settings.Setting;
import lombok.Getter;
import lombok.Setter;

import java.util.function.Supplier;

@Getter
@Setter
public class ButtonSetting extends Setting {

    private Runnable run;

    public ButtonSetting(String name, Runnable run) {
        super(name);
        this.run = run;
    }
    public ButtonSetting setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }

    @Override
    public SettingType getType() {
        return SettingType.BUTTON_SETTING;
    }
}

ModeSetting:
package arctic.tech.modules.settings.imp;

import arctic.tech.modules.settings.Setting;
import lombok.Getter;
import lombok.Setter;

import java.util.Arrays;
import java.util.function.Supplier;

@Getter
public class ModeSetting extends Setting {
    @Setter
    private int index;
    public String[] modes;


    public ModeSetting(String name, String current, String... modes) {
        super(name);
        this.modes = modes;
        this.index = Arrays.asList(modes).indexOf(current);
    }

    public boolean is(String mode) {
        return get().equals(mode);
    }

    public String get() {
        try {
            if (index < 0 || index >= modes.length) {
                return modes[0];
            }
            return modes[index];
        } catch (ArrayIndexOutOfBoundsException e) {
            return "ERROR";
        }
    }

    public void set(String mode) {
        this.index = Arrays.asList(modes).indexOf(mode);
    }

    public void set(int mode) {
        this.index = mode;
    }

    public ModeSetting setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }

    @Override
    public SettingType getType() {
        return SettingType.MODE_SETTING;
    }
}

ColorSetting:
package arctic.tech.modules.settings.imp;

import arctic.tech.modules.settings.Setting;

import java.awt.*;
import java.util.function.Supplier;

public class ColorSetting extends Setting {
    public int color = 0;

    public ColorSetting(String name, int color) {
        super(name);
        this.color = color;
    }

    public int get() {
        return color;
    }

    public Color getColor() {
        return new Color(color);
    }

    public ColorSetting setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }

    @Override
    public SettingType getType() {
        return SettingType.COLOR_SETTING;
    }
}

MultiBoxSetting:
package arctic.tech.modules.settings.imp;

import arctic.tech.modules.settings.Setting;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class MultiBoxSetting extends Setting {
    public List<BooleanOption> options;
    public int index;
    public float animation;

    public MultiBoxSetting(String name, BooleanOption... options) {
        super(name);
        this.options = List.of(options);
    }

    public boolean get(String name) {
        return Objects.requireNonNull(this.options.stream().filter((option) -> option.getName().equalsIgnoreCase(name)).findFirst().orElse(null)).get();
    }

    public void set(String name, boolean value) {
        Objects.requireNonNull(this.options.stream().filter((option) -> option.getName().equalsIgnoreCase(name)).findFirst().orElse(null)).set(value);
    }

    public List<BooleanOption> getToggled() {
        return this.options.stream().filter(BooleanOption::get).collect(Collectors.toList());
    }

    public String get() {
        List<String> includedOptions = new ArrayList<>();
        for (BooleanOption option : options) {
            if (option.get()) {
                includedOptions.add(option.getName());
            }
        }
        return String.join(", ", includedOptions);
    }

    public void set(int index, boolean value) {
        this.options.get(index).set(value);
    }

    public boolean get(int index) {
        return this.options.get(index).get();
    }

    public MultiBoxSetting setVisible(Supplier<Boolean> bool) {
        this.visible = bool;
        return this;
    }

    @Override
    public SettingType getType() {
        return SettingType.MULTI_BOX_SETTING;
    }
}

SliderSetting:
package arctic.tech.modules.settings.imp;


import arctic.tech.modules.settings.Setting;
import lombok.Getter;
import net.minecraft.util.math.MathHelper;

import java.util.function.Supplier;

public class SliderSetting extends Setting {
    private float value;
    @Getter
    private final float min;
    @Getter
    private final float max;
    @Getter
    private final float increment;


    public SliderSetting(String name, float value, float min, float max, float increment) {
        super(name);
        this.value = value;
        this.min = min;
        this.max = max;
        this.increment = increment;

    }

    public SliderSetting setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }

    public Number getValue() {
        return MathHelper.clamp(value, getMin(), getMax());
    }

    public void setValue(float value) {
        this.value = MathHelper.clamp(value, getMin(), getMax());
    }

    @Override
    public SettingType getType() {
        return SettingType.SLIDER_SETTING;
    }
}

TextSetting:
package arctic.tech.modules.settings.imp;

import arctic.tech.modules.settings.Setting;

import java.util.function.Supplier;

public class TextSetting extends Setting {
    public String text;

    public TextSetting(String name, String text) {
        super(name);
       this.text = text;
    }

    public String get() {
        return text;
    }

    public TextSetting setVisible(Supplier<Boolean> bool) {
        visible = bool;
        return this;
    }

    @Override
    public SettingType getType() {
        return SettingType.TEXT_SETTING;
    }
}

Hand:
package net.minecraft.util;

public enum Hand
{
    MAIN_HAND,
    OFF_HAND;
}

CClickWindowPacket:
package net.minecraft.network.play.client;

import java.io.IOException;
import net.minecraft.inventory.container.ClickType;
import net.minecraft.item.ItemStack;
import net.minecraft.network.IPacket;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.play.IServerPlayNetHandler;

public class CClickWindowPacket implements IPacket<IServerPlayNetHandler>
{
    /** The id of the window which was clicked. 0 for player inventory. */
    private int windowId;

    /** Id of the clicked slot */
    private int slotId;

    /** Button used */
    private int packedClickData;

    /** A unique number for the action, used for transaction handling */
    private short actionNumber;

    /** The item stack present in the slot */
    private ItemStack clickedItem = ItemStack.EMPTY;

    /** Inventory operation mode */
    private ClickType mode;

    public CClickWindowPacket()
    {
    }

    public CClickWindowPacket(int windowIdIn, int slotIdIn, int usedButtonIn, ClickType modeIn, ItemStack clickedItemIn, short actionNumberIn)
    {
        this.windowId = windowIdIn;
        this.slotId = slotIdIn;
        this.packedClickData = usedButtonIn;
        this.clickedItem = clickedItemIn.copy();
        this.actionNumber = actionNumberIn;
        this.mode = modeIn;
    }

    /**
     * Passes this Packet on to the NetHandler for processing.
     */
    public void processPacket(IServerPlayNetHandler handler)
    {
        handler.processClickWindow(this);
    }

    /**
     * Reads the raw packet data from the data stream.
     */
    public void readPacketData(PacketBuffer buf) throws IOException
    {
        this.windowId = buf.readByte();
        this.slotId = buf.readShort();
        this.packedClickData = buf.readByte();
        this.actionNumber = buf.readShort();
        this.mode = buf.readEnumValue(ClickType.class);
        this.clickedItem = buf.readItemStack();
    }

    /**
     * Writes the raw packet data to the data stream.
     */
    public void writePacketData(PacketBuffer buf) throws IOException
    {
        buf.writeByte(this.windowId);
        buf.writeShort(this.slotId);
        buf.writeByte(this.packedClickData);
        buf.writeShort(this.actionNumber);
        buf.writeEnumValue(this.mode);
        buf.writeItemStack(this.clickedItem);
    }

    public int getWindowId()
    {
        return this.windowId;
    }

    public int getSlotId()
    {
        return this.slotId;
    }

    public int getUsedButton()
    {
        return this.packedClickData;
    }

    public short getActionNumber()
    {
        return this.actionNumber;
    }

    public ItemStack getClickedItem()
    {
        return this.clickedItem;
    }

    public ClickType getClickType()
    {
        return this.mode;
    }
}

CPlayerPacket:
package net.minecraft.network.play.client;

import java.io.IOException;
import net.minecraft.network.IPacket;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.play.IServerPlayNetHandler;

public class CPlayerPacket implements IPacket<IServerPlayNetHandler>
{
    public double x;
    public double y;
    public double z;
    public float yaw;
    public float pitch;
    public boolean onGround;
    public boolean moving;
    public boolean rotating;

    public CPlayerPacket()
    {
    }

    public CPlayerPacket(boolean onGroundIn)
    {
        this.onGround = onGroundIn;
    }

    /**
     * Passes this Packet on to the NetHandler for processing.
     */
    public void processPacket(IServerPlayNetHandler handler)
    {
        handler.processPlayer(this);
    }

    /**
     * Reads the raw packet data from the data stream.
     */
    public void readPacketData(PacketBuffer buf) throws IOException
    {
        this.onGround = buf.readUnsignedByte() != 0;
    }

    /**
     * Writes the raw packet data to the data stream.
     */
    public void writePacketData(PacketBuffer buf) throws IOException
    {
        buf.writeByte(this.onGround ? 1 : 0);
    }

    public double getX(double defaultValue)
    {
        return this.moving ? this.x : defaultValue;
    }

    public double getY(double defaultValue)
    {
        return this.moving ? this.y : defaultValue;
    }

    public double getZ(double defaultValue)
    {
        return this.moving ? this.z : defaultValue;
    }

    public float getYaw(float defaultValue)
    {
        return this.rotating ? this.yaw : defaultValue;
    }

    public float getPitch(float defaultValue)
    {
        return this.rotating ? this.pitch : defaultValue;
    }

    public boolean isOnGround()
    {
        return this.onGround;
    }

    public static class PositionPacket extends CPlayerPacket
    {
        public PositionPacket()
        {
            this.moving = true;
        }

        public PositionPacket(double xIn, double yIn, double zIn, boolean onGroundIn)
        {
            this.x = xIn;
            this.y = yIn;
            this.z = zIn;
            this.onGround = onGroundIn;
            this.moving = true;
        }

        public void readPacketData(PacketBuffer buf) throws IOException
        {
            this.x = buf.readDouble();
            this.y = buf.readDouble();
            this.z = buf.readDouble();
            super.readPacketData(buf);
        }

        public void writePacketData(PacketBuffer buf) throws IOException
        {
            buf.writeDouble(this.x);
            buf.writeDouble(this.y);
            buf.writeDouble(this.z);
            super.writePacketData(buf);
        }
    }

    public static class PositionRotationPacket extends CPlayerPacket
    {
        public PositionRotationPacket()
        {
            this.moving = true;
            this.rotating = true;
        }

        public PositionRotationPacket(double xIn, double yIn, double zIn, float yawIn, float pitchIn, boolean onGroundIn)
        {
            this.x = xIn;
            this.y = yIn;
            this.z = zIn;
            this.yaw = yawIn;
            this.pitch = pitchIn;
            this.onGround = onGroundIn;
            this.rotating = true;
            this.moving = true;
        }

        public void readPacketData(PacketBuffer buf) throws IOException
        {
            this.x = buf.readDouble();
            this.y = buf.readDouble();
            this.z = buf.readDouble();
            this.yaw = buf.readFloat();
            this.pitch = buf.readFloat();
            super.readPacketData(buf);
        }

        public void writePacketData(PacketBuffer buf) throws IOException
        {
            buf.writeDouble(this.x);
            buf.writeDouble(this.y);
            buf.writeDouble(this.z);
            buf.writeFloat(this.yaw);
            buf.writeFloat(this.pitch);
            super.writePacketData(buf);
        }
    }

    public static class RotationPacket extends CPlayerPacket
    {
        public RotationPacket()
        {
            this.rotating = true;
        }

        public RotationPacket(float yawIn, float pitchIn, boolean onGroundIn)
        {
            this.yaw = yawIn;
            this.pitch = pitchIn;
            this.onGround = onGroundIn;
            this.rotating = true;
        }

        public void readPacketData(PacketBuffer buf) throws IOException
        {
            this.yaw = buf.readFloat();
            this.pitch = buf.readFloat();
            super.readPacketData(buf);
        }

        public void writePacketData(PacketBuffer buf) throws IOException
        {
            buf.writeFloat(this.yaw);
            buf.writeFloat(this.pitch);
            super.writePacketData(buf);
        }
    }
}

CPlayerTryUseItemPacket:
package net.minecraft.network.play.client;

import java.io.IOException;
import net.minecraft.network.IPacket;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.play.IServerPlayNetHandler;
import net.minecraft.util.Hand;

public class CPlayerTryUseItemPacket implements IPacket<IServerPlayNetHandler>
{
    private Hand hand;

    public CPlayerTryUseItemPacket()
    {
    }

    public CPlayerTryUseItemPacket(Hand handIn)
    {
        this.hand = handIn;
    }

    /**
     * Reads the raw packet data from the data stream.
     */
    public void readPacketData(PacketBuffer buf) throws IOException
    {
        this.hand = buf.readEnumValue(Hand.class);
    }

    /**
     * Writes the raw packet data to the data stream.
     */
    public void writePacketData(PacketBuffer buf) throws IOException
    {
        buf.writeEnumValue(this.hand);
    }

    /**
     * Passes this Packet on to the NetHandler for processing.
     */
    public void processPacket(IServerPlayNetHandler handler)
    {
        handler.processTryUseItem(this);
    }

    public Hand getHand()
    {
        return this.hand;
    }
}

CHeldItemChangePacket:
package net.minecraft.network.play.client;

import java.io.IOException;
import net.minecraft.network.IPacket;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.play.IServerPlayNetHandler;

public class CHeldItemChangePacket implements IPacket<IServerPlayNetHandler>
{
    private int slotId;

    public CHeldItemChangePacket()
    {
    }

    public CHeldItemChangePacket(int slotIdIn)
    {
        this.slotId = slotIdIn;
    }

    /**
     * Reads the raw packet data from the data stream.
     */
    public void readPacketData(PacketBuffer buf) throws IOException
    {
        this.slotId = buf.readShort();
    }

    /**
     * Writes the raw packet data to the data stream.
     */
    public void writePacketData(PacketBuffer buf) throws IOException
    {
        buf.writeShort(this.slotId);
    }

    /**
     * Passes this Packet on to the NetHandler for processing.
     */
    public void processPacket(IServerPlayNetHandler handler)
    {
        handler.processHeldItemChange(this);
    }

    public int getSlotId()
    {
        return this.slotId;
    }
}
